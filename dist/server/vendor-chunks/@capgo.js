"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@capgo";
exports.ids = ["vendor-chunks/@capgo"];
exports.modules = {

/***/ "(ssr)/./node_modules/@capgo/capacitor-social-login/dist/plugin.cjs.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@capgo/capacitor-social-login/dist/plugin.cjs.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar core = __webpack_require__(/*! @capacitor/core */ \"(ssr)/./node_modules/@capacitor/core/dist/index.cjs.js\");\n\nconst SocialLogin = core.registerPlugin('SocialLogin', {\n    web: () => Promise.resolve().then(function () { return web; }).then((m) => new m.SocialLoginWeb()),\n});\n\nclass BaseSocialLogin extends core.WebPlugin {\n    constructor() {\n        super();\n    }\n    parseJwt(token) {\n        const base64Url = token.split('.')[1];\n        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\n        const jsonPayload = decodeURIComponent(atob(base64)\n            .split('')\n            .map((c) => {\n            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n        })\n            .join(''));\n        return JSON.parse(jsonPayload);\n    }\n    async loadScript(src) {\n        return new Promise((resolve, reject) => {\n            const script = document.createElement('script');\n            script.src = src;\n            script.async = true;\n            script.onload = () => {\n                resolve();\n            };\n            script.onerror = reject;\n            document.body.appendChild(script);\n        });\n    }\n}\nBaseSocialLogin.OAUTH_STATE_KEY = 'social_login_oauth_pending';\n\nclass AppleSocialLogin extends BaseSocialLogin {\n    constructor() {\n        super(...arguments);\n        this.clientId = null;\n        this.redirectUrl = null;\n        this.scriptLoaded = false;\n        this.scriptUrl = 'https://appleid.cdn-apple.com/appleauth/static/jsapi/appleid/1/en_US/appleid.auth.js';\n        this.useProperTokenExchange = false;\n    }\n    async initialize(clientId, redirectUrl, useProperTokenExchange = false) {\n        this.clientId = clientId;\n        this.redirectUrl = redirectUrl || null;\n        this.useProperTokenExchange = useProperTokenExchange;\n        if (clientId) {\n            await this.loadAppleScript();\n        }\n    }\n    async login(options) {\n        if (!this.clientId) {\n            throw new Error('Apple Client ID not set. Call initialize() first.');\n        }\n        if (!this.scriptLoaded) {\n            throw new Error('Apple Sign-In script not loaded.');\n        }\n        return new Promise((resolve, reject) => {\n            var _a;\n            AppleID.auth.init({\n                clientId: this.clientId,\n                scope: ((_a = options.scopes) === null || _a === void 0 ? void 0 : _a.join(' ')) || 'name email',\n                redirectURI: this.redirectUrl || window.location.href,\n                state: options.state,\n                nonce: options.nonce,\n                usePopup: true,\n            });\n            AppleID.auth\n                .signIn()\n                .then((res) => {\n                var _a, _b, _c, _d, _e;\n                let accessToken = null;\n                if (this.useProperTokenExchange) {\n                    // When using proper token exchange, the authorization code should be exchanged\n                    // for a proper access token on the backend. For now, we set accessToken to null\n                    // and provide the authorization code in a separate field for backend processing.\n                    accessToken = null;\n                }\n                else {\n                    // Legacy behavior: use authorization code as access token for backward compatibility\n                    accessToken = {\n                        token: res.authorization.code || '',\n                    };\n                }\n                const result = Object.assign({ profile: {\n                        user: res.user || '',\n                        email: ((_a = res.user) === null || _a === void 0 ? void 0 : _a.email) || null,\n                        givenName: ((_c = (_b = res.user) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.firstName) || null,\n                        familyName: ((_e = (_d = res.user) === null || _d === void 0 ? void 0 : _d.name) === null || _e === void 0 ? void 0 : _e.lastName) || null,\n                    }, accessToken: accessToken, idToken: res.authorization.id_token || null }, (this.useProperTokenExchange && { authorizationCode: res.authorization.code }));\n                resolve({ provider: 'apple', result });\n            })\n                .catch((error) => {\n                reject(error);\n            });\n        });\n    }\n    async logout() {\n        // Apple doesn't provide a logout method for web\n        console.log('Apple logout: Session should be managed on the client side');\n    }\n    async isLoggedIn() {\n        // Apple doesn't provide a method to check login status on web\n        console.log('Apple login status should be managed on the client side');\n        return { isLoggedIn: false };\n    }\n    async getAuthorizationCode() {\n        // Apple authorization code should be obtained during login\n        console.log('Apple authorization code should be stored during login');\n        throw new Error('Apple authorization code not available');\n    }\n    async refresh() {\n        // Apple doesn't provide a refresh method for web\n        console.log('Apple refresh not available on web');\n    }\n    async loadAppleScript() {\n        if (this.scriptLoaded)\n            return;\n        return this.loadScript(this.scriptUrl).then(() => {\n            this.scriptLoaded = true;\n        });\n    }\n}\n\nclass FacebookSocialLogin extends BaseSocialLogin {\n    constructor() {\n        super(...arguments);\n        this.appId = null;\n        this.scriptLoaded = false;\n        this.locale = 'en_US';\n    }\n    async initialize(appId, locale) {\n        this.appId = appId;\n        if (locale) {\n            this.locale = locale;\n        }\n        if (appId) {\n            // Load with the specified locale or default\n            await this.loadFacebookScript(this.locale);\n            FB.init({\n                appId: this.appId,\n                version: 'v17.0',\n                xfbml: true,\n                cookie: true,\n            });\n        }\n    }\n    async login(options) {\n        if (!this.appId) {\n            throw new Error('Facebook App ID not set. Call initialize() first.');\n        }\n        return new Promise((resolve, reject) => {\n            FB.login((response) => {\n                if (response.status === 'connected') {\n                    FB.api('/me', { fields: 'id,name,email,picture' }, (userInfo) => {\n                        var _a, _b;\n                        const result = {\n                            accessToken: {\n                                token: response.authResponse.accessToken,\n                                userId: response.authResponse.userID,\n                            },\n                            profile: {\n                                userID: userInfo.id,\n                                name: userInfo.name,\n                                email: userInfo.email || null,\n                                imageURL: ((_b = (_a = userInfo.picture) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.url) || null,\n                                friendIDs: [],\n                                birthday: null,\n                                ageRange: null,\n                                gender: null,\n                                location: null,\n                                hometown: null,\n                                profileURL: null,\n                            },\n                            idToken: null,\n                        };\n                        resolve({ provider: 'facebook', result });\n                    });\n                }\n                else {\n                    reject(new Error('Facebook login failed'));\n                }\n            }, { scope: options.permissions.join(',') });\n        });\n    }\n    async logout() {\n        return new Promise((resolve) => {\n            FB.logout(() => resolve());\n        });\n    }\n    async isLoggedIn() {\n        return new Promise((resolve) => {\n            FB.getLoginStatus((response) => {\n                resolve({ isLoggedIn: response.status === 'connected' });\n            });\n        });\n    }\n    async getAuthorizationCode() {\n        return new Promise((resolve, reject) => {\n            FB.getLoginStatus((response) => {\n                var _a;\n                if (response.status === 'connected') {\n                    resolve({ jwt: ((_a = response.authResponse) === null || _a === void 0 ? void 0 : _a.accessToken) || '' });\n                }\n                else {\n                    reject(new Error('No Facebook authorization code available'));\n                }\n            });\n        });\n    }\n    async refresh(options) {\n        await this.login(options);\n    }\n    async loadFacebookScript(locale) {\n        if (this.scriptLoaded)\n            return;\n        // Remove any existing Facebook SDK script\n        const existingScript = document.querySelector('script[src*=\"connect.facebook.net\"]');\n        if (existingScript) {\n            existingScript.remove();\n        }\n        return this.loadScript(`https://connect.facebook.net/${locale}/sdk.js`).then(() => {\n            this.scriptLoaded = true;\n        });\n    }\n}\n\nclass GoogleSocialLogin extends BaseSocialLogin {\n    constructor() {\n        super(...arguments);\n        this.clientId = null;\n        this.loginType = 'online';\n        this.GOOGLE_TOKEN_REQUEST_URL = 'https://www.googleapis.com/oauth2/v3/tokeninfo';\n        this.GOOGLE_STATE_KEY = 'capgo_social_login_google_state';\n    }\n    async initialize(clientId, mode, hostedDomain, redirectUrl) {\n        this.clientId = clientId;\n        if (mode) {\n            this.loginType = mode;\n        }\n        this.hostedDomain = hostedDomain;\n        this.redirectUrl = redirectUrl;\n    }\n    async login(options) {\n        if (!this.clientId) {\n            throw new Error('Google Client ID not set. Call initialize() first.');\n        }\n        let scopes = options.scopes || [];\n        if (scopes.length > 0) {\n            // If scopes are provided, directly use the traditional OAuth flow\n            if (!scopes.includes('https://www.googleapis.com/auth/userinfo.email')) {\n                scopes.push('https://www.googleapis.com/auth/userinfo.email');\n            }\n            if (!scopes.includes('https://www.googleapis.com/auth/userinfo.profile')) {\n                scopes.push('https://www.googleapis.com/auth/userinfo.profile');\n            }\n            if (!scopes.includes('openid')) {\n                scopes.push('openid');\n            }\n        }\n        else {\n            scopes = [\n                'https://www.googleapis.com/auth/userinfo.email',\n                'https://www.googleapis.com/auth/userinfo.profile',\n                'openid',\n            ];\n        }\n        const nonce = options.nonce || Math.random().toString(36).substring(2);\n        // If scopes are provided, directly use the traditional OAuth flow\n        return this.traditionalOAuth({\n            scopes,\n            nonce,\n            hostedDomain: this.hostedDomain,\n        });\n    }\n    async logout() {\n        if (this.loginType === 'offline') {\n            return Promise.reject(\"Offline login doesn't store tokens. logout is not available\");\n        }\n        // eslint-disable-next-line\n        const state = this.getGoogleState();\n        if (!state)\n            return;\n        await this.rawLogoutGoogle(state.accessToken);\n    }\n    async isLoggedIn() {\n        if (this.loginType === 'offline') {\n            return Promise.reject(\"Offline login doesn't store tokens. isLoggedIn is not available\");\n        }\n        // eslint-disable-next-line\n        const state = this.getGoogleState();\n        if (!state)\n            return { isLoggedIn: false };\n        try {\n            const isValidAccessToken = await this.accessTokenIsValid(state.accessToken);\n            const isValidIdToken = this.idTokenValid(state.idToken);\n            if (isValidAccessToken && isValidIdToken) {\n                return { isLoggedIn: true };\n            }\n            else {\n                try {\n                    await this.rawLogoutGoogle(state.accessToken, false);\n                }\n                catch (e) {\n                    console.error('Access token is not valid, but cannot logout', e);\n                }\n                return { isLoggedIn: false };\n            }\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    async getAuthorizationCode() {\n        if (this.loginType === 'offline') {\n            return Promise.reject(\"Offline login doesn't store tokens. getAuthorizationCode is not available\");\n        }\n        // eslint-disable-next-line\n        const state = this.getGoogleState();\n        if (!state)\n            throw new Error('No Google authorization code available');\n        try {\n            const isValidAccessToken = await this.accessTokenIsValid(state.accessToken);\n            const isValidIdToken = this.idTokenValid(state.idToken);\n            if (isValidAccessToken && isValidIdToken) {\n                return { accessToken: state.accessToken, jwt: state.idToken };\n            }\n            else {\n                try {\n                    await this.rawLogoutGoogle(state.accessToken, false);\n                }\n                catch (e) {\n                    console.error('Access token is not valid, but cannot logout', e);\n                }\n                throw new Error('No Google authorization code available');\n            }\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    async refresh() {\n        // For Google, we can prompt for re-authentication\n        return Promise.reject('Not implemented');\n    }\n    handleOAuthRedirect(url) {\n        const paramsRaw = url.searchParams;\n        const code = paramsRaw.get('code');\n        if (code && paramsRaw.has('scope')) {\n            return {\n                provider: 'google',\n                result: {\n                    serverAuthCode: code,\n                    responseType: 'offline',\n                },\n            };\n        }\n        const hash = url.hash.substring(1);\n        console.log('handleOAuthRedirect', url.hash);\n        if (!hash)\n            return null;\n        console.log('handleOAuthRedirect ok');\n        const params = new URLSearchParams(hash);\n        const accessToken = params.get('access_token');\n        const idToken = params.get('id_token');\n        if (accessToken && idToken) {\n            localStorage.removeItem(BaseSocialLogin.OAUTH_STATE_KEY);\n            const profile = this.parseJwt(idToken);\n            return {\n                provider: 'google',\n                result: {\n                    accessToken: {\n                        token: accessToken,\n                    },\n                    idToken,\n                    profile: {\n                        email: profile.email || null,\n                        familyName: profile.family_name || null,\n                        givenName: profile.given_name || null,\n                        id: profile.sub || null,\n                        name: profile.name || null,\n                        imageUrl: profile.picture || null,\n                    },\n                    responseType: 'online',\n                },\n            };\n        }\n        return null;\n    }\n    async accessTokenIsValid(accessToken) {\n        const url = `${this.GOOGLE_TOKEN_REQUEST_URL}?access_token=${encodeURIComponent(accessToken)}`;\n        try {\n            // Make the GET request using fetch\n            const response = await fetch(url);\n            // Check if the response is successful\n            if (!response.ok) {\n                console.log(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response not successful. Status code: ${response.status}. Assuming that the token is not valid`);\n                return false;\n            }\n            // Get the response body as text\n            const responseBody = await response.text();\n            if (!responseBody) {\n                console.error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response body is null`);\n                throw new Error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response body is null`);\n            }\n            // Parse the response body as JSON\n            let jsonObject;\n            try {\n                jsonObject = JSON.parse(responseBody);\n            }\n            catch (e) {\n                console.error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response body is not valid JSON. Error: ${e}`);\n                throw new Error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response body is not valid JSON. Error: ${e}`);\n            }\n            // Extract the 'expires_in' field\n            const expiresInStr = jsonObject['expires_in'];\n            if (expiresInStr === undefined || expiresInStr === null) {\n                console.error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response JSON does not include 'expires_in'.`);\n                throw new Error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. Response JSON does not include 'expires_in'.`);\n            }\n            // Parse 'expires_in' as an integer\n            let expiresInInt;\n            try {\n                expiresInInt = parseInt(expiresInStr, 10);\n                if (isNaN(expiresInInt)) {\n                    throw new Error(`'expires_in' is not a valid integer`);\n                }\n            }\n            catch (e) {\n                console.error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. 'expires_in': ${expiresInStr} is not a valid integer. Error: ${e}`);\n                throw new Error(`Invalid response from ${this.GOOGLE_TOKEN_REQUEST_URL}. 'expires_in': ${expiresInStr} is not a valid integer. Error: ${e}`);\n            }\n            // Determine if the access token is valid based on 'expires_in'\n            return expiresInInt > 5;\n        }\n        catch (error) {\n            console.error(error);\n            throw error;\n        }\n    }\n    idTokenValid(idToken) {\n        try {\n            const parsed = this.parseJwt(idToken);\n            const currentTime = Math.ceil(Date.now() / 1000) + 5; // Convert current time to seconds since epoch\n            return parsed.exp && currentTime < parsed.exp;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    async rawLogoutGoogle(accessToken, tokenValid = null) {\n        if (tokenValid === null) {\n            tokenValid = await this.accessTokenIsValid(accessToken);\n        }\n        if (tokenValid === true) {\n            try {\n                await fetch(`https://accounts.google.com/o/oauth2/revoke?token=${encodeURIComponent(accessToken)}`);\n                this.clearStateGoogle();\n            }\n            catch (e) {\n                // ignore\n            }\n            return;\n        }\n        else {\n            this.clearStateGoogle();\n            return;\n        }\n    }\n    persistStateGoogle(accessToken, idToken) {\n        try {\n            window.localStorage.setItem(this.GOOGLE_STATE_KEY, JSON.stringify({ accessToken, idToken }));\n        }\n        catch (e) {\n            console.error('Cannot persist state google', e);\n        }\n    }\n    clearStateGoogle() {\n        try {\n            window.localStorage.removeItem(this.GOOGLE_STATE_KEY);\n        }\n        catch (e) {\n            console.error('Cannot clear state google', e);\n        }\n    }\n    getGoogleState() {\n        try {\n            const state = window.localStorage.getItem(this.GOOGLE_STATE_KEY);\n            if (!state)\n                return null;\n            const { accessToken, idToken } = JSON.parse(state);\n            return { accessToken, idToken };\n        }\n        catch (e) {\n            console.error('Cannot get state google', e);\n            return null;\n        }\n    }\n    async traditionalOAuth({ scopes, hostedDomain, nonce, }) {\n        const uniqueScopes = [...new Set([...(scopes || []), 'openid'])];\n        const params = new URLSearchParams(Object.assign(Object.assign({ client_id: this.clientId, redirect_uri: this.redirectUrl || window.location.origin + window.location.pathname, response_type: this.loginType === 'offline' ? 'code' : 'token id_token', scope: uniqueScopes.join(' ') }, (nonce && { nonce })), { include_granted_scopes: 'true', state: 'popup' }));\n        if (hostedDomain !== undefined) {\n            params.append('hd', hostedDomain);\n        }\n        const url = `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;\n        const width = 500;\n        const height = 600;\n        const left = window.screenX + (window.outerWidth - width) / 2;\n        const top = window.screenY + (window.outerHeight - height) / 2;\n        localStorage.setItem(BaseSocialLogin.OAUTH_STATE_KEY, 'true');\n        const popup = window.open(url, 'Google Sign In', `width=${width},height=${height},left=${left},top=${top},popup=1`);\n        let popupClosedInterval;\n        let timeoutHandle;\n        // This may never return...\n        return new Promise((resolve, reject) => {\n            if (!popup) {\n                reject(new Error('Failed to open popup'));\n                return;\n            }\n            const handleMessage = (event) => {\n                var _a, _b, _c;\n                if (event.origin !== window.location.origin || ((_b = (_a = event.data) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.startsWith('angular')))\n                    return;\n                if (((_c = event.data) === null || _c === void 0 ? void 0 : _c.type) === 'oauth-response') {\n                    window.removeEventListener('message', handleMessage);\n                    clearInterval(popupClosedInterval);\n                    if (this.loginType === 'online') {\n                        const { accessToken, idToken } = event.data;\n                        if (accessToken && idToken) {\n                            const profile = this.parseJwt(idToken);\n                            this.persistStateGoogle(accessToken.token, idToken);\n                            resolve({\n                                provider: 'google',\n                                result: {\n                                    accessToken: {\n                                        token: accessToken.token,\n                                    },\n                                    idToken,\n                                    profile: {\n                                        email: profile.email || null,\n                                        familyName: profile.family_name || null,\n                                        givenName: profile.given_name || null,\n                                        id: profile.sub || null,\n                                        name: profile.name || null,\n                                        imageUrl: profile.picture || null,\n                                    },\n                                    responseType: 'online',\n                                },\n                            });\n                        }\n                    }\n                    else {\n                        const { serverAuthCode } = event.data;\n                        resolve({\n                            provider: 'google',\n                            result: {\n                                responseType: 'offline',\n                                serverAuthCode,\n                            },\n                        });\n                    }\n                }\n                // Don't reject for non-OAuth messages, just ignore them\n            };\n            window.addEventListener('message', handleMessage);\n            // Timeout after 5 minutes\n            timeoutHandle = setTimeout(() => {\n                clearTimeout(timeoutHandle);\n                window.removeEventListener('message', handleMessage);\n                popup.close();\n                reject(new Error('OAuth timeout'));\n            }, 300000);\n            popupClosedInterval = setInterval(() => {\n                if (popup.closed) {\n                    clearInterval(popupClosedInterval);\n                    reject(new Error('Popup closed'));\n                }\n            }, 1000);\n        });\n    }\n}\n\nclass SocialLoginWeb extends core.WebPlugin {\n    constructor() {\n        var _a;\n        super();\n        this.googleProvider = new GoogleSocialLogin();\n        this.appleProvider = new AppleSocialLogin();\n        this.facebookProvider = new FacebookSocialLogin();\n        // Set up listener for OAuth redirects if we have a pending OAuth flow\n        if (localStorage.getItem(SocialLoginWeb.OAUTH_STATE_KEY)) {\n            console.log('OAUTH_STATE_KEY found');\n            const result = this.handleOAuthRedirect();\n            if (result) {\n                (_a = window.opener) === null || _a === void 0 ? void 0 : _a.postMessage(Object.assign({ type: 'oauth-response' }, result.result), window.location.origin);\n                window.close();\n            }\n        }\n    }\n    handleOAuthRedirect() {\n        const url = new URL(window.location.href);\n        return this.googleProvider.handleOAuthRedirect(url);\n    }\n    async initialize(options) {\n        var _a, _b, _c;\n        const initPromises = [];\n        if ((_a = options.google) === null || _a === void 0 ? void 0 : _a.webClientId) {\n            initPromises.push(this.googleProvider.initialize(options.google.webClientId, options.google.mode, options.google.hostedDomain, options.google.redirectUrl));\n        }\n        if ((_b = options.apple) === null || _b === void 0 ? void 0 : _b.clientId) {\n            initPromises.push(this.appleProvider.initialize(options.apple.clientId, options.apple.redirectUrl, options.apple.useProperTokenExchange));\n        }\n        if ((_c = options.facebook) === null || _c === void 0 ? void 0 : _c.appId) {\n            initPromises.push(this.facebookProvider.initialize(options.facebook.appId, options.facebook.locale));\n        }\n        await Promise.all(initPromises);\n    }\n    async login(options) {\n        switch (options.provider) {\n            case 'google':\n                return this.googleProvider.login(options.options);\n            case 'apple':\n                return this.appleProvider.login(options.options);\n            case 'facebook':\n                return this.facebookProvider.login(options.options);\n            default:\n                throw new Error(`Login for ${options.provider} is not implemented on web`);\n        }\n    }\n    async logout(options) {\n        switch (options.provider) {\n            case 'google':\n                return this.googleProvider.logout();\n            case 'apple':\n                return this.appleProvider.logout();\n            case 'facebook':\n                return this.facebookProvider.logout();\n            default:\n                throw new Error(`Logout for ${options.provider} is not implemented`);\n        }\n    }\n    async isLoggedIn(options) {\n        switch (options.provider) {\n            case 'google':\n                return this.googleProvider.isLoggedIn();\n            case 'apple':\n                return this.appleProvider.isLoggedIn();\n            case 'facebook':\n                return this.facebookProvider.isLoggedIn();\n            default:\n                throw new Error(`isLoggedIn for ${options.provider} is not implemented`);\n        }\n    }\n    async getAuthorizationCode(options) {\n        switch (options.provider) {\n            case 'google':\n                return this.googleProvider.getAuthorizationCode();\n            case 'apple':\n                return this.appleProvider.getAuthorizationCode();\n            case 'facebook':\n                return this.facebookProvider.getAuthorizationCode();\n            default:\n                throw new Error(`getAuthorizationCode for ${options.provider} is not implemented`);\n        }\n    }\n    async refresh(options) {\n        switch (options.provider) {\n            case 'google':\n                return this.googleProvider.refresh();\n            case 'apple':\n                return this.appleProvider.refresh();\n            case 'facebook':\n                return this.facebookProvider.refresh(options.options);\n            default:\n                throw new Error(`Refresh for ${options.provider} is not implemented`);\n        }\n    }\n    async providerSpecificCall(options) {\n        throw new Error(`Provider specific call for ${options.call} is not implemented`);\n    }\n}\nSocialLoginWeb.OAUTH_STATE_KEY = 'social_login_oauth_pending';\n\nvar web = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    SocialLoginWeb: SocialLoginWeb\n});\n\nexports.SocialLogin = SocialLogin;\n//# sourceMappingURL=plugin.cjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNhcGdvL2NhcGFjaXRvci1zb2NpYWwtbG9naW4vZGlzdC9wbHVnaW4uY2pzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQywrRUFBaUI7O0FBRXBDO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakUsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5RUFBeUUsb0NBQW9DLDJDQUEyQztBQUM3SywwQkFBMEIsMkJBQTJCO0FBQ3JELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBLENBQUM7O0FBRUQsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9kZXJuaXplLW5leHQtc3RhcnRlcmtpdC8uL25vZGVfbW9kdWxlcy9AY2FwZ28vY2FwYWNpdG9yLXNvY2lhbC1sb2dpbi9kaXN0L3BsdWdpbi5janMuanM/MzZhMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBjb3JlID0gcmVxdWlyZSgnQGNhcGFjaXRvci9jb3JlJyk7XG5cbmNvbnN0IFNvY2lhbExvZ2luID0gY29yZS5yZWdpc3RlclBsdWdpbignU29jaWFsTG9naW4nLCB7XG4gICAgd2ViOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHdlYjsgfSkudGhlbigobSkgPT4gbmV3IG0uU29jaWFsTG9naW5XZWIoKSksXG59KTtcblxuY2xhc3MgQmFzZVNvY2lhbExvZ2luIGV4dGVuZHMgY29yZS5XZWJQbHVnaW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBwYXJzZUp3dCh0b2tlbikge1xuICAgICAgICBjb25zdCBiYXNlNjRVcmwgPSB0b2tlbi5zcGxpdCgnLicpWzFdO1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjRVcmwucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKTtcbiAgICAgICAgY29uc3QganNvblBheWxvYWQgPSBkZWNvZGVVUklDb21wb25lbnQoYXRvYihiYXNlNjQpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gJyUnICsgKCcwMCcgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJykpO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uUGF5bG9hZCk7XG4gICAgfVxuICAgIGFzeW5jIGxvYWRTY3JpcHQoc3JjKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkJhc2VTb2NpYWxMb2dpbi5PQVVUSF9TVEFURV9LRVkgPSAnc29jaWFsX2xvZ2luX29hdXRoX3BlbmRpbmcnO1xuXG5jbGFzcyBBcHBsZVNvY2lhbExvZ2luIGV4dGVuZHMgQmFzZVNvY2lhbExvZ2luIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVkaXJlY3RVcmwgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcmlwdExvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjcmlwdFVybCA9ICdodHRwczovL2FwcGxlaWQuY2RuLWFwcGxlLmNvbS9hcHBsZWF1dGgvc3RhdGljL2pzYXBpL2FwcGxlaWQvMS9lbl9VUy9hcHBsZWlkLmF1dGguanMnO1xuICAgICAgICB0aGlzLnVzZVByb3BlclRva2VuRXhjaGFuZ2UgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdGlhbGl6ZShjbGllbnRJZCwgcmVkaXJlY3RVcmwsIHVzZVByb3BlclRva2VuRXhjaGFuZ2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMucmVkaXJlY3RVcmwgPSByZWRpcmVjdFVybCB8fCBudWxsO1xuICAgICAgICB0aGlzLnVzZVByb3BlclRva2VuRXhjaGFuZ2UgPSB1c2VQcm9wZXJUb2tlbkV4Y2hhbmdlO1xuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZEFwcGxlU2NyaXB0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbG9naW4ob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXBwbGUgQ2xpZW50IElEIG5vdCBzZXQuIENhbGwgaW5pdGlhbGl6ZSgpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zY3JpcHRMb2FkZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXBwbGUgU2lnbi1JbiBzY3JpcHQgbm90IGxvYWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgQXBwbGVJRC5hdXRoLmluaXQoe1xuICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIHNjb3BlOiAoKF9hID0gb3B0aW9ucy5zY29wZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5qb2luKCcgJykpIHx8ICduYW1lIGVtYWlsJyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFVSSTogdGhpcy5yZWRpcmVjdFVybCB8fCB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgICAgICBzdGF0ZTogb3B0aW9ucy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSxcbiAgICAgICAgICAgICAgICB1c2VQb3B1cDogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgQXBwbGVJRC5hdXRoXG4gICAgICAgICAgICAgICAgLnNpZ25JbigpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgICAgICAgICAgbGV0IGFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51c2VQcm9wZXJUb2tlbkV4Y2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdXNpbmcgcHJvcGVyIHRva2VuIGV4Y2hhbmdlLCB0aGUgYXV0aG9yaXphdGlvbiBjb2RlIHNob3VsZCBiZSBleGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGEgcHJvcGVyIGFjY2VzcyB0b2tlbiBvbiB0aGUgYmFja2VuZC4gRm9yIG5vdywgd2Ugc2V0IGFjY2Vzc1Rva2VuIHRvIG51bGxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb3ZpZGUgdGhlIGF1dGhvcml6YXRpb24gY29kZSBpbiBhIHNlcGFyYXRlIGZpZWxkIGZvciBiYWNrZW5kIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2FjeSBiZWhhdmlvcjogdXNlIGF1dGhvcml6YXRpb24gY29kZSBhcyBhY2Nlc3MgdG9rZW4gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogcmVzLmF1dGhvcml6YXRpb24uY29kZSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7IHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IHJlcy51c2VyIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWw6ICgoX2EgPSByZXMudXNlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVtYWlsKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2l2ZW5OYW1lOiAoKF9jID0gKF9iID0gcmVzLnVzZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmlyc3ROYW1lKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5TmFtZTogKChfZSA9IChfZCA9IHJlcy51c2VyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubmFtZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmxhc3ROYW1lKSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LCBhY2Nlc3NUb2tlbjogYWNjZXNzVG9rZW4sIGlkVG9rZW46IHJlcy5hdXRob3JpemF0aW9uLmlkX3Rva2VuIHx8IG51bGwgfSwgKHRoaXMudXNlUHJvcGVyVG9rZW5FeGNoYW5nZSAmJiB7IGF1dGhvcml6YXRpb25Db2RlOiByZXMuYXV0aG9yaXphdGlvbi5jb2RlIH0pKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgcHJvdmlkZXI6ICdhcHBsZScsIHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGxvZ291dCgpIHtcbiAgICAgICAgLy8gQXBwbGUgZG9lc24ndCBwcm92aWRlIGEgbG9nb3V0IG1ldGhvZCBmb3Igd2ViXG4gICAgICAgIGNvbnNvbGUubG9nKCdBcHBsZSBsb2dvdXQ6IFNlc3Npb24gc2hvdWxkIGJlIG1hbmFnZWQgb24gdGhlIGNsaWVudCBzaWRlJyk7XG4gICAgfVxuICAgIGFzeW5jIGlzTG9nZ2VkSW4oKSB7XG4gICAgICAgIC8vIEFwcGxlIGRvZXNuJ3QgcHJvdmlkZSBhIG1ldGhvZCB0byBjaGVjayBsb2dpbiBzdGF0dXMgb24gd2ViXG4gICAgICAgIGNvbnNvbGUubG9nKCdBcHBsZSBsb2dpbiBzdGF0dXMgc2hvdWxkIGJlIG1hbmFnZWQgb24gdGhlIGNsaWVudCBzaWRlJyk7XG4gICAgICAgIHJldHVybiB7IGlzTG9nZ2VkSW46IGZhbHNlIH07XG4gICAgfVxuICAgIGFzeW5jIGdldEF1dGhvcml6YXRpb25Db2RlKCkge1xuICAgICAgICAvLyBBcHBsZSBhdXRob3JpemF0aW9uIGNvZGUgc2hvdWxkIGJlIG9idGFpbmVkIGR1cmluZyBsb2dpblxuICAgICAgICBjb25zb2xlLmxvZygnQXBwbGUgYXV0aG9yaXphdGlvbiBjb2RlIHNob3VsZCBiZSBzdG9yZWQgZHVyaW5nIGxvZ2luJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXBwbGUgYXV0aG9yaXphdGlvbiBjb2RlIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaCgpIHtcbiAgICAgICAgLy8gQXBwbGUgZG9lc24ndCBwcm92aWRlIGEgcmVmcmVzaCBtZXRob2QgZm9yIHdlYlxuICAgICAgICBjb25zb2xlLmxvZygnQXBwbGUgcmVmcmVzaCBub3QgYXZhaWxhYmxlIG9uIHdlYicpO1xuICAgIH1cbiAgICBhc3luYyBsb2FkQXBwbGVTY3JpcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcmlwdExvYWRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZFNjcmlwdCh0aGlzLnNjcmlwdFVybCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdExvYWRlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgRmFjZWJvb2tTb2NpYWxMb2dpbiBleHRlbmRzIEJhc2VTb2NpYWxMb2dpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYXBwSWQgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcmlwdExvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvY2FsZSA9ICdlbl9VUyc7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUoYXBwSWQsIGxvY2FsZSkge1xuICAgICAgICB0aGlzLmFwcElkID0gYXBwSWQ7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBJZCkge1xuICAgICAgICAgICAgLy8gTG9hZCB3aXRoIHRoZSBzcGVjaWZpZWQgbG9jYWxlIG9yIGRlZmF1bHRcbiAgICAgICAgICAgIGF3YWl0IHRoaXMubG9hZEZhY2Vib29rU2NyaXB0KHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIEZCLmluaXQoe1xuICAgICAgICAgICAgICAgIGFwcElkOiB0aGlzLmFwcElkLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICd2MTcuMCcsXG4gICAgICAgICAgICAgICAgeGZibWw6IHRydWUsXG4gICAgICAgICAgICAgICAgY29va2llOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbG9naW4ob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuYXBwSWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFjZWJvb2sgQXBwIElEIG5vdCBzZXQuIENhbGwgaW5pdGlhbGl6ZSgpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBGQi5sb2dpbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAnY29ubmVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICBGQi5hcGkoJy9tZScsIHsgZmllbGRzOiAnaWQsbmFtZSxlbWFpbCxwaWN0dXJlJyB9LCAodXNlckluZm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzVG9rZW46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHJlc3BvbnNlLmF1dGhSZXNwb25zZS5hY2Nlc3NUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkOiByZXNwb25zZS5hdXRoUmVzcG9uc2UudXNlcklELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySUQ6IHVzZXJJbmZvLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB1c2VySW5mby5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWFpbDogdXNlckluZm8uZW1haWwgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVUkw6ICgoX2IgPSAoX2EgPSB1c2VySW5mby5waWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVybCkgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJpZW5kSURzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmlydGhkYXk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFnZVJhbmdlOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5kZXI6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob21ldG93bjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZVVSTDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkVG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHByb3ZpZGVyOiAnZmFjZWJvb2snLCByZXN1bHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFjZWJvb2sgbG9naW4gZmFpbGVkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHsgc2NvcGU6IG9wdGlvbnMucGVybWlzc2lvbnMuam9pbignLCcpIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgbG9nb3V0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIEZCLmxvZ291dCgoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgaXNMb2dnZWRJbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBGQi5nZXRMb2dpblN0YXR1cygocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgaXNMb2dnZWRJbjogcmVzcG9uc2Uuc3RhdHVzID09PSAnY29ubmVjdGVkJyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXV0aG9yaXphdGlvbkNvZGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBGQi5nZXRMb2dpblN0YXR1cygocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGp3dDogKChfYSA9IHJlc3BvbnNlLmF1dGhSZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc1Rva2VuKSB8fCAnJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vIEZhY2Vib29rIGF1dGhvcml6YXRpb24gY29kZSBhdmFpbGFibGUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZWZyZXNoKG9wdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2dpbihvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZEZhY2Vib29rU2NyaXB0KGxvY2FsZSkge1xuICAgICAgICBpZiAodGhpcy5zY3JpcHRMb2FkZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgRmFjZWJvb2sgU0RLIHNjcmlwdFxuICAgICAgICBjb25zdCBleGlzdGluZ1NjcmlwdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtzcmMqPVwiY29ubmVjdC5mYWNlYm9vay5uZXRcIl0nKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU2NyaXB0KSB7XG4gICAgICAgICAgICBleGlzdGluZ1NjcmlwdC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkU2NyaXB0KGBodHRwczovL2Nvbm5lY3QuZmFjZWJvb2submV0LyR7bG9jYWxlfS9zZGsuanNgKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0TG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBHb29nbGVTb2NpYWxMb2dpbiBleHRlbmRzIEJhc2VTb2NpYWxMb2dpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZ2luVHlwZSA9ICdvbmxpbmUnO1xuICAgICAgICB0aGlzLkdPT0dMRV9UT0tFTl9SRVFVRVNUX1VSTCA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9vYXV0aDIvdjMvdG9rZW5pbmZvJztcbiAgICAgICAgdGhpcy5HT09HTEVfU1RBVEVfS0VZID0gJ2NhcGdvX3NvY2lhbF9sb2dpbl9nb29nbGVfc3RhdGUnO1xuICAgIH1cbiAgICBhc3luYyBpbml0aWFsaXplKGNsaWVudElkLCBtb2RlLCBob3N0ZWREb21haW4sIHJlZGlyZWN0VXJsKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgaWYgKG1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9naW5UeXBlID0gbW9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3RlZERvbWFpbiA9IGhvc3RlZERvbWFpbjtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVybCA9IHJlZGlyZWN0VXJsO1xuICAgIH1cbiAgICBhc3luYyBsb2dpbihvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHb29nbGUgQ2xpZW50IElEIG5vdCBzZXQuIENhbGwgaW5pdGlhbGl6ZSgpIGZpcnN0LicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY29wZXMgPSBvcHRpb25zLnNjb3BlcyB8fCBbXTtcbiAgICAgICAgaWYgKHNjb3Blcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiBzY29wZXMgYXJlIHByb3ZpZGVkLCBkaXJlY3RseSB1c2UgdGhlIHRyYWRpdGlvbmFsIE9BdXRoIGZsb3dcbiAgICAgICAgICAgIGlmICghc2NvcGVzLmluY2x1ZGVzKCdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3VzZXJpbmZvLmVtYWlsJykpIHtcbiAgICAgICAgICAgICAgICBzY29wZXMucHVzaCgnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC91c2VyaW5mby5lbWFpbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzY29wZXMuaW5jbHVkZXMoJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvdXNlcmluZm8ucHJvZmlsZScpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzLnB1c2goJ2h0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL2F1dGgvdXNlcmluZm8ucHJvZmlsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzY29wZXMuaW5jbHVkZXMoJ29wZW5pZCcpKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzLnB1c2goJ29wZW5pZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NvcGVzID0gW1xuICAgICAgICAgICAgICAgICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL3VzZXJpbmZvLmVtYWlsJyxcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vYXV0aC91c2VyaW5mby5wcm9maWxlJyxcbiAgICAgICAgICAgICAgICAnb3BlbmlkJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9uY2UgPSBvcHRpb25zLm5vbmNlIHx8IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKTtcbiAgICAgICAgLy8gSWYgc2NvcGVzIGFyZSBwcm92aWRlZCwgZGlyZWN0bHkgdXNlIHRoZSB0cmFkaXRpb25hbCBPQXV0aCBmbG93XG4gICAgICAgIHJldHVybiB0aGlzLnRyYWRpdGlvbmFsT0F1dGgoe1xuICAgICAgICAgICAgc2NvcGVzLFxuICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICBob3N0ZWREb21haW46IHRoaXMuaG9zdGVkRG9tYWluLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgbG9nb3V0KCkge1xuICAgICAgICBpZiAodGhpcy5sb2dpblR5cGUgPT09ICdvZmZsaW5lJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiT2ZmbGluZSBsb2dpbiBkb2Vzbid0IHN0b3JlIHRva2Vucy4gbG9nb3V0IGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRHb29nbGVTdGF0ZSgpO1xuICAgICAgICBpZiAoIXN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhd2FpdCB0aGlzLnJhd0xvZ291dEdvb2dsZShzdGF0ZS5hY2Nlc3NUb2tlbik7XG4gICAgfVxuICAgIGFzeW5jIGlzTG9nZ2VkSW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmxvZ2luVHlwZSA9PT0gJ29mZmxpbmUnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJPZmZsaW5lIGxvZ2luIGRvZXNuJ3Qgc3RvcmUgdG9rZW5zLiBpc0xvZ2dlZEluIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRHb29nbGVTdGF0ZSgpO1xuICAgICAgICBpZiAoIXN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNMb2dnZWRJbjogZmFsc2UgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRBY2Nlc3NUb2tlbiA9IGF3YWl0IHRoaXMuYWNjZXNzVG9rZW5Jc1ZhbGlkKHN0YXRlLmFjY2Vzc1Rva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWRJZFRva2VuID0gdGhpcy5pZFRva2VuVmFsaWQoc3RhdGUuaWRUb2tlbik7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEFjY2Vzc1Rva2VuICYmIGlzVmFsaWRJZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNMb2dnZWRJbjogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5yYXdMb2dvdXRHb29nbGUoc3RhdGUuYWNjZXNzVG9rZW4sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQWNjZXNzIHRva2VuIGlzIG5vdCB2YWxpZCwgYnV0IGNhbm5vdCBsb2dvdXQnLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNMb2dnZWRJbjogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldEF1dGhvcml6YXRpb25Db2RlKCkge1xuICAgICAgICBpZiAodGhpcy5sb2dpblR5cGUgPT09ICdvZmZsaW5lJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiT2ZmbGluZSBsb2dpbiBkb2Vzbid0IHN0b3JlIHRva2Vucy4gZ2V0QXV0aG9yaXphdGlvbkNvZGUgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldEdvb2dsZVN0YXRlKCk7XG4gICAgICAgIGlmICghc3RhdGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdvb2dsZSBhdXRob3JpemF0aW9uIGNvZGUgYXZhaWxhYmxlJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkQWNjZXNzVG9rZW4gPSBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuSXNWYWxpZChzdGF0ZS5hY2Nlc3NUb2tlbik7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkSWRUb2tlbiA9IHRoaXMuaWRUb2tlblZhbGlkKHN0YXRlLmlkVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRBY2Nlc3NUb2tlbiAmJiBpc1ZhbGlkSWRUb2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGFjY2Vzc1Rva2VuOiBzdGF0ZS5hY2Nlc3NUb2tlbiwgand0OiBzdGF0ZS5pZFRva2VuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJhd0xvZ291dEdvb2dsZShzdGF0ZS5hY2Nlc3NUb2tlbiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBY2Nlc3MgdG9rZW4gaXMgbm90IHZhbGlkLCBidXQgY2Fubm90IGxvZ291dCcsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEdvb2dsZSBhdXRob3JpemF0aW9uIGNvZGUgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZWZyZXNoKCkge1xuICAgICAgICAvLyBGb3IgR29vZ2xlLCB3ZSBjYW4gcHJvbXB0IGZvciByZS1hdXRoZW50aWNhdGlvblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBoYW5kbGVPQXV0aFJlZGlyZWN0KHVybCkge1xuICAgICAgICBjb25zdCBwYXJhbXNSYXcgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgICAgICBjb25zdCBjb2RlID0gcGFyYW1zUmF3LmdldCgnY29kZScpO1xuICAgICAgICBpZiAoY29kZSAmJiBwYXJhbXNSYXcuaGFzKCdzY29wZScpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiAnZ29vZ2xlJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyQXV0aENvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ29mZmxpbmUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc2ggPSB1cmwuaGFzaC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoYW5kbGVPQXV0aFJlZGlyZWN0JywgdXJsLmhhc2gpO1xuICAgICAgICBpZiAoIWhhc2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc29sZS5sb2coJ2hhbmRsZU9BdXRoUmVkaXJlY3Qgb2snKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhoYXNoKTtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSBwYXJhbXMuZ2V0KCdhY2Nlc3NfdG9rZW4nKTtcbiAgICAgICAgY29uc3QgaWRUb2tlbiA9IHBhcmFtcy5nZXQoJ2lkX3Rva2VuJyk7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlbiAmJiBpZFRva2VuKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShCYXNlU29jaWFsTG9naW4uT0FVVEhfU1RBVEVfS0VZKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2ZpbGUgPSB0aGlzLnBhcnNlSnd0KGlkVG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogJ2dvb2dsZScsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGlkVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBwcm9maWxlLmVtYWlsIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHlOYW1lOiBwcm9maWxlLmZhbWlseV9uYW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBnaXZlbk5hbWU6IHByb2ZpbGUuZ2l2ZW5fbmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2ZpbGUuc3ViIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwcm9maWxlLm5hbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlVXJsOiBwcm9maWxlLnBpY3R1cmUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnb25saW5lJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXN5bmMgYWNjZXNzVG9rZW5Jc1ZhbGlkKGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuR09PR0xFX1RPS0VOX1JFUVVFU1RfVVJMfT9hY2Nlc3NfdG9rZW49JHtlbmNvZGVVUklDb21wb25lbnQoYWNjZXNzVG9rZW4pfWA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBNYWtlIHRoZSBHRVQgcmVxdWVzdCB1c2luZyBmZXRjaFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgSW52YWxpZCByZXNwb25zZSBmcm9tICR7dGhpcy5HT09HTEVfVE9LRU5fUkVRVUVTVF9VUkx9LiBSZXNwb25zZSBub3Qgc3VjY2Vzc2Z1bC4gU3RhdHVzIGNvZGU6ICR7cmVzcG9uc2Uuc3RhdHVzfS4gQXNzdW1pbmcgdGhhdCB0aGUgdG9rZW4gaXMgbm90IHZhbGlkYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSByZXNwb25zZSBib2R5IGFzIHRleHRcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tICR7dGhpcy5HT09HTEVfVE9LRU5fUkVRVUVTVF9VUkx9LiBSZXNwb25zZSBib2R5IGlzIG51bGxgKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZnJvbSAke3RoaXMuR09PR0xFX1RPS0VOX1JFUVVFU1RfVVJMfS4gUmVzcG9uc2UgYm9keSBpcyBudWxsYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBhcyBKU09OXG4gICAgICAgICAgICBsZXQganNvbk9iamVjdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAganNvbk9iamVjdCA9IEpTT04ucGFyc2UocmVzcG9uc2VCb2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tICR7dGhpcy5HT09HTEVfVE9LRU5fUkVRVUVTVF9VUkx9LiBSZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OLiBFcnJvcjogJHtlfWApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tICR7dGhpcy5HT09HTEVfVE9LRU5fUkVRVUVTVF9VUkx9LiBSZXNwb25zZSBib2R5IGlzIG5vdCB2YWxpZCBKU09OLiBFcnJvcjogJHtlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXh0cmFjdCB0aGUgJ2V4cGlyZXNfaW4nIGZpZWxkXG4gICAgICAgICAgICBjb25zdCBleHBpcmVzSW5TdHIgPSBqc29uT2JqZWN0WydleHBpcmVzX2luJ107XG4gICAgICAgICAgICBpZiAoZXhwaXJlc0luU3RyID09PSB1bmRlZmluZWQgfHwgZXhwaXJlc0luU3RyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tICR7dGhpcy5HT09HTEVfVE9LRU5fUkVRVUVTVF9VUkx9LiBSZXNwb25zZSBKU09OIGRvZXMgbm90IGluY2x1ZGUgJ2V4cGlyZXNfaW4nLmApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBmcm9tICR7dGhpcy5HT09HTEVfVE9LRU5fUkVRVUVTVF9VUkx9LiBSZXNwb25zZSBKU09OIGRvZXMgbm90IGluY2x1ZGUgJ2V4cGlyZXNfaW4nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2UgJ2V4cGlyZXNfaW4nIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAgIGxldCBleHBpcmVzSW5JbnQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNJbkludCA9IHBhcnNlSW50KGV4cGlyZXNJblN0ciwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihleHBpcmVzSW5JbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJ2V4cGlyZXNfaW4nIGlzIG5vdCBhIHZhbGlkIGludGVnZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZnJvbSAke3RoaXMuR09PR0xFX1RPS0VOX1JFUVVFU1RfVVJMfS4gJ2V4cGlyZXNfaW4nOiAke2V4cGlyZXNJblN0cn0gaXMgbm90IGEgdmFsaWQgaW50ZWdlci4gRXJyb3I6ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZnJvbSAke3RoaXMuR09PR0xFX1RPS0VOX1JFUVVFU1RfVVJMfS4gJ2V4cGlyZXNfaW4nOiAke2V4cGlyZXNJblN0cn0gaXMgbm90IGEgdmFsaWQgaW50ZWdlci4gRXJyb3I6ICR7ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgYWNjZXNzIHRva2VuIGlzIHZhbGlkIGJhc2VkIG9uICdleHBpcmVzX2luJ1xuICAgICAgICAgICAgcmV0dXJuIGV4cGlyZXNJbkludCA+IDU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlkVG9rZW5WYWxpZChpZFRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlSnd0KGlkVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBNYXRoLmNlaWwoRGF0ZS5ub3coKSAvIDEwMDApICsgNTsgLy8gQ29udmVydCBjdXJyZW50IHRpbWUgdG8gc2Vjb25kcyBzaW5jZSBlcG9jaFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZC5leHAgJiYgY3VycmVudFRpbWUgPCBwYXJzZWQuZXhwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmF3TG9nb3V0R29vZ2xlKGFjY2Vzc1Rva2VuLCB0b2tlblZhbGlkID0gbnVsbCkge1xuICAgICAgICBpZiAodG9rZW5WYWxpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW5WYWxpZCA9IGF3YWl0IHRoaXMuYWNjZXNzVG9rZW5Jc1ZhbGlkKGFjY2Vzc1Rva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5WYWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmZXRjaChgaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3Jldm9rZT90b2tlbj0ke2VuY29kZVVSSUNvbXBvbmVudChhY2Nlc3NUb2tlbil9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclN0YXRlR29vZ2xlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbGVhclN0YXRlR29vZ2xlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGVyc2lzdFN0YXRlR29vZ2xlKGFjY2Vzc1Rva2VuLCBpZFRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5HT09HTEVfU1RBVEVfS0VZLCBKU09OLnN0cmluZ2lmeSh7IGFjY2Vzc1Rva2VuLCBpZFRva2VuIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHBlcnNpc3Qgc3RhdGUgZ29vZ2xlJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXJTdGF0ZUdvb2dsZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLkdPT0dMRV9TVEFURV9LRVkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgY2xlYXIgc3RhdGUgZ29vZ2xlJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0R29vZ2xlU3RhdGUoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLkdPT0dMRV9TVEFURV9LRVkpO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjZXNzVG9rZW4sIGlkVG9rZW4gfSA9IEpTT04ucGFyc2Uoc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgYWNjZXNzVG9rZW4sIGlkVG9rZW4gfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IGdldCBzdGF0ZSBnb29nbGUnLCBlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHRyYWRpdGlvbmFsT0F1dGgoeyBzY29wZXMsIGhvc3RlZERvbWFpbiwgbm9uY2UsIH0pIHtcbiAgICAgICAgY29uc3QgdW5pcXVlU2NvcGVzID0gWy4uLm5ldyBTZXQoWy4uLihzY29wZXMgfHwgW10pLCAnb3BlbmlkJ10pXTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVybCB8fCB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLCByZXNwb25zZV90eXBlOiB0aGlzLmxvZ2luVHlwZSA9PT0gJ29mZmxpbmUnID8gJ2NvZGUnIDogJ3Rva2VuIGlkX3Rva2VuJywgc2NvcGU6IHVuaXF1ZVNjb3Blcy5qb2luKCcgJykgfSwgKG5vbmNlICYmIHsgbm9uY2UgfSkpLCB7IGluY2x1ZGVfZ3JhbnRlZF9zY29wZXM6ICd0cnVlJywgc3RhdGU6ICdwb3B1cCcgfSkpO1xuICAgICAgICBpZiAoaG9zdGVkRG9tYWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoJ2hkJywgaG9zdGVkRG9tYWluKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly9hY2NvdW50cy5nb29nbGUuY29tL28vb2F1dGgyL3YyL2F1dGg/JHtwYXJhbXMudG9TdHJpbmcoKX1gO1xuICAgICAgICBjb25zdCB3aWR0aCA9IDUwMDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gNjAwO1xuICAgICAgICBjb25zdCBsZWZ0ID0gd2luZG93LnNjcmVlblggKyAod2luZG93Lm91dGVyV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cub3V0ZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oQmFzZVNvY2lhbExvZ2luLk9BVVRIX1NUQVRFX0tFWSwgJ3RydWUnKTtcbiAgICAgICAgY29uc3QgcG9wdXAgPSB3aW5kb3cub3Blbih1cmwsICdHb29nbGUgU2lnbiBJbicsIGB3aWR0aD0ke3dpZHRofSxoZWlnaHQ9JHtoZWlnaHR9LGxlZnQ9JHtsZWZ0fSx0b3A9JHt0b3B9LHBvcHVwPTFgKTtcbiAgICAgICAgbGV0IHBvcHVwQ2xvc2VkSW50ZXJ2YWw7XG4gICAgICAgIGxldCB0aW1lb3V0SGFuZGxlO1xuICAgICAgICAvLyBUaGlzIG1heSBuZXZlciByZXR1cm4uLi5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghcG9wdXApIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gb3BlbiBwb3B1cCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiB8fCAoKF9iID0gKF9hID0gZXZlbnQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvdXJjZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0c1dpdGgoJ2FuZ3VsYXInKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoKChfYyA9IGV2ZW50LmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50eXBlKSA9PT0gJ29hdXRoLXJlc3BvbnNlJykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHBvcHVwQ2xvc2VkSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sb2dpblR5cGUgPT09ICdvbmxpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFjY2Vzc1Rva2VuLCBpZFRva2VuIH0gPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2Vzc1Rva2VuICYmIGlkVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9maWxlID0gdGhpcy5wYXJzZUp3dChpZFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcnNpc3RTdGF0ZUdvb2dsZShhY2Nlc3NUb2tlbi50b2tlbiwgaWRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiAnZ29vZ2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuOiBhY2Nlc3NUb2tlbi50b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZmlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsOiBwcm9maWxlLmVtYWlsIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFtaWx5TmFtZTogcHJvZmlsZS5mYW1pbHlfbmFtZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdpdmVuTmFtZTogcHJvZmlsZS5naXZlbl9uYW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHByb2ZpbGUuc3ViIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcHJvZmlsZS5uYW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VVcmw6IHByb2ZpbGUucGljdHVyZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ29ubGluZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNlcnZlckF1dGhDb2RlIH0gPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6ICdnb29nbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6ICdvZmZsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyQXV0aENvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERvbid0IHJlamVjdCBmb3Igbm9uLU9BdXRoIG1lc3NhZ2VzLCBqdXN0IGlnbm9yZSB0aGVtXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIFRpbWVvdXQgYWZ0ZXIgNSBtaW51dGVzXG4gICAgICAgICAgICB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcG9wdXAuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdPQXV0aCB0aW1lb3V0JykpO1xuICAgICAgICAgICAgfSwgMzAwMDAwKTtcbiAgICAgICAgICAgIHBvcHVwQ2xvc2VkSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHVwLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHBvcHVwQ2xvc2VkSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdQb3B1cCBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgU29jaWFsTG9naW5XZWIgZXh0ZW5kcyBjb3JlLldlYlBsdWdpbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nb29nbGVQcm92aWRlciA9IG5ldyBHb29nbGVTb2NpYWxMb2dpbigpO1xuICAgICAgICB0aGlzLmFwcGxlUHJvdmlkZXIgPSBuZXcgQXBwbGVTb2NpYWxMb2dpbigpO1xuICAgICAgICB0aGlzLmZhY2Vib29rUHJvdmlkZXIgPSBuZXcgRmFjZWJvb2tTb2NpYWxMb2dpbigpO1xuICAgICAgICAvLyBTZXQgdXAgbGlzdGVuZXIgZm9yIE9BdXRoIHJlZGlyZWN0cyBpZiB3ZSBoYXZlIGEgcGVuZGluZyBPQXV0aCBmbG93XG4gICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTb2NpYWxMb2dpbldlYi5PQVVUSF9TVEFURV9LRVkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnT0FVVEhfU1RBVEVfS0VZIGZvdW5kJyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmhhbmRsZU9BdXRoUmVkaXJlY3QoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB3aW5kb3cub3BlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IHR5cGU6ICdvYXV0aC1yZXNwb25zZScgfSwgcmVzdWx0LnJlc3VsdCksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZU9BdXRoUmVkaXJlY3QoKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4gdGhpcy5nb29nbGVQcm92aWRlci5oYW5kbGVPQXV0aFJlZGlyZWN0KHVybCk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgaW5pdFByb21pc2VzID0gW107XG4gICAgICAgIGlmICgoX2EgPSBvcHRpb25zLmdvb2dsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndlYkNsaWVudElkKSB7XG4gICAgICAgICAgICBpbml0UHJvbWlzZXMucHVzaCh0aGlzLmdvb2dsZVByb3ZpZGVyLmluaXRpYWxpemUob3B0aW9ucy5nb29nbGUud2ViQ2xpZW50SWQsIG9wdGlvbnMuZ29vZ2xlLm1vZGUsIG9wdGlvbnMuZ29vZ2xlLmhvc3RlZERvbWFpbiwgb3B0aW9ucy5nb29nbGUucmVkaXJlY3RVcmwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9iID0gb3B0aW9ucy5hcHBsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNsaWVudElkKSB7XG4gICAgICAgICAgICBpbml0UHJvbWlzZXMucHVzaCh0aGlzLmFwcGxlUHJvdmlkZXIuaW5pdGlhbGl6ZShvcHRpb25zLmFwcGxlLmNsaWVudElkLCBvcHRpb25zLmFwcGxlLnJlZGlyZWN0VXJsLCBvcHRpb25zLmFwcGxlLnVzZVByb3BlclRva2VuRXhjaGFuZ2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9jID0gb3B0aW9ucy5mYWNlYm9vaykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFwcElkKSB7XG4gICAgICAgICAgICBpbml0UHJvbWlzZXMucHVzaCh0aGlzLmZhY2Vib29rUHJvdmlkZXIuaW5pdGlhbGl6ZShvcHRpb25zLmZhY2Vib29rLmFwcElkLCBvcHRpb25zLmZhY2Vib29rLmxvY2FsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluaXRQcm9taXNlcyk7XG4gICAgfVxuICAgIGFzeW5jIGxvZ2luKG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjYXNlICdnb29nbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdvb2dsZVByb3ZpZGVyLmxvZ2luKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgICAgICBjYXNlICdhcHBsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGVQcm92aWRlci5sb2dpbihvcHRpb25zLm9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSAnZmFjZWJvb2snOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhY2Vib29rUHJvdmlkZXIubG9naW4ob3B0aW9ucy5vcHRpb25zKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2dpbiBmb3IgJHtvcHRpb25zLnByb3ZpZGVyfSBpcyBub3QgaW1wbGVtZW50ZWQgb24gd2ViYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbG9nb3V0KG9wdGlvbnMpIHtcbiAgICAgICAgc3dpdGNoIChvcHRpb25zLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjYXNlICdnb29nbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdvb2dsZVByb3ZpZGVyLmxvZ291dCgpO1xuICAgICAgICAgICAgY2FzZSAnYXBwbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGxlUHJvdmlkZXIubG9nb3V0KCk7XG4gICAgICAgICAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZWJvb2tQcm92aWRlci5sb2dvdXQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2dvdXQgZm9yICR7b3B0aW9ucy5wcm92aWRlcn0gaXMgbm90IGltcGxlbWVudGVkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaXNMb2dnZWRJbihvcHRpb25zKSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgY2FzZSAnZ29vZ2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nb29nbGVQcm92aWRlci5pc0xvZ2dlZEluKCk7XG4gICAgICAgICAgICBjYXNlICdhcHBsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGVQcm92aWRlci5pc0xvZ2dlZEluKCk7XG4gICAgICAgICAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZWJvb2tQcm92aWRlci5pc0xvZ2dlZEluKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaXNMb2dnZWRJbiBmb3IgJHtvcHRpb25zLnByb3ZpZGVyfSBpcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBdXRob3JpemF0aW9uQ29kZShvcHRpb25zKSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgY2FzZSAnZ29vZ2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nb29nbGVQcm92aWRlci5nZXRBdXRob3JpemF0aW9uQ29kZSgpO1xuICAgICAgICAgICAgY2FzZSAnYXBwbGUnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGxlUHJvdmlkZXIuZ2V0QXV0aG9yaXphdGlvbkNvZGUoKTtcbiAgICAgICAgICAgIGNhc2UgJ2ZhY2Vib29rJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWNlYm9va1Byb3ZpZGVyLmdldEF1dGhvcml6YXRpb25Db2RlKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZ2V0QXV0aG9yaXphdGlvbkNvZGUgZm9yICR7b3B0aW9ucy5wcm92aWRlcn0gaXMgbm90IGltcGxlbWVudGVkYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVmcmVzaChvcHRpb25zKSB7XG4gICAgICAgIHN3aXRjaCAob3B0aW9ucy5wcm92aWRlcikge1xuICAgICAgICAgICAgY2FzZSAnZ29vZ2xlJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nb29nbGVQcm92aWRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICBjYXNlICdhcHBsZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGVQcm92aWRlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICBjYXNlICdmYWNlYm9vayc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFjZWJvb2tQcm92aWRlci5yZWZyZXNoKG9wdGlvbnMub3B0aW9ucyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVmcmVzaCBmb3IgJHtvcHRpb25zLnByb3ZpZGVyfSBpcyBub3QgaW1wbGVtZW50ZWRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm92aWRlclNwZWNpZmljQ2FsbChvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZXIgc3BlY2lmaWMgY2FsbCBmb3IgJHtvcHRpb25zLmNhbGx9IGlzIG5vdCBpbXBsZW1lbnRlZGApO1xuICAgIH1cbn1cblNvY2lhbExvZ2luV2ViLk9BVVRIX1NUQVRFX0tFWSA9ICdzb2NpYWxfbG9naW5fb2F1dGhfcGVuZGluZyc7XG5cbnZhciB3ZWIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIFNvY2lhbExvZ2luV2ViOiBTb2NpYWxMb2dpbldlYlxufSk7XG5cbmV4cG9ydHMuU29jaWFsTG9naW4gPSBTb2NpYWxMb2dpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBsdWdpbi5janMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@capgo/capacitor-social-login/dist/plugin.cjs.js\n");

/***/ })

};
;