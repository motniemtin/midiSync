"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/remotion";
exports.ids = ["vendor-chunks/remotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/remotion/dist/esm/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/remotion/dist/esm/index.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: () => (/* binding */ AbsoluteFill),\n/* harmony export */   AnimatedImage: () => (/* binding */ AnimatedImage),\n/* harmony export */   Artifact: () => (/* binding */ Artifact),\n/* harmony export */   Audio: () => (/* binding */ Audio),\n/* harmony export */   Composition: () => (/* binding */ Composition),\n/* harmony export */   Config: () => (/* binding */ Config),\n/* harmony export */   Easing: () => (/* binding */ Easing),\n/* harmony export */   Experimental: () => (/* binding */ Experimental),\n/* harmony export */   Folder: () => (/* binding */ Folder),\n/* harmony export */   FolderContext: () => (/* binding */ FolderContext),\n/* harmony export */   Freeze: () => (/* binding */ Freeze),\n/* harmony export */   Html5Audio: () => (/* binding */ Html5Audio),\n/* harmony export */   Html5Video: () => (/* binding */ Html5Video),\n/* harmony export */   IFrame: () => (/* binding */ IFrame),\n/* harmony export */   Img: () => (/* binding */ Img),\n/* harmony export */   Internals: () => (/* binding */ Internals),\n/* harmony export */   Loop: () => (/* binding */ Loop),\n/* harmony export */   OffthreadVideo: () => (/* binding */ OffthreadVideo),\n/* harmony export */   Sequence: () => (/* binding */ Sequence),\n/* harmony export */   Series: () => (/* binding */ Series),\n/* harmony export */   Still: () => (/* binding */ Still),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   Video: () => (/* binding */ Video),\n/* harmony export */   cancelRender: () => (/* binding */ cancelRender),\n/* harmony export */   continueRender: () => (/* binding */ continueRender),\n/* harmony export */   delayRender: () => (/* binding */ delayRender),\n/* harmony export */   getInputProps: () => (/* binding */ getInputProps),\n/* harmony export */   getRemotionEnvironment: () => (/* binding */ getRemotionEnvironment),\n/* harmony export */   getStaticFiles: () => (/* binding */ getStaticFiles),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),\n/* harmony export */   measureSpring: () => (/* binding */ measureSpring),\n/* harmony export */   prefetch: () => (/* binding */ prefetch),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   registerRoot: () => (/* binding */ registerRoot),\n/* harmony export */   spring: () => (/* binding */ spring),\n/* harmony export */   staticFile: () => (/* binding */ staticFile),\n/* harmony export */   useBufferState: () => (/* binding */ useBufferState),\n/* harmony export */   useCurrentFrame: () => (/* binding */ useCurrentFrame),\n/* harmony export */   useCurrentScale: () => (/* binding */ useCurrentScale),\n/* harmony export */   useDelayRender: () => (/* binding */ useDelayRender),\n/* harmony export */   useRemotionEnvironment: () => (/* binding */ useRemotionEnvironment),\n/* harmony export */   useVideoConfig: () => (/* binding */ useVideoConfig),\n/* harmony export */   watchStaticFile: () => (/* binding */ watchStaticFile)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true,\n      configurable: true,\n      set: (newValue) => all[name] = () => newValue\n    });\n};\n\n// src/_check-rsc.ts\n\nif (typeof react__WEBPACK_IMPORTED_MODULE_0__.createContext !== \"function\") {\n  const err = [\n    'Remotion requires React.createContext, but it is \"undefined\".',\n    'If you are in a React Server Component, turn it into a client component by adding \"use client\" at the top of the file.',\n    \"\",\n    \"Before:\",\n    '  import {useCurrentFrame} from \"remotion\";',\n    \"\",\n    \"After:\",\n    '  \"use client\";',\n    '  import {useCurrentFrame} from \"remotion\";'\n  ];\n  throw new Error(err.join(`\n`));\n}\n\n// src/Clipper.tsx\nvar Clipper = () => {\n  throw new Error(\"<Clipper> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n\n// src/enable-sequence-stack-traces.ts\n\n\n\n// src/get-remotion-environment.ts\nfunction getNodeEnvString() {\n  return [\"NOD\", \"E_EN\", \"V\"].join(\"\");\n}\nvar getEnvString = () => {\n  return [\"e\", \"nv\"].join(\"\");\n};\nvar getRemotionEnvironment = () => {\n  const isPlayer = typeof window !== \"undefined\" && window.remotion_isPlayer;\n  const isRendering = typeof window !== \"undefined\" && typeof window.process !== \"undefined\" && typeof window.process.env !== \"undefined\" && (window.process[getEnvString()][getNodeEnvString()] === \"test\" || window.process[getEnvString()][getNodeEnvString()] === \"production\" && typeof window !== \"undefined\" && typeof window.remotion_puppeteerTimeout !== \"undefined\");\n  const isStudio = typeof window !== \"undefined\" && window.remotion_isStudio;\n  const isReadOnlyStudio = typeof window !== \"undefined\" && window.remotion_isReadOnlyStudio;\n  return {\n    isStudio,\n    isRendering,\n    isPlayer,\n    isReadOnlyStudio,\n    isClientSideRendering: false\n  };\n};\n\n// src/enable-sequence-stack-traces.ts\nvar originalCreateElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement;\nvar originalJsx = react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx;\nvar componentsToAddStacksTo = [];\nvar enableProxy = (api) => {\n  return new Proxy(api, {\n    apply(target, thisArg, argArray) {\n      if (componentsToAddStacksTo.includes(argArray[0])) {\n        const [first, props, ...rest] = argArray;\n        const newProps = {\n          ...props ?? {},\n          stack: new Error().stack\n        };\n        return Reflect.apply(target, thisArg, [first, newProps, ...rest]);\n      }\n      return Reflect.apply(target, thisArg, argArray);\n    }\n  });\n};\nvar enableSequenceStackTraces = () => {\n  if (!getRemotionEnvironment().isStudio) {\n    return;\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.createElement = enableProxy(originalCreateElement);\n  react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx = enableProxy(originalJsx);\n};\nvar addSequenceStackTraces = (component) => {\n  componentsToAddStacksTo.push(component);\n  enableSequenceStackTraces();\n};\n\n// src/is-player.tsx\n\n\nvar IsPlayerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsPlayerContextProvider = ({\n  children\n}) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, {\n    value: true,\n    children\n  });\n};\nvar useIsPlayer = () => {\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/version.ts\nvar VERSION = \"4.0.370\";\n\n// src/multiple-versions-warning.ts\nvar checkMultipleRemotionVersions = () => {\n  if (typeof globalThis === \"undefined\") {\n    return;\n  }\n  const set = () => {\n    globalThis.remotion_imported = VERSION;\n    if (typeof window !== \"undefined\") {\n      window.remotion_imported = VERSION;\n    }\n  };\n  const alreadyImported = globalThis.remotion_imported || typeof window !== \"undefined\" && window.remotion_imported;\n  if (alreadyImported) {\n    if (alreadyImported === VERSION) {\n      return;\n    }\n    if (typeof alreadyImported === \"string\" && alreadyImported.includes(\"webcodecs\")) {\n      set();\n      return;\n    }\n    throw new TypeError(`\\uD83D\\uDEA8 Multiple versions of Remotion detected: ${[\n      VERSION,\n      typeof alreadyImported === \"string\" ? alreadyImported : \"an older version\"\n    ].filter(truthy).join(\" and \")}. This will cause things to break in an unexpected way.\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n  }\n  set();\n};\n\n// src/Null.tsx\nvar Null = () => {\n  throw new Error(\"<Null> has been removed as of Remotion v4.0.228. The native clipping APIs were experimental and subject to removal at any time. We removed them because they were sparingly used and made rendering often slower rather than faster.\");\n};\n\n// src/Sequence.tsx\n\n\n// src/AbsoluteFill.tsx\n\n\nvar hasTailwindClassName = ({\n  className,\n  classPrefix,\n  type\n}) => {\n  if (!className) {\n    return false;\n  }\n  if (type === \"exact\") {\n    const split = className.split(\" \");\n    return classPrefix.some((token) => {\n      return split.some((part) => {\n        return part.trim() === token || part.trim().endsWith(`:${token}`) || part.trim().endsWith(`!${token}`);\n      });\n    });\n  }\n  return classPrefix.some((prefix) => {\n    return className.startsWith(prefix) || className.includes(` ${prefix}`) || className.includes(`!${prefix}`) || className.includes(`:${prefix}`);\n  });\n};\nvar AbsoluteFillRefForwarding = (props, ref) => {\n  const { style, ...other } = props;\n  const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      position: \"absolute\",\n      top: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"top-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      left: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"left-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      right: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"right-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      bottom: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"bottom-\", \"inset-\"],\n        type: \"prefix\"\n      }) ? undefined : 0,\n      width: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"w-\"],\n        type: \"prefix\"\n      }) ? undefined : \"100%\",\n      height: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\"h-\"],\n        type: \"prefix\"\n      }) ? undefined : \"100%\",\n      display: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\n          \"block\",\n          \"inline-block\",\n          \"inline\",\n          \"flex\",\n          \"inline-flex\",\n          \"flow-root\",\n          \"grid\",\n          \"inline-grid\",\n          \"contents\",\n          \"list-item\",\n          \"hidden\"\n        ],\n        type: \"exact\"\n      }) ? undefined : \"flex\",\n      flexDirection: hasTailwindClassName({\n        className: other.className,\n        classPrefix: [\n          \"flex-row\",\n          \"flex-col\",\n          \"flex-row-reverse\",\n          \"flex-col-reverse\"\n        ],\n        type: \"exact\"\n      }) ? undefined : \"column\",\n      ...style\n    };\n  }, [other.className, style]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    ref,\n    style: actualStyle,\n    ...other\n  });\n};\nvar AbsoluteFill = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n\n// src/SequenceContext.tsx\n\nvar SequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n\n// src/SequenceManager.tsx\n\n\nvar SequenceManager = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  registerSequence: () => {\n    throw new Error(\"SequenceManagerContext not initialized\");\n  },\n  unregisterSequence: () => {\n    throw new Error(\"SequenceManagerContext not initialized\");\n  },\n  sequences: []\n});\nvar SequenceVisibilityToggleContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  hidden: {},\n  setHidden: () => {\n    throw new Error(\"SequenceVisibilityToggle not initialized\");\n  }\n});\nvar SequenceManagerProvider = ({ children }) => {\n  const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [hidden, setHidden] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {\n    setSequences((seqs) => {\n      return [...seqs, seq];\n    });\n  }, []);\n  const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {\n    setSequences((seqs) => seqs.filter((s) => s.id !== seq));\n  }, []);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerSequence,\n      sequences,\n      unregisterSequence\n    };\n  }, [registerSequence, sequences, unregisterSequence]);\n  const hiddenContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      hidden,\n      setHidden\n    };\n  }, [hidden]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n    value: sequenceContext,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceVisibilityToggleContext.Provider, {\n      value: hiddenContext,\n      children\n    })\n  });\n};\n\n// src/nonce.ts\n\nvar NonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  getNonce: () => 0,\n  fastRefreshes: 0,\n  manualRefreshes: 0\n});\nvar SetNonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  increaseManualRefreshes: () => {}\n});\nvar useNonce = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n  const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => context.getNonce());\n  const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (lastContext.current === context) {\n      return;\n    }\n    lastContext.current = context;\n    setNonce(context.getNonce);\n  }, [context]);\n  return nonce;\n};\n\n// src/timeline-position-state.ts\nvar exports_timeline_position_state = {};\n__export(exports_timeline_position_state, {\n  useTimelineSetFrame: () => useTimelineSetFrame,\n  useTimelinePosition: () => useTimelinePosition,\n  usePlayingState: () => usePlayingState,\n  persistCurrentFrame: () => persistCurrentFrame,\n  getInitialFrameState: () => getInitialFrameState,\n  getFrameForComposition: () => getFrameForComposition,\n  TimelineContext: () => TimelineContext,\n  SetTimelineContext: () => SetTimelineContext\n});\n\n\n// src/use-remotion-environment.ts\n\n\n// src/remotion-environment-context.ts\n\nvar RemotionEnvironmentContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n// src/use-remotion-environment.ts\nvar useRemotionEnvironment = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RemotionEnvironmentContext);\n  const [env] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getRemotionEnvironment());\n  return context ?? env;\n};\n\n// src/use-video.ts\n\n\n// src/CompositionManagerContext.tsx\n\nvar CompositionManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  compositions: [],\n  folders: [],\n  currentCompositionMetadata: null,\n  canvasContent: null\n});\nvar CompositionSetters = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  registerComposition: () => {\n    return;\n  },\n  unregisterComposition: () => {\n    return;\n  },\n  registerFolder: () => {\n    return;\n  },\n  unregisterFolder: () => {\n    return;\n  },\n  setCanvasContent: () => {\n    return;\n  },\n  updateCompositionDefaultProps: () => {\n    return;\n  },\n  onlyRenderComposition: null\n});\n\n// src/ResolveCompositionConfig.tsx\n\n\n// src/EditorProps.tsx\n\n\nvar EditorPropsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  props: {},\n  updateProps: () => {\n    throw new Error(\"Not implemented\");\n  },\n  resetUnsaved: () => {\n    throw new Error(\"Not implemented\");\n  }\n});\nvar editorPropsProviderRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar timeValueRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar EditorPropsProvider = ({ children }) => {\n  const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n  const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({\n    defaultProps,\n    id,\n    newProps\n  }) => {\n    setProps((prev) => {\n      return {\n        ...prev,\n        [id]: typeof newProps === \"function\" ? newProps(prev[id] ?? defaultProps) : newProps\n      };\n    });\n  }, []);\n  const resetUnsaved = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((compositionId) => {\n    setProps((prev) => {\n      if (prev[compositionId]) {\n        const newProps = { ...prev };\n        delete newProps[compositionId];\n        return newProps;\n      }\n      return prev;\n    });\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(editorPropsProviderRef, () => {\n    return {\n      getProps: () => props,\n      setProps\n    };\n  }, [props]);\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return { props, updateProps, resetUnsaved };\n  }, [props, resetUnsaved, updateProps]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, {\n    value: ctx,\n    children\n  });\n};\n\n// src/input-props-override.ts\nvar getKey = () => {\n  return `remotion_inputPropsOverride` + window.location.origin;\n};\nvar getInputPropsOverride = () => {\n  if (typeof localStorage === \"undefined\")\n    return null;\n  const override = localStorage.getItem(getKey());\n  if (!override)\n    return null;\n  return JSON.parse(override);\n};\nvar setInputPropsOverride = (override) => {\n  if (typeof localStorage === \"undefined\")\n    return;\n  if (override === null) {\n    localStorage.removeItem(getKey());\n    return;\n  }\n  localStorage.setItem(getKey(), JSON.stringify(override));\n};\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithSpecialTypes = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithSpecialTypes = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n    }\n    return value;\n  });\n};\nvar serializeThenDeserialize = (props) => {\n  return deserializeJSONWithSpecialTypes(serializeJSONWithSpecialTypes({\n    data: props,\n    indent: 2,\n    staticBase: window.remotion_staticBase\n  }).serializedString);\n};\nvar serializeThenDeserializeInStudio = (props) => {\n  if (getRemotionEnvironment().isStudio) {\n    return serializeThenDeserialize(props);\n  }\n  return props;\n};\n\n// src/config/input-props.ts\nvar didWarnSSRImport = false;\nvar warnOnceSSRImport = () => {\n  if (didWarnSSRImport) {\n    return;\n  }\n  didWarnSSRImport = true;\n  console.warn(\"Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.\");\n  console.warn(\"To hide this warning, don't call this function on the server:\");\n  console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nvar getInputProps = () => {\n  if (typeof window === \"undefined\") {\n    warnOnceSSRImport();\n    return {};\n  }\n  if (getRemotionEnvironment().isPlayer) {\n    throw new Error(\"You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.\");\n  }\n  const override = getInputPropsOverride();\n  if (override) {\n    return override;\n  }\n  const param = window.remotion_inputProps;\n  if (!param) {\n    return {};\n  }\n  const parsed = deserializeJSONWithSpecialTypes(param);\n  return parsed;\n};\n\n// src/codec.ts\nvar validCodecs = [\n  \"h264\",\n  \"h265\",\n  \"vp8\",\n  \"vp9\",\n  \"mp3\",\n  \"aac\",\n  \"wav\",\n  \"prores\",\n  \"h264-mkv\",\n  \"h264-ts\",\n  \"gif\"\n];\n\n// src/validation/validate-default-codec.ts\nfunction validateCodec(defaultCodec, location, name) {\n  if (typeof defaultCodec === \"undefined\") {\n    return;\n  }\n  if (typeof defaultCodec !== \"string\") {\n    throw new TypeError(`The \"${name}\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n  }\n  if (!validCodecs.includes(defaultCodec)) {\n    throw new Error(`The \"${name}\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n  }\n}\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/resolve-video-config.ts\nvar validateCalculated = ({\n  calculated,\n  compositionId,\n  compositionFps,\n  compositionHeight,\n  compositionWidth,\n  compositionDurationInFrames\n}) => {\n  const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${compositionId}\"`;\n  const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${compositionId}\"`;\n  const width = calculated?.width ?? compositionWidth ?? undefined;\n  validateDimension(width, \"width\", calculated?.width ? calculateMetadataErrorLocation : defaultErrorLocation);\n  const height = calculated?.height ?? compositionHeight ?? undefined;\n  validateDimension(height, \"height\", calculated?.height ? calculateMetadataErrorLocation : defaultErrorLocation);\n  const fps = calculated?.fps ?? compositionFps ?? null;\n  validateFps(fps, calculated?.fps ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n  const durationInFrames = calculated?.durationInFrames ?? compositionDurationInFrames ?? null;\n  validateDurationInFrames(durationInFrames, {\n    allowFloats: false,\n    component: `of the \"<Composition />\" component with the id \"${compositionId}\"`\n  });\n  const defaultCodec = calculated?.defaultCodec;\n  validateCodec(defaultCodec, calculateMetadataErrorLocation, \"defaultCodec\");\n  const defaultOutName = calculated?.defaultOutName;\n  const defaultVideoImageFormat = calculated?.defaultVideoImageFormat;\n  const defaultPixelFormat = calculated?.defaultPixelFormat;\n  const defaultProResProfile = calculated?.defaultProResProfile;\n  return {\n    width,\n    height,\n    fps,\n    durationInFrames,\n    defaultCodec,\n    defaultOutName,\n    defaultVideoImageFormat,\n    defaultPixelFormat,\n    defaultProResProfile\n  };\n};\nvar resolveVideoConfig = ({\n  calculateMetadata,\n  signal,\n  defaultProps,\n  originalProps,\n  compositionId,\n  compositionDurationInFrames,\n  compositionFps,\n  compositionHeight,\n  compositionWidth\n}) => {\n  const calculatedProm = calculateMetadata ? calculateMetadata({\n    defaultProps,\n    props: originalProps,\n    abortSignal: signal,\n    compositionId,\n    isRendering: getRemotionEnvironment().isRendering\n  }) : null;\n  if (calculatedProm !== null && typeof calculatedProm === \"object\" && \"then\" in calculatedProm) {\n    return calculatedProm.then((c) => {\n      const {\n        height,\n        width,\n        durationInFrames,\n        fps,\n        defaultCodec,\n        defaultOutName,\n        defaultVideoImageFormat,\n        defaultPixelFormat,\n        defaultProResProfile\n      } = validateCalculated({\n        calculated: c,\n        compositionDurationInFrames,\n        compositionFps,\n        compositionHeight,\n        compositionWidth,\n        compositionId\n      });\n      return {\n        width,\n        height,\n        fps,\n        durationInFrames,\n        id: compositionId,\n        defaultProps: serializeThenDeserializeInStudio(defaultProps),\n        props: serializeThenDeserializeInStudio(c.props ?? originalProps),\n        defaultCodec: defaultCodec ?? null,\n        defaultOutName: defaultOutName ?? null,\n        defaultVideoImageFormat: defaultVideoImageFormat ?? null,\n        defaultPixelFormat: defaultPixelFormat ?? null,\n        defaultProResProfile: defaultProResProfile ?? null\n      };\n    });\n  }\n  const data = validateCalculated({\n    calculated: calculatedProm,\n    compositionDurationInFrames,\n    compositionFps,\n    compositionHeight,\n    compositionWidth,\n    compositionId\n  });\n  if (calculatedProm === null) {\n    return {\n      ...data,\n      id: compositionId,\n      defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n      props: serializeThenDeserializeInStudio(originalProps),\n      defaultCodec: null,\n      defaultOutName: null,\n      defaultVideoImageFormat: null,\n      defaultPixelFormat: null,\n      defaultProResProfile: null\n    };\n  }\n  return {\n    ...data,\n    id: compositionId,\n    defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n    props: serializeThenDeserializeInStudio(calculatedProm.props ?? originalProps),\n    defaultCodec: calculatedProm.defaultCodec ?? null,\n    defaultOutName: calculatedProm.defaultOutName ?? null,\n    defaultVideoImageFormat: calculatedProm.defaultVideoImageFormat ?? null,\n    defaultPixelFormat: calculatedProm.defaultPixelFormat ?? null,\n    defaultProResProfile: calculatedProm.defaultProResProfile ?? null\n  };\n};\nvar resolveVideoConfigOrCatch = (params) => {\n  try {\n    const promiseOrReturnValue = resolveVideoConfig(params);\n    return {\n      type: \"success\",\n      result: promiseOrReturnValue\n    };\n  } catch (err) {\n    return {\n      type: \"error\",\n      error: err\n    };\n  }\n};\n\n// src/ResolveCompositionConfig.tsx\n\nvar ResolveCompositionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar resolveCompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar needsResolution = (composition) => {\n  return Boolean(composition.calculateMetadata);\n};\nvar PROPS_UPDATED_EXTERNALLY = \"remotion.propsUpdatedExternally\";\nvar ResolveCompositionConfig = ({ children }) => {\n  const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n  const { fastRefreshes, manualRefreshes } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n  if (manualRefreshes) {}\n  const selectedComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return compositions.find((c) => canvasContent && canvasContent.type === \"composition\" && canvasContent.compositionId === c.id);\n  }, [canvasContent, compositions]);\n  const renderModalComposition = compositions.find((c) => c.id === currentRenderModalComposition);\n  const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n  const env = useRemotionEnvironment();\n  const inputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return typeof window === \"undefined\" || env.isPlayer ? {} : getInputProps() ?? {};\n  }, [env.isPlayer]);\n  const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n  const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return selectedComposition ? allEditorProps[selectedComposition.id] ?? {} : {};\n  }, [allEditorProps, selectedComposition]);\n  const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return renderModalComposition ? allEditorProps[renderModalComposition.id] ?? {} : {};\n  }, [allEditorProps, renderModalComposition]);\n  const hasResolution = Boolean(currentCompositionMetadata);\n  const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({\n    calculateMetadata,\n    combinedProps,\n    compositionDurationInFrames,\n    compositionFps,\n    compositionHeight,\n    compositionId,\n    compositionWidth,\n    defaultProps\n  }) => {\n    const controller = new AbortController;\n    if (hasResolution) {\n      return controller;\n    }\n    const { signal } = controller;\n    const result = resolveVideoConfigOrCatch({\n      compositionId,\n      calculateMetadata,\n      originalProps: combinedProps,\n      signal,\n      defaultProps,\n      compositionDurationInFrames,\n      compositionFps,\n      compositionHeight,\n      compositionWidth\n    });\n    if (result.type === \"error\") {\n      setResolvedConfigs((r) => ({\n        ...r,\n        [compositionId]: {\n          type: \"error\",\n          error: result.error\n        }\n      }));\n      return controller;\n    }\n    const promOrNot = result.result;\n    if (typeof promOrNot === \"object\" && \"then\" in promOrNot) {\n      setResolvedConfigs((r) => {\n        const prev = r[compositionId];\n        if (prev?.type === \"success\" || prev?.type === \"success-and-refreshing\") {\n          return {\n            ...r,\n            [compositionId]: {\n              type: \"success-and-refreshing\",\n              result: prev.result\n            }\n          };\n        }\n        return {\n          ...r,\n          [compositionId]: {\n            type: \"loading\"\n          }\n        };\n      });\n      promOrNot.then((c) => {\n        if (controller.signal.aborted) {\n          return;\n        }\n        setResolvedConfigs((r) => ({\n          ...r,\n          [compositionId]: {\n            type: \"success\",\n            result: c\n          }\n        }));\n      }).catch((err) => {\n        if (controller.signal.aborted) {\n          return;\n        }\n        setResolvedConfigs((r) => ({\n          ...r,\n          [compositionId]: {\n            type: \"error\",\n            error: err\n          }\n        }));\n      });\n    } else {\n      setResolvedConfigs((r) => ({\n        ...r,\n        [compositionId]: {\n          type: \"success\",\n          result: promOrNot\n        }\n      }));\n    }\n    return controller;\n  }, [hasResolution]);\n  const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, () => {\n    return {\n      setCurrentRenderModalComposition: (id) => {\n        setCurrentRenderModalComposition(id);\n      },\n      reloadCurrentlySelectedComposition: () => {\n        if (!currentComposition) {\n          return;\n        }\n        const composition = compositions.find((c) => c.id === currentComposition);\n        if (!composition) {\n          throw new Error(`Could not find composition with id ${currentComposition}`);\n        }\n        const editorProps = allEditorProps[currentComposition] ?? {};\n        const defaultProps = {\n          ...composition.defaultProps ?? {},\n          ...editorProps ?? {}\n        };\n        const props = {\n          ...defaultProps,\n          ...inputProps ?? {}\n        };\n        doResolution({\n          defaultProps,\n          calculateMetadata: composition.calculateMetadata,\n          combinedProps: props,\n          compositionDurationInFrames: composition.durationInFrames ?? null,\n          compositionFps: composition.fps ?? null,\n          compositionHeight: composition.height ?? null,\n          compositionWidth: composition.width ?? null,\n          compositionId: composition.id\n        });\n      }\n    };\n  }, [\n    allEditorProps,\n    compositions,\n    currentComposition,\n    doResolution,\n    inputProps\n  ]);\n  const isTheSame = selectedComposition?.id === renderModalComposition?.id;\n  const currentDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...selectedComposition?.defaultProps ?? {},\n      ...selectedEditorProps ?? {}\n    };\n  }, [selectedComposition?.defaultProps, selectedEditorProps]);\n  const originalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...currentDefaultProps,\n      ...inputProps ?? {}\n    };\n  }, [currentDefaultProps, inputProps]);\n  const canResolve = selectedComposition && needsResolution(selectedComposition);\n  const shouldIgnoreUpdate = typeof window !== \"undefined\" && window.remotion_ignoreFastRefreshUpdate && fastRefreshes <= window.remotion_ignoreFastRefreshUpdate;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (shouldIgnoreUpdate) {\n      return;\n    }\n    if (canResolve) {\n      const controller = doResolution({\n        calculateMetadata: selectedComposition.calculateMetadata,\n        combinedProps: originalProps,\n        compositionDurationInFrames: selectedComposition.durationInFrames ?? null,\n        compositionFps: selectedComposition.fps ?? null,\n        compositionHeight: selectedComposition.height ?? null,\n        compositionWidth: selectedComposition.width ?? null,\n        defaultProps: currentDefaultProps,\n        compositionId: selectedComposition.id\n      });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [\n    canResolve,\n    currentDefaultProps,\n    doResolution,\n    originalProps,\n    selectedComposition?.calculateMetadata,\n    selectedComposition?.durationInFrames,\n    selectedComposition?.fps,\n    selectedComposition?.height,\n    selectedComposition?.id,\n    selectedComposition?.width,\n    shouldIgnoreUpdate\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (renderModalComposition && !isTheSame) {\n      const combinedProps = {\n        ...renderModalComposition.defaultProps ?? {},\n        ...renderModalProps ?? {},\n        ...inputProps ?? {}\n      };\n      const controller = doResolution({\n        calculateMetadata: renderModalComposition.calculateMetadata,\n        compositionDurationInFrames: renderModalComposition.durationInFrames ?? null,\n        compositionFps: renderModalComposition.fps ?? null,\n        compositionHeight: renderModalComposition.height ?? null,\n        compositionId: renderModalComposition.id,\n        compositionWidth: renderModalComposition.width ?? null,\n        defaultProps: currentDefaultProps,\n        combinedProps\n      });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [\n    currentDefaultProps,\n    doResolution,\n    inputProps,\n    isTheSame,\n    renderModalComposition,\n    renderModalProps\n  ]);\n  const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const staticComps = compositions.filter((c) => {\n      return c.calculateMetadata === null;\n    });\n    return {\n      ...resolvedConfigs,\n      ...staticComps.reduce((acc, curr) => {\n        return {\n          ...acc,\n          [curr.id]: {\n            type: \"success\",\n            result: { ...curr, defaultProps: curr.defaultProps ?? {} }\n          }\n        };\n      }, {})\n    };\n  }, [compositions, resolvedConfigs]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n    value: resolvedConfigsIncludingStaticOnes,\n    children\n  });\n};\nvar useResolvedVideoConfig = (preferredCompositionId) => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n  const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n  const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n  const currentComposition = canvasContent?.type === \"composition\" ? canvasContent.compositionId : null;\n  const compositionId = preferredCompositionId ?? currentComposition;\n  const composition = compositions.find((c) => c.id === compositionId);\n  const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return composition ? allEditorProps[composition.id] ?? {} : {};\n  }, [allEditorProps, composition]);\n  const env = useRemotionEnvironment();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!composition) {\n      return null;\n    }\n    if (currentCompositionMetadata) {\n      return {\n        type: \"success\",\n        result: {\n          ...currentCompositionMetadata,\n          id: composition.id,\n          defaultProps: composition.defaultProps ?? {}\n        }\n      };\n    }\n    if (!needsResolution(composition)) {\n      validateDurationInFrames(composition.durationInFrames, {\n        allowFloats: false,\n        component: `in <Composition id=\"${composition.id}\">`\n      });\n      validateFps(composition.fps, `in <Composition id=\"${composition.id}\">`, false);\n      validateDimension(composition.width, \"width\", `in <Composition id=\"${composition.id}\">`);\n      validateDimension(composition.height, \"height\", `in <Composition id=\"${composition.id}\">`);\n      return {\n        type: \"success\",\n        result: {\n          width: composition.width,\n          height: composition.height,\n          fps: composition.fps,\n          id: composition.id,\n          durationInFrames: composition.durationInFrames,\n          defaultProps: composition.defaultProps ?? {},\n          props: {\n            ...composition.defaultProps ?? {},\n            ...selectedEditorProps ?? {},\n            ...typeof window === \"undefined\" || env.isPlayer ? {} : getInputProps() ?? {}\n          },\n          defaultCodec: null,\n          defaultOutName: null,\n          defaultVideoImageFormat: null,\n          defaultPixelFormat: null,\n          defaultProResProfile: null\n        }\n      };\n    }\n    if (!context[composition.id]) {\n      return null;\n    }\n    return context[composition.id];\n  }, [\n    composition,\n    context,\n    currentCompositionMetadata,\n    selectedEditorProps,\n    env.isPlayer\n  ]);\n};\n\n// src/use-video.ts\nvar useVideo = () => {\n  const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n  const selected = compositions.find((c) => {\n    return canvasContent?.type === \"composition\" && c.id === canvasContent.compositionId;\n  });\n  const resolved = useResolvedVideoConfig(selected?.id ?? null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!resolved) {\n      return null;\n    }\n    if (resolved.type === \"error\") {\n      return null;\n    }\n    if (resolved.type === \"loading\") {\n      return null;\n    }\n    if (!selected) {\n      return null;\n    }\n    return {\n      ...resolved.result,\n      defaultProps: selected.defaultProps ?? {},\n      id: selected.id,\n      ...currentCompositionMetadata ?? {},\n      component: selected.component\n    };\n  }, [currentCompositionMetadata, resolved, selected]);\n};\n\n// src/timeline-position-state.ts\nvar TimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  frame: {},\n  playing: false,\n  playbackRate: 1,\n  rootId: \"\",\n  imperativePlaying: {\n    current: false\n  },\n  setPlaybackRate: () => {\n    throw new Error(\"default\");\n  },\n  audioAndVideoTags: { current: [] }\n});\nvar SetTimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  setFrame: () => {\n    throw new Error(\"default\");\n  },\n  setPlaying: () => {\n    throw new Error(\"default\");\n  }\n});\nvar makeKey = () => {\n  return `remotion.time-all`;\n};\nvar persistCurrentFrame = (time) => {\n  localStorage.setItem(makeKey(), JSON.stringify(time));\n};\nvar getInitialFrameState = () => {\n  const item = localStorage.getItem(makeKey()) ?? \"{}\";\n  const obj = JSON.parse(item);\n  return obj;\n};\nvar getFrameForComposition = (composition) => {\n  const item = localStorage.getItem(makeKey()) ?? \"{}\";\n  const obj = JSON.parse(item);\n  if (obj[composition] !== undefined) {\n    return Number(obj[composition]);\n  }\n  if (typeof window === \"undefined\") {\n    return 0;\n  }\n  return window.remotion_initialFrame ?? 0;\n};\nvar useTimelinePosition = () => {\n  const videoConfig = useVideo();\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const env = useRemotionEnvironment();\n  if (!videoConfig) {\n    return typeof window === \"undefined\" ? 0 : window.remotion_initialFrame ?? 0;\n  }\n  const unclamped = state.frame[videoConfig.id] ?? (env.isPlayer ? 0 : getFrameForComposition(videoConfig.id));\n  return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nvar useTimelineSetFrame = () => {\n  const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n  return setFrame;\n};\nvar usePlayingState = () => {\n  const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [playing, setPlaying, imperativePlaying], [imperativePlaying, playing, setPlaying]);\n};\n\n// src/use-video-config.ts\n\n\n// src/CanUseRemotionHooks.tsx\n\n\nvar CanUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar CanUseRemotionHooksProvider = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n    value: true,\n    children\n  });\n};\n\n// src/use-unsafe-video-config.ts\n\nvar useUnsafeVideoConfig = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const ctxWidth = context?.width ?? null;\n  const ctxHeight = context?.height ?? null;\n  const ctxDuration = context?.durationInFrames ?? null;\n  const video = useVideo();\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!video) {\n      return null;\n    }\n    const {\n      id,\n      durationInFrames,\n      fps,\n      height,\n      width,\n      defaultProps,\n      props,\n      defaultCodec,\n      defaultOutName,\n      defaultVideoImageFormat,\n      defaultPixelFormat,\n      defaultProResProfile\n    } = video;\n    return {\n      id,\n      width: ctxWidth ?? width,\n      height: ctxHeight ?? height,\n      fps,\n      durationInFrames: ctxDuration ?? durationInFrames,\n      defaultProps,\n      props,\n      defaultCodec,\n      defaultOutName,\n      defaultVideoImageFormat,\n      defaultPixelFormat,\n      defaultProResProfile\n    };\n  }, [ctxDuration, ctxHeight, ctxWidth, video]);\n};\n\n// src/use-video-config.ts\nvar useVideoConfig = () => {\n  const videoConfig = useUnsafeVideoConfig();\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n  const isPlayer = useIsPlayer();\n  if (!videoConfig) {\n    if (typeof window !== \"undefined\" && window.remotion_isPlayer || isPlayer) {\n      throw new Error([\n        \"No video config found. Likely reasons:\",\n        \"- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.\",\n        \"- You have multiple versions of Remotion installed which causes the React context to get lost.\"\n      ].join(\"-\"));\n    }\n    throw new Error(\"No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.\");\n  }\n  if (!context) {\n    throw new Error(\"Called useVideoConfig() outside a Remotion composition.\");\n  }\n  return videoConfig;\n};\n\n// src/freeze.tsx\n\n\n// src/use-current-frame.ts\n\nvar useCurrentFrame = () => {\n  const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n  const env = useRemotionEnvironment();\n  if (!canUseRemotionHooks) {\n    if (env.isPlayer) {\n      throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n    }\n    throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n  }\n  const frame = useTimelinePosition();\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const contextOffset = context ? context.cumulatedFrom + context.relativeFrom : 0;\n  return frame - contextOffset;\n};\n\n// src/freeze.tsx\n\nvar Freeze = ({\n  frame: frameToFreeze,\n  children,\n  active = true\n}) => {\n  const frame = useCurrentFrame();\n  const videoConfig = useVideoConfig();\n  if (typeof frameToFreeze === \"undefined\") {\n    throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n  }\n  if (typeof frameToFreeze !== \"number\") {\n    throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frameToFreeze}`);\n  }\n  if (Number.isNaN(frameToFreeze)) {\n    throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n  }\n  if (!Number.isFinite(frameToFreeze)) {\n    throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frameToFreeze}.`);\n  }\n  const isActive = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (typeof active === \"boolean\") {\n      return active;\n    }\n    if (typeof active === \"function\") {\n      return active(frame);\n    }\n  }, [active, frame]);\n  const timelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const relativeFrom = sequenceContext?.relativeFrom ?? 0;\n  const timelineValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!isActive) {\n      return timelineContext;\n    }\n    return {\n      ...timelineContext,\n      playing: false,\n      imperativePlaying: {\n        current: false\n      },\n      frame: {\n        [videoConfig.id]: frameToFreeze + relativeFrom\n      }\n    };\n  }, [isActive, timelineContext, videoConfig.id, frameToFreeze, relativeFrom]);\n  const newSequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!sequenceContext) {\n      return null;\n    }\n    if (!isActive) {\n      return sequenceContext;\n    }\n    return {\n      ...sequenceContext,\n      relativeFrom: 0,\n      cumulatedFrom: 0\n    };\n  }, [sequenceContext, isActive]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n    value: timelineValue,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n      value: newSequenceContext,\n      children\n    })\n  });\n};\n\n// src/Sequence.tsx\n\nvar RegularSequenceRefForwardingFunction = ({\n  from = 0,\n  durationInFrames = Infinity,\n  children,\n  name,\n  height,\n  width,\n  showInTimeline = true,\n  _remotionInternalLoopDisplay: loopDisplay,\n  _remotionInternalStack: stack,\n  _remotionInternalPremountDisplay: premountDisplay,\n  _remotionInternalPostmountDisplay: postmountDisplay,\n  ...other\n}, ref) => {\n  const { layout = \"absolute-fill\" } = other;\n  const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const cumulatedFrom = parentSequence ? parentSequence.cumulatedFrom + parentSequence.relativeFrom : 0;\n  const nonce = useNonce();\n  if (layout !== \"absolute-fill\" && layout !== \"none\") {\n    throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n  }\n  if (layout === \"none\" && typeof other.style !== \"undefined\") {\n    throw new TypeError('If layout=\"none\", you may not pass a style.');\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n  }\n  if (typeof from !== \"number\") {\n    throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n  }\n  if (!Number.isFinite(from)) {\n    throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n  }\n  const absoluteFrame = useTimelinePosition();\n  const videoConfig = useVideoConfig();\n  const parentSequenceDuration = parentSequence ? Math.min(parentSequence.durationInFrames - from, durationInFrames) : durationInFrames;\n  const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n  const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n  const premounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return parentSequence?.premounting || Boolean(other._remotionInternalIsPremounting);\n  }, [other._remotionInternalIsPremounting, parentSequence?.premounting]);\n  const postmounting = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return parentSequence?.postmounting || Boolean(other._remotionInternalIsPostmounting);\n  }, [other._remotionInternalIsPostmounting, parentSequence?.postmounting]);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      cumulatedFrom,\n      relativeFrom: from,\n      durationInFrames: actualDurationInFrames,\n      parentFrom: parentSequence?.relativeFrom ?? 0,\n      id,\n      height: height ?? parentSequence?.height ?? null,\n      width: width ?? parentSequence?.width ?? null,\n      premounting,\n      postmounting,\n      premountDisplay: premountDisplay ?? null,\n      postmountDisplay: postmountDisplay ?? null\n    };\n  }, [\n    cumulatedFrom,\n    from,\n    actualDurationInFrames,\n    parentSequence,\n    id,\n    height,\n    width,\n    premounting,\n    postmounting,\n    premountDisplay,\n    postmountDisplay\n  ]);\n  const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return name ?? \"\";\n  }, [name]);\n  const env = useRemotionEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!env.isStudio) {\n      return;\n    }\n    registerSequence({\n      from,\n      duration: actualDurationInFrames,\n      id,\n      displayName: timelineClipName,\n      parent: parentSequence?.id ?? null,\n      type: \"sequence\",\n      rootId,\n      showInTimeline,\n      nonce,\n      loopDisplay,\n      stack: stack ?? null,\n      premountDisplay: premountDisplay ?? null,\n      postmountDisplay: postmountDisplay ?? null\n    });\n    return () => {\n      unregisterSequence(id);\n    };\n  }, [\n    durationInFrames,\n    id,\n    name,\n    registerSequence,\n    timelineClipName,\n    unregisterSequence,\n    parentSequence?.id,\n    actualDurationInFrames,\n    rootId,\n    from,\n    showInTimeline,\n    nonce,\n    loopDisplay,\n    stack,\n    premountDisplay,\n    postmountDisplay,\n    env.isStudio\n  ]);\n  const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n  const content = absoluteFrame < cumulatedFrom + from ? null : absoluteFrame > endThreshold ? null : children;\n  const styleIfThere = other.layout === \"none\" ? undefined : other.style;\n  const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      flexDirection: undefined,\n      ...width ? { width } : {},\n      ...height ? { height } : {},\n      ...styleIfThere ?? {}\n    };\n  }, [height, styleIfThere, width]);\n  if (ref !== null && layout === \"none\") {\n    throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n  }\n  const isSequenceHidden = hidden[id] ?? false;\n  if (isSequenceHidden) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n    value: contextValue,\n    children: content === null ? null : other.layout === \"none\" ? content : /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, {\n      ref,\n      style: defaultStyle,\n      className: other.className,\n      children: content\n    })\n  });\n};\nvar RegularSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(RegularSequenceRefForwardingFunction);\nvar PremountedPostmountedSequenceRefForwardingFunction = (props, ref) => {\n  const frame = useCurrentFrame();\n  if (props.layout === \"none\") {\n    throw new Error('`<Sequence>` with `premountFor` and `postmountFor` props does not support layout=\"none\"');\n  }\n  const {\n    style: passedStyle,\n    from = 0,\n    durationInFrames = Infinity,\n    premountFor = 0,\n    postmountFor = 0,\n    styleWhilePremounted,\n    styleWhilePostmounted,\n    ...otherProps\n  } = props;\n  const endThreshold = Math.ceil(from + durationInFrames - 1);\n  const premountingActive = frame < from && frame >= from - premountFor;\n  const postmountingActive = frame > endThreshold && frame <= endThreshold + postmountFor;\n  const freezeFrame = premountingActive ? from : postmountingActive ? from + durationInFrames - 1 : 0;\n  const isFreezingActive = premountingActive || postmountingActive;\n  const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...passedStyle,\n      opacity: premountingActive || postmountingActive ? 0 : 1,\n      pointerEvents: premountingActive || postmountingActive ? \"none\" : passedStyle?.pointerEvents ?? undefined,\n      ...premountingActive ? styleWhilePremounted : {},\n      ...postmountingActive ? styleWhilePostmounted : {}\n    };\n  }, [\n    passedStyle,\n    premountingActive,\n    postmountingActive,\n    styleWhilePremounted,\n    styleWhilePostmounted\n  ]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Freeze, {\n    frame: freezeFrame,\n    active: isFreezingActive,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      ref,\n      from,\n      durationInFrames,\n      style,\n      _remotionInternalPremountDisplay: premountFor,\n      _remotionInternalPostmountDisplay: postmountFor,\n      _remotionInternalIsPremounting: premountingActive,\n      _remotionInternalIsPostmounting: postmountingActive,\n      ...otherProps\n    })\n  });\n};\nvar PremountedPostmountedSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PremountedPostmountedSequenceRefForwardingFunction);\nvar SequenceRefForwardingFunction = (props, ref) => {\n  const env = useRemotionEnvironment();\n  if (props.layout !== \"none\" && !env.isRendering) {\n    if (props.premountFor || props.postmountFor) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PremountedPostmountedSequence, {\n        ...props,\n        ref\n      });\n    }\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RegularSequence, {\n    ...props,\n    ref\n  });\n};\nvar Sequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n// src/animated-image/AnimatedImage.tsx\n\n\n// src/cancel-render.ts\nvar isErrorLike = (err) => {\n  if (err instanceof Error) {\n    return true;\n  }\n  if (err === null) {\n    return false;\n  }\n  if (typeof err !== \"object\") {\n    return false;\n  }\n  if (!(\"stack\" in err)) {\n    return false;\n  }\n  if (typeof err.stack !== \"string\") {\n    return false;\n  }\n  if (!(\"message\" in err)) {\n    return false;\n  }\n  if (typeof err.message !== \"string\") {\n    return false;\n  }\n  return true;\n};\nfunction cancelRender(err) {\n  let error;\n  if (isErrorLike(err)) {\n    error = err;\n    if (!error.stack) {\n      error.stack = new Error(error.message).stack;\n    }\n  } else if (typeof err === \"string\") {\n    error = Error(err);\n  } else {\n    error = Error(\"Rendering was cancelled\");\n  }\n  window.remotion_cancelledError = error.stack;\n  throw error;\n}\n\n// src/use-delay-render.ts\n\n\n// src/log.ts\nvar logLevels = [\"trace\", \"verbose\", \"info\", \"warn\", \"error\"];\nvar getNumberForLogLevel = (level) => {\n  return logLevels.indexOf(level);\n};\nvar isEqualOrBelowLogLevel = (currentLevel, level) => {\n  return getNumberForLogLevel(currentLevel) <= getNumberForLogLevel(level);\n};\nvar transformArgs = ({\n  args,\n  logLevel,\n  tag\n}) => {\n  const arr = [...args];\n  if (getRemotionEnvironment().isRendering && !getRemotionEnvironment().isClientSideRendering) {\n    arr.unshift(Symbol.for(`__remotion_level_${logLevel}`));\n  }\n  if (tag && getRemotionEnvironment().isRendering && !getRemotionEnvironment().isClientSideRendering) {\n    arr.unshift(Symbol.for(`__remotion_tag_${tag}`));\n  }\n  return arr;\n};\nvar verbose = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"verbose\")) {\n    return console.debug(...transformArgs({ args, logLevel: \"verbose\", tag: options.tag }));\n  }\n};\nvar trace = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"trace\")) {\n    return console.debug(...transformArgs({ args, logLevel: \"trace\", tag: options.tag }));\n  }\n};\nvar info = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"info\")) {\n    return console.log(...transformArgs({ args, logLevel: \"info\", tag: options.tag }));\n  }\n};\nvar warn = (options, ...args) => {\n  if (isEqualOrBelowLogLevel(options.logLevel, \"warn\")) {\n    return console.warn(...transformArgs({ args, logLevel: \"warn\", tag: options.tag }));\n  }\n};\nvar error = (options, ...args) => {\n  return console.error(...transformArgs({ args, logLevel: \"error\", tag: options.tag }));\n};\nvar Log = {\n  trace,\n  verbose,\n  info,\n  warn,\n  error\n};\n\n// src/delay-render.ts\nvar handles = [];\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n  if (!window.remotion_delayRenderTimeouts) {\n    window.remotion_delayRenderTimeouts = {};\n  }\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\nvar defaultTimeout = 30000;\nvar delayRenderInternal = (environment, label, options) => {\n  if (typeof label !== \"string\" && typeof label !== \"undefined\") {\n    throw new Error(\"The label parameter of delayRender() must be a string or undefined, got: \" + JSON.stringify(label));\n  }\n  const handle = Math.random();\n  handles.push(handle);\n  const called = Error().stack?.replace(/^Error/g, \"\") ?? \"\";\n  if (environment.isRendering) {\n    const timeoutToUse = (options?.timeoutInMilliseconds ?? (typeof window === \"undefined\" ? defaultTimeout : window.remotion_puppeteerTimeout ?? defaultTimeout)) - 2000;\n    if (typeof window !== \"undefined\") {\n      const retriesLeft = (options?.retries ?? 0) - (window.remotion_attempt - 1);\n      window.remotion_delayRenderTimeouts[handle] = {\n        label: label ?? null,\n        startTime: Date.now(),\n        timeout: setTimeout(() => {\n          const message = [\n            `A delayRender()`,\n            label ? `\"${label}\"` : null,\n            `was called but not cleared after ${timeoutToUse}ms. See https://remotion.dev/docs/timeout for help.`,\n            retriesLeft > 0 ? DELAY_RENDER_RETRIES_LEFT + retriesLeft : null,\n            retriesLeft > 0 ? DELAY_RENDER_RETRY_TOKEN : null,\n            DELAY_RENDER_CALLSTACK_TOKEN,\n            called\n          ].filter(truthy).join(\" \");\n          cancelRender(Error(message));\n        }, timeoutToUse)\n      };\n    }\n  }\n  if (typeof window !== \"undefined\") {\n    window.remotion_renderReady = false;\n  }\n  return handle;\n};\nvar delayRender = (label, options) => {\n  return delayRenderInternal(getRemotionEnvironment(), label, options);\n};\nvar continueRenderInternal = (handle, environment) => {\n  if (typeof handle === \"undefined\") {\n    throw new TypeError(\"The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.\");\n  }\n  if (typeof handle !== \"number\") {\n    throw new TypeError(\"The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: \" + JSON.stringify(handle));\n  }\n  handles = handles.filter((h) => {\n    if (h === handle) {\n      if (environment.isRendering) {\n        if (!window.remotion_delayRenderTimeouts[handle]) {\n          return false;\n        }\n        const { label, startTime, timeout } = window.remotion_delayRenderTimeouts[handle];\n        clearTimeout(timeout);\n        const message = [\n          label ? `\"${label}\"` : \"A handle\",\n          DELAY_RENDER_CLEAR_TOKEN,\n          `${Date.now() - startTime}ms`\n        ].filter(truthy).join(\" \");\n        Log.verbose({ logLevel: window.remotion_logLevel, tag: \"delayRender()\" }, message);\n        delete window.remotion_delayRenderTimeouts[handle];\n      }\n      return false;\n    }\n    return true;\n  });\n  if (handles.length === 0 && typeof window !== \"undefined\") {\n    window.remotion_renderReady = true;\n  }\n};\nvar continueRender = (handle) => {\n  continueRenderInternal(handle, getRemotionEnvironment());\n};\n\n// src/use-delay-render.ts\nvar useDelayRender = () => {\n  const environment = useRemotionEnvironment();\n  const delayRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((label, options) => {\n    return delayRenderInternal(environment, label, options);\n  }, [environment]);\n  const continueRender2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((handle) => {\n    continueRenderInternal(handle, environment);\n  }, [environment]);\n  return { delayRender: delayRender2, continueRender: continueRender2 };\n};\n\n// src/animated-image/canvas.tsx\n\n\nvar calcArgs = (fit, frameSize, canvasSize) => {\n  switch (fit) {\n    case \"fill\": {\n      return [\n        0,\n        0,\n        frameSize.width,\n        frameSize.height,\n        0,\n        0,\n        canvasSize.width,\n        canvasSize.height\n      ];\n    }\n    case \"contain\": {\n      const ratio = Math.min(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n      const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n      const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n      return [\n        0,\n        0,\n        frameSize.width,\n        frameSize.height,\n        centerX,\n        centerY,\n        frameSize.width * ratio,\n        frameSize.height * ratio\n      ];\n    }\n    case \"cover\": {\n      const ratio = Math.max(canvasSize.width / frameSize.width, canvasSize.height / frameSize.height);\n      const centerX = (canvasSize.width - frameSize.width * ratio) / 2;\n      const centerY = (canvasSize.height - frameSize.height * ratio) / 2;\n      return [\n        0,\n        0,\n        frameSize.width,\n        frameSize.height,\n        centerX,\n        centerY,\n        frameSize.width * ratio,\n        frameSize.height * ratio\n      ];\n    }\n    default:\n      throw new Error(\"Unknown fit: \" + fit);\n  }\n};\nvar CanvasRefForwardingFunction = ({ width, height, fit, className, style }, ref) => {\n  const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const draw = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((imageData) => {\n    const canvas = canvasRef.current;\n    const canvasWidth = width ?? imageData.displayWidth;\n    const canvasHeight = height ?? imageData.displayHeight;\n    if (!canvas) {\n      throw new Error(\"Canvas ref is not set\");\n    }\n    const ctx = canvasRef.current?.getContext(\"2d\");\n    if (!ctx) {\n      throw new Error(\"Could not get 2d context\");\n    }\n    canvas.width = canvasWidth;\n    canvas.height = canvasHeight;\n    ctx.drawImage(imageData, ...calcArgs(fit, {\n      height: imageData.displayHeight,\n      width: imageData.displayWidth\n    }, {\n      width: canvasWidth,\n      height: canvasHeight\n    }));\n  }, [fit, height, width]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return {\n      draw,\n      getCanvas: () => {\n        if (!canvasRef.current) {\n          throw new Error(\"Canvas ref is not set\");\n        }\n        return canvasRef.current;\n      },\n      clear: () => {\n        const ctx = canvasRef.current?.getContext(\"2d\");\n        if (!ctx) {\n          throw new Error(\"Could not get 2d context\");\n        }\n        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);\n      }\n    };\n  }, [draw]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"canvas\", {\n    ref: canvasRef,\n    className,\n    style\n  });\n};\nvar Canvas = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(CanvasRefForwardingFunction);\n\n// src/animated-image/decode-image.ts\nvar CACHE_SIZE = 5;\nvar getActualTime = ({\n  loopBehavior,\n  durationFound,\n  timeInSec\n}) => {\n  return loopBehavior === \"loop\" ? durationFound ? timeInSec % durationFound : timeInSec : Math.min(timeInSec, durationFound || Infinity);\n};\nvar decodeImage = async ({\n  resolvedSrc,\n  signal,\n  currentTime,\n  initialLoopBehavior\n}) => {\n  if (typeof ImageDecoder === \"undefined\") {\n    throw new Error(\"Your browser does not support the WebCodecs ImageDecoder API.\");\n  }\n  const res = await fetch(resolvedSrc, { signal });\n  const { body } = res;\n  if (!body) {\n    throw new Error(\"Got no body\");\n  }\n  const decoder = new ImageDecoder({\n    data: body,\n    type: res.headers.get(\"Content-Type\") || \"image/gif\"\n  });\n  await decoder.completed;\n  const { selectedTrack } = decoder.tracks;\n  if (!selectedTrack) {\n    throw new Error(\"No selected track\");\n  }\n  const cache = [];\n  let durationFound = null;\n  const getFrameByIndex = async (frameIndex) => {\n    const foundInCache = cache.find((c) => c.frameIndex === frameIndex);\n    if (foundInCache && foundInCache.frame) {\n      return foundInCache;\n    }\n    const frame = await decoder.decode({\n      frameIndex,\n      completeFramesOnly: true\n    });\n    if (foundInCache) {\n      foundInCache.frame = frame.image;\n    } else {\n      cache.push({\n        frame: frame.image,\n        frameIndex,\n        timeInSeconds: frame.image.timestamp / 1e6\n      });\n    }\n    return {\n      frame: frame.image,\n      frameIndex,\n      timeInSeconds: frame.image.timestamp / 1e6\n    };\n  };\n  const clearCache = (closeToTimeInSec) => {\n    const itemsInCache = cache.filter((c) => c.frame);\n    const sortByClosestToCurrentTime = itemsInCache.sort((a, b) => {\n      const aDiff = Math.abs(a.timeInSeconds - closeToTimeInSec);\n      const bDiff = Math.abs(b.timeInSeconds - closeToTimeInSec);\n      return aDiff - bDiff;\n    });\n    for (let i = 0;i < sortByClosestToCurrentTime.length; i++) {\n      if (i < CACHE_SIZE) {\n        continue;\n      }\n      const item = sortByClosestToCurrentTime[i];\n      item.frame = null;\n    }\n  };\n  const ensureFrameBeforeAndAfter = async ({\n    timeInSec,\n    loopBehavior\n  }) => {\n    const actualTimeInSec = getActualTime({\n      durationFound,\n      loopBehavior,\n      timeInSec\n    });\n    const framesBefore = cache.filter((c) => c.timeInSeconds <= actualTimeInSec);\n    const biggestIndex = framesBefore.map((c) => c.frameIndex).reduce((a, b) => Math.max(a, b), 0);\n    let i = biggestIndex;\n    while (true) {\n      const f = await getFrameByIndex(i);\n      i++;\n      if (!f.frame) {\n        throw new Error(\"No frame found\");\n      }\n      if (!f.frame.duration) {\n        break;\n      }\n      if (i === selectedTrack.frameCount && durationFound === null) {\n        const duration = (f.frame.timestamp + f.frame.duration) / 1e6;\n        durationFound = duration;\n      }\n      if (f.timeInSeconds > actualTimeInSec || i === selectedTrack.frameCount) {\n        break;\n      }\n    }\n    if (selectedTrack.frameCount - biggestIndex < 3 && loopBehavior === \"loop\") {\n      await getFrameByIndex(0);\n    }\n    clearCache(actualTimeInSec);\n  };\n  await ensureFrameBeforeAndAfter({\n    timeInSec: currentTime,\n    loopBehavior: initialLoopBehavior\n  });\n  await ensureFrameBeforeAndAfter({\n    timeInSec: currentTime,\n    loopBehavior: initialLoopBehavior\n  });\n  const getFrame = async (timeInSec, loopBehavior) => {\n    if (durationFound !== null && timeInSec > durationFound && loopBehavior === \"clear-after-finish\") {\n      return null;\n    }\n    const actualTimeInSec = getActualTime({\n      loopBehavior,\n      durationFound,\n      timeInSec\n    });\n    await ensureFrameBeforeAndAfter({ timeInSec: actualTimeInSec, loopBehavior });\n    const itemsInCache = cache.filter((c) => c.frame);\n    const closest = itemsInCache.reduce((a, b) => {\n      const aDiff = Math.abs(a.timeInSeconds - actualTimeInSec);\n      const bDiff = Math.abs(b.timeInSeconds - actualTimeInSec);\n      return aDiff < bDiff ? a : b;\n    });\n    if (!closest.frame) {\n      throw new Error(\"No frame found\");\n    }\n    return closest;\n  };\n  return {\n    getFrame,\n    frameCount: selectedTrack.frameCount\n  };\n};\n\n// src/animated-image/resolve-image-source.tsx\nvar resolveAnimatedImageSource = (src) => {\n  if (typeof window === \"undefined\") {\n    return src;\n  }\n  return new URL(src, window.origin).href;\n};\n\n// src/animated-image/AnimatedImage.tsx\n\nvar AnimatedImage = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(({\n  src,\n  width,\n  height,\n  onError,\n  loopBehavior = \"loop\",\n  playbackRate = 1,\n  fit = \"fill\",\n  ...props\n}, canvasRef) => {\n  const mountState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({ isMounted: true });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = mountState;\n    current.isMounted = true;\n    return () => {\n      current.isMounted = false;\n    };\n  }, []);\n  const resolvedSrc = resolveAnimatedImageSource(src);\n  const [imageDecoder, setImageDecoder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const [decodeHandle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender2(`Rendering <AnimatedImage/> with src=\"${resolvedSrc}\"`));\n  const frame = useCurrentFrame();\n  const { fps } = useVideoConfig();\n  const currentTime = frame / playbackRate / fps;\n  const currentTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(currentTime);\n  currentTimeRef.current = currentTime;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(canvasRef, () => {\n    const c = ref.current?.getCanvas();\n    if (!c) {\n      throw new Error(\"Canvas ref is not set\");\n    }\n    return c;\n  }, []);\n  const [initialLoopBehavior] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => loopBehavior);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const controller = new AbortController;\n    decodeImage({\n      resolvedSrc,\n      signal: controller.signal,\n      currentTime: currentTimeRef.current,\n      initialLoopBehavior\n    }).then((d) => {\n      setImageDecoder(d);\n      continueRender2(decodeHandle);\n    }).catch((err) => {\n      if (err.name === \"AbortError\") {\n        continueRender2(decodeHandle);\n        return;\n      }\n      if (onError) {\n        onError?.(err);\n        continueRender2(decodeHandle);\n      } else {\n        cancelRender(err);\n      }\n    });\n    return () => {\n      controller.abort();\n    };\n  }, [\n    resolvedSrc,\n    decodeHandle,\n    onError,\n    initialLoopBehavior,\n    continueRender2\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!imageDecoder) {\n      return;\n    }\n    const delay = delayRender2(`Rendering frame at ${currentTime} of <AnimatedImage src=\"${src}\"/>`);\n    imageDecoder.getFrame(currentTime, loopBehavior).then((videoFrame) => {\n      if (mountState.current.isMounted) {\n        if (videoFrame === null) {\n          ref.current?.clear();\n        } else {\n          ref.current?.draw(videoFrame.frame);\n        }\n      }\n      continueRender2(delay);\n    }).catch((err) => {\n      if (onError) {\n        onError(err);\n        continueRender2(delay);\n      } else {\n        cancelRender(err);\n      }\n    });\n  }, [\n    currentTime,\n    imageDecoder,\n    loopBehavior,\n    onError,\n    src,\n    continueRender2,\n    delayRender2\n  ]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Canvas, {\n    ref,\n    width,\n    height,\n    fit,\n    ...props\n  });\n});\n// src/Artifact.tsx\n\n\n// src/RenderAssetManager.tsx\n\n\n// src/validation/validate-artifact.ts\nvar validateArtifactFilename = (filename) => {\n  if (typeof filename !== \"string\") {\n    throw new TypeError(`The \"filename\" must be a string, but you passed a value of type ${typeof filename}`);\n  }\n  if (filename.trim() === \"\") {\n    throw new Error(\"The `filename` must not be empty\");\n  }\n  if (!filename.match(/^([0-9a-zA-Z-!_.*'()/:&$@=;+,?]+)/g)) {\n    throw new Error('The `filename` must match \"/^([0-9a-zA-Z-!_.*\\'()/:&$@=;+,?]+)/g\". Use forward slashes only, even on Windows.');\n  }\n};\nvar validateContent = (content) => {\n  if (typeof content !== \"string\" && !(content instanceof Uint8Array)) {\n    throw new TypeError(`The \"content\" must be a string or Uint8Array, but you passed a value of type ${typeof content}`);\n  }\n  if (typeof content === \"string\" && content.trim() === \"\") {\n    throw new Error(\"The `content` must not be empty\");\n  }\n};\nvar validateRenderAsset = (artifact) => {\n  if (artifact.type !== \"artifact\") {\n    return;\n  }\n  validateArtifactFilename(artifact.filename);\n  if (artifact.contentType === \"thumbnail\") {\n    return;\n  }\n  validateContent(artifact.content);\n};\n\n// src/RenderAssetManager.tsx\n\nvar RenderAssetManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  registerRenderAsset: () => {\n    return;\n  },\n  unregisterRenderAsset: () => {\n    return;\n  },\n  renderAssets: []\n});\nvar RenderAssetManagerProvider = ({ children }) => {\n  const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset) => {\n    validateRenderAsset(renderAsset);\n    setRenderAssets((assets) => {\n      return [...assets, renderAsset];\n    });\n  }, []);\n  const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    setRenderAssets((assts) => {\n      return assts.filter((a) => a.id !== id);\n    });\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (typeof window !== \"undefined\") {\n      window.remotion_collectAssets = () => {\n        setRenderAssets([]);\n        return renderAssets;\n      };\n    }\n  }, [renderAssets]);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerRenderAsset,\n      unregisterRenderAsset,\n      renderAssets\n    };\n  }, [renderAssets, registerRenderAsset, unregisterRenderAsset]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n    value: contextValue,\n    children\n  });\n};\n\n// src/Artifact.tsx\nvar ArtifactThumbnail = Symbol(\"Thumbnail\");\nvar Artifact = ({ filename, content, downloadBehavior }) => {\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  const env = useRemotionEnvironment();\n  const frame = useCurrentFrame();\n  const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    return String(Math.random());\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!env.isRendering) {\n      return;\n    }\n    if (content instanceof Uint8Array) {\n      registerRenderAsset({\n        type: \"artifact\",\n        id,\n        content: btoa(new TextDecoder(\"utf8\").decode(content)),\n        filename,\n        frame,\n        contentType: \"binary\",\n        downloadBehavior: downloadBehavior ?? null\n      });\n    } else if (content === ArtifactThumbnail) {\n      registerRenderAsset({\n        type: \"artifact\",\n        id,\n        filename,\n        frame,\n        contentType: \"thumbnail\",\n        downloadBehavior: downloadBehavior ?? null\n      });\n    } else {\n      registerRenderAsset({\n        type: \"artifact\",\n        id,\n        content,\n        filename,\n        frame,\n        contentType: \"text\",\n        downloadBehavior: downloadBehavior ?? null\n      });\n    }\n    return () => {\n      return unregisterRenderAsset(id);\n    };\n  }, [\n    content,\n    env.isRendering,\n    filename,\n    frame,\n    id,\n    registerRenderAsset,\n    unregisterRenderAsset,\n    downloadBehavior\n  ]);\n  return null;\n};\nArtifact.Thumbnail = ArtifactThumbnail;\n// src/audio/Audio.tsx\n\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  if (relativeSrc.startsWith(\"http://\") || relativeSrc.startsWith(\"https://\") || relativeSrc.startsWith(\"file://\") || relativeSrc.startsWith(\"blob:\") || relativeSrc.startsWith(\"data:\")) {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/calculate-media-duration.ts\nvar calculateMediaDuration = ({\n  trimAfter,\n  mediaDurationInFrames,\n  playbackRate,\n  trimBefore\n}) => {\n  let duration = mediaDurationInFrames;\n  if (typeof trimAfter !== \"undefined\") {\n    duration = trimAfter;\n  }\n  if (typeof trimBefore !== \"undefined\") {\n    duration -= trimBefore;\n  }\n  const actualDuration = duration / playbackRate;\n  return Math.floor(actualDuration);\n};\n\n// src/loop/index.tsx\n\n\nvar LoopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useLoop = () => {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LoopContext);\n};\nvar Loop = ({ durationInFrames, times = Infinity, children, name, ...props }) => {\n  const currentFrame = useCurrentFrame();\n  const { durationInFrames: compDuration } = useVideoConfig();\n  validateDurationInFrames(durationInFrames, {\n    component: \"of the <Loop /> component\",\n    allowFloats: true\n  });\n  if (typeof times !== \"number\") {\n    throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n  }\n  if (times !== Infinity && times % 1 !== 0) {\n    throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n  }\n  if (times < 0) {\n    throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n  }\n  const maxTimes = Math.ceil(compDuration / durationInFrames);\n  const actualTimes = Math.min(maxTimes, times);\n  const style = props.layout === \"none\" ? undefined : props.style;\n  const maxFrame = durationInFrames * (actualTimes - 1);\n  const iteration = Math.floor(currentFrame / durationInFrames);\n  const start = iteration * durationInFrames;\n  const from = Math.min(start, maxFrame);\n  const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      numberOfTimes: actualTimes,\n      startOffset: -from,\n      durationInFrames\n    };\n  }, [actualTimes, durationInFrames, from]);\n  const loopContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      iteration: Math.floor(currentFrame / durationInFrames),\n      durationInFrames\n    };\n  }, [currentFrame, durationInFrames]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LoopContext.Provider, {\n    value: loopContext,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      durationInFrames,\n      from,\n      name: name ?? \"<Loop>\",\n      _remotionInternalLoopDisplay: loopDisplay,\n      layout: props.layout,\n      style,\n      children\n    })\n  });\n};\nLoop.useLoop = useLoop;\n\n// src/prefetch.ts\n\n\n// src/playback-logging.ts\nvar playbackLogging = ({\n  logLevel,\n  tag,\n  message,\n  mountTime\n}) => {\n  const tags = [mountTime ? Date.now() - mountTime + \"ms \" : null, tag].filter(Boolean).join(\" \");\n  Log.trace({ logLevel, tag: null }, `[${tags}]`, message);\n};\n\n// src/prefetch-state.tsx\n\n\nvar PreloadContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nvar preloads = {};\nvar updaters = [];\nvar setPreloads = (updater) => {\n  preloads = updater(preloads);\n  updaters.forEach((u) => u());\n};\nvar PrefetchProvider = ({ children }) => {\n  const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => preloads);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const updaterFunction = () => {\n      _setPreloads(preloads);\n    };\n    updaters.push(updaterFunction);\n    return () => {\n      updaters = updaters.filter((u) => u !== updaterFunction);\n    };\n  }, []);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n    value: _preloads,\n    children\n  });\n};\n\n// src/prefetch.ts\nvar removeAndGetHashFragment = (src) => {\n  const hashIndex = src.indexOf(\"#\");\n  if (hashIndex === -1) {\n    return null;\n  }\n  return hashIndex;\n};\nvar getSrcWithoutHash = (src) => {\n  const hashIndex = removeAndGetHashFragment(src);\n  if (hashIndex === null) {\n    return src;\n  }\n  return src.slice(0, hashIndex);\n};\nvar usePreload = (src) => {\n  const preloads2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n  const hashFragmentIndex = removeAndGetHashFragment(src);\n  const withoutHashFragment = getSrcWithoutHash(src);\n  if (!preloads2[withoutHashFragment]) {\n    return src;\n  }\n  if (hashFragmentIndex !== null) {\n    return preloads2[withoutHashFragment] + src.slice(hashFragmentIndex);\n  }\n  return preloads2[withoutHashFragment];\n};\nvar blobToBase64 = function(blob) {\n  const reader = new FileReader;\n  return new Promise((resolve, reject) => {\n    reader.onload = function() {\n      const dataUrl = reader.result;\n      resolve(dataUrl);\n    };\n    reader.onerror = (err) => {\n      return reject(err);\n    };\n    reader.readAsDataURL(blob);\n  });\n};\nvar getBlobFromReader = async ({\n  reader,\n  contentType,\n  contentLength,\n  onProgress\n}) => {\n  let receivedLength = 0;\n  const chunks = [];\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    chunks.push(value);\n    receivedLength += value.length;\n    if (onProgress) {\n      onProgress({ loadedBytes: receivedLength, totalBytes: contentLength });\n    }\n  }\n  const chunksAll = new Uint8Array(receivedLength);\n  let position = 0;\n  for (const chunk of chunks) {\n    chunksAll.set(chunk, position);\n    position += chunk.length;\n  }\n  return new Blob([chunksAll], {\n    type: contentType ?? undefined\n  });\n};\nvar prefetch = (src, options) => {\n  const method = options?.method ?? \"blob-url\";\n  const logLevel = options?.logLevel ?? \"info\";\n  const srcWithoutHash = getSrcWithoutHash(src);\n  if (getRemotionEnvironment().isRendering) {\n    return {\n      free: () => {\n        return;\n      },\n      waitUntilDone: () => Promise.resolve(srcWithoutHash)\n    };\n  }\n  Log.verbose({ logLevel, tag: \"prefetch\" }, `Starting prefetch ${srcWithoutHash}`);\n  let canceled = false;\n  let objectUrl = null;\n  let resolve = () => {\n    return;\n  };\n  let reject = () => {\n    return;\n  };\n  const waitUntilDone = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  const controller = new AbortController;\n  let canBeAborted = true;\n  fetch(srcWithoutHash, {\n    signal: controller.signal,\n    credentials: options?.credentials ?? undefined\n  }).then((res) => {\n    canBeAborted = false;\n    if (canceled) {\n      return null;\n    }\n    if (!res.ok) {\n      throw new Error(`HTTP error, status = ${res.status}`);\n    }\n    const headerContentType = res.headers.get(\"Content-Type\");\n    const contentType = options?.contentType ?? headerContentType;\n    const hasProperContentType = contentType && (contentType.startsWith(\"video/\") || contentType.startsWith(\"audio/\") || contentType.startsWith(\"image/\"));\n    if (!hasProperContentType) {\n      console.warn(`Called prefetch() on ${srcWithoutHash} which returned a \"Content-Type\" of ${headerContentType}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n    }\n    if (!res.body) {\n      throw new Error(`HTTP response of ${srcWithoutHash} has no body`);\n    }\n    const reader = res.body.getReader();\n    return getBlobFromReader({\n      reader,\n      contentType: options?.contentType ?? headerContentType ?? null,\n      contentLength: res.headers.get(\"Content-Length\") ? parseInt(res.headers.get(\"Content-Length\"), 10) : null,\n      onProgress: options?.onProgress\n    });\n  }).then((buf) => {\n    if (!buf) {\n      return;\n    }\n    const actualBlob = options?.contentType ? new Blob([buf], { type: options.contentType }) : buf;\n    if (method === \"base64\") {\n      return blobToBase64(actualBlob);\n    }\n    return URL.createObjectURL(actualBlob);\n  }).then((url) => {\n    if (canceled) {\n      return;\n    }\n    playbackLogging({\n      logLevel,\n      tag: \"prefetch\",\n      message: `Finished prefetch ${srcWithoutHash} with method ${method}`,\n      mountTime: null\n    });\n    objectUrl = url;\n    setPreloads((p) => ({\n      ...p,\n      [srcWithoutHash]: objectUrl\n    }));\n    resolve(objectUrl);\n  }).catch((err) => {\n    if (err?.message.includes(\"free() called\")) {\n      return;\n    }\n    reject(err);\n  });\n  return {\n    free: () => {\n      playbackLogging({\n        logLevel,\n        tag: \"prefetch\",\n        message: `Freeing ${srcWithoutHash}`,\n        mountTime: null\n      });\n      if (objectUrl) {\n        if (method === \"blob-url\") {\n          URL.revokeObjectURL(objectUrl);\n        }\n        setPreloads((p) => {\n          const copy = { ...p };\n          delete copy[srcWithoutHash];\n          return copy;\n        });\n      } else {\n        canceled = true;\n        if (canBeAborted) {\n          try {\n            controller.abort(new Error(\"free() called\"));\n          } catch {}\n        }\n      }\n    },\n    waitUntilDone: () => {\n      return waitUntilDone;\n    }\n  };\n};\n\n// src/validate-media-props.ts\nvar validateMediaProps = (props, component) => {\n  if (typeof props.volume !== \"number\" && typeof props.volume !== \"function\" && typeof props.volume !== \"undefined\") {\n    throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n  }\n  if (typeof props.volume === \"number\" && props.volume < 0) {\n    throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n  }\n  if (typeof props.playbackRate !== \"number\" && typeof props.playbackRate !== \"undefined\") {\n    throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n  }\n  if (typeof props.playbackRate === \"number\" && (isNaN(props.playbackRate) || !Number.isFinite(props.playbackRate) || props.playbackRate <= 0)) {\n    throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n  }\n};\n\n// src/validate-start-from-props.ts\nvar validateStartFromProps = (startFrom, endAt) => {\n  if (typeof startFrom !== \"undefined\") {\n    if (typeof startFrom !== \"number\") {\n      throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n    }\n    if (isNaN(startFrom) || startFrom === Infinity) {\n      throw new TypeError(\"startFrom prop can not be NaN or Infinity.\");\n    }\n    if (startFrom < 0) {\n      throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n    }\n  }\n  if (typeof endAt !== \"undefined\") {\n    if (typeof endAt !== \"number\") {\n      throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n    }\n    if (isNaN(endAt)) {\n      throw new TypeError(\"endAt prop can not be NaN.\");\n    }\n    if (endAt <= 0) {\n      throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n    }\n  }\n  if (endAt < startFrom) {\n    throw new TypeError(\"endAt prop must be greater than startFrom prop.\");\n  }\n};\nvar validateTrimProps = (trimBefore, trimAfter) => {\n  if (typeof trimBefore !== \"undefined\") {\n    if (typeof trimBefore !== \"number\") {\n      throw new TypeError(`type of trimBefore prop must be a number, instead got type ${typeof trimBefore}.`);\n    }\n    if (isNaN(trimBefore) || trimBefore === Infinity) {\n      throw new TypeError(\"trimBefore prop can not be NaN or Infinity.\");\n    }\n    if (trimBefore < 0) {\n      throw new TypeError(`trimBefore must be greater than equal to 0 instead got ${trimBefore}.`);\n    }\n  }\n  if (typeof trimAfter !== \"undefined\") {\n    if (typeof trimAfter !== \"number\") {\n      throw new TypeError(`type of trimAfter prop must be a number, instead got type ${typeof trimAfter}.`);\n    }\n    if (isNaN(trimAfter)) {\n      throw new TypeError(\"trimAfter prop can not be NaN.\");\n    }\n    if (trimAfter <= 0) {\n      throw new TypeError(`trimAfter must be a positive number, instead got ${trimAfter}.`);\n    }\n  }\n  if (trimAfter <= trimBefore) {\n    throw new TypeError(\"trimAfter prop must be greater than trimBefore prop.\");\n  }\n};\nvar validateMediaTrimProps = ({\n  startFrom,\n  endAt,\n  trimBefore,\n  trimAfter\n}) => {\n  if (typeof startFrom !== \"undefined\" && typeof trimBefore !== \"undefined\") {\n    throw new TypeError(\"Cannot use both startFrom and trimBefore props. Use trimBefore instead as startFrom is deprecated.\");\n  }\n  if (typeof endAt !== \"undefined\" && typeof trimAfter !== \"undefined\") {\n    throw new TypeError(\"Cannot use both endAt and trimAfter props. Use trimAfter instead as endAt is deprecated.\");\n  }\n  const hasNewProps = typeof trimBefore !== \"undefined\" || typeof trimAfter !== \"undefined\";\n  const hasOldProps = typeof startFrom !== \"undefined\" || typeof endAt !== \"undefined\";\n  if (hasNewProps) {\n    validateTrimProps(trimBefore, trimAfter);\n  } else if (hasOldProps) {\n    validateStartFromProps(startFrom, endAt);\n  }\n};\nvar resolveTrimProps = ({\n  startFrom,\n  endAt,\n  trimBefore,\n  trimAfter\n}) => {\n  const trimBeforeValue = trimBefore ?? startFrom ?? undefined;\n  const trimAfterValue = trimAfter ?? endAt ?? undefined;\n  return { trimBeforeValue, trimAfterValue };\n};\n\n// src/video/duration-state.tsx\n\n\nvar durationReducer = (state, action) => {\n  switch (action.type) {\n    case \"got-duration\": {\n      const absoluteSrc = getAbsoluteSrc(action.src);\n      if (state[absoluteSrc] === action.durationInSeconds) {\n        return state;\n      }\n      return {\n        ...state,\n        [absoluteSrc]: action.durationInSeconds\n      };\n    }\n    default:\n      return state;\n  }\n};\nvar DurationsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  durations: {},\n  setDurations: () => {\n    throw new Error(\"context missing\");\n  }\n});\nvar DurationsContextProvider = ({ children }) => {\n  const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      durations,\n      setDurations\n    };\n  }, [durations]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, {\n    value,\n    children\n  });\n};\n\n// src/audio/AudioForPreview.tsx\n\n\n// src/get-cross-origin-value.ts\nvar getCrossOriginValue = ({\n  crossOrigin,\n  requestsVideoFrame\n}) => {\n  if (crossOrigin !== undefined && crossOrigin !== null) {\n    return crossOrigin;\n  }\n  if (requestsVideoFrame) {\n    return \"anonymous\";\n  }\n  return;\n};\n\n// src/log-level-context.tsx\n\n\nvar LogLevelContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  logLevel: \"info\",\n  mountTime: 0\n});\nvar useLogLevel = () => {\n  const { logLevel } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n  if (logLevel === null) {\n    throw new Error(\"useLogLevel must be used within a LogLevelProvider\");\n  }\n  return logLevel;\n};\nvar useMountTime = () => {\n  const { mountTime } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n  if (mountTime === null) {\n    throw new Error(\"useMountTime must be used within a LogLevelProvider\");\n  }\n  return mountTime;\n};\n\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n\n// src/use-amplification.ts\n\n\n// src/audio/shared-audio-tags.tsx\n\n\n// src/play-and-handle-not-allowed-error.ts\nvar playAndHandleNotAllowedError = ({\n  mediaRef,\n  mediaType,\n  onAutoPlayError,\n  logLevel,\n  mountTime,\n  reason,\n  isPlayer\n}) => {\n  const { current } = mediaRef;\n  if (!current) {\n    return;\n  }\n  playbackLogging({\n    logLevel,\n    tag: \"play\",\n    message: `Attempting to play ${current.src}. Reason: ${reason}`,\n    mountTime\n  });\n  const prom = current.play();\n  if (!prom.catch) {\n    return;\n  }\n  prom.catch((err) => {\n    if (!current) {\n      return;\n    }\n    if (err.message.includes(\"request was interrupted by a call to pause\")) {\n      return;\n    }\n    if (err.message.includes(\"The operation was aborted.\")) {\n      return;\n    }\n    if (err.message.includes(\"The fetching process for the media resource was aborted by the user agent\")) {\n      return;\n    }\n    if (err.message.includes(\"request was interrupted by a new load request\")) {\n      return;\n    }\n    if (err.message.includes(\"because the media was removed from the document\")) {\n      return;\n    }\n    if (err.message.includes(\"user didn't interact with the document\") && current.muted) {\n      return;\n    }\n    console.log(`Could not play ${mediaType} due to following error: `, err);\n    if (!current.muted) {\n      if (onAutoPlayError) {\n        onAutoPlayError();\n        return;\n      }\n      console.log(`The video will be muted and we'll retry playing it.`);\n      if (mediaType === \"video\" && isPlayer) {\n        console.log(\"Use onAutoPlayError() to handle this error yourself.\");\n      }\n      current.muted = true;\n      current.play();\n    }\n  });\n};\n\n// src/audio/shared-element-source-node.ts\nvar makeSharedElementSourceNode = ({\n  audioContext,\n  ref\n}) => {\n  let connected = null;\n  return {\n    attemptToConnect: () => {\n      if (!connected && ref.current) {\n        const mediaElementSourceNode = audioContext.createMediaElementSource(ref.current);\n        connected = mediaElementSourceNode;\n      }\n    },\n    get: () => {\n      if (!connected) {\n        throw new Error(\"Audio element not connected\");\n      }\n      return connected;\n    }\n  };\n};\n\n// src/audio/use-audio-context.ts\n\nvar warned = false;\nvar warnOnce = (logLevel) => {\n  if (warned) {\n    return;\n  }\n  warned = true;\n  if (typeof window !== \"undefined\") {\n    Log.warn({ logLevel, tag: null }, \"AudioContext is not supported in this browser\");\n  }\n};\nvar useSingletonAudioContext = (logLevel, latencyHint) => {\n  const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (typeof AudioContext === \"undefined\") {\n      warnOnce(logLevel);\n      return null;\n    }\n    return new AudioContext({\n      latencyHint\n    });\n  }, [logLevel, latencyHint]);\n  return audioContext;\n};\n\n// src/audio/shared-audio-tags.tsx\n\nvar EMPTY_AUDIO = \"data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV\";\nvar compareProps = (obj1, obj2) => {\n  const keysA = Object.keys(obj1).sort();\n  const keysB = Object.keys(obj2).sort();\n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  for (let i = 0;i < keysA.length; i++) {\n    if (keysA[i] !== keysB[i]) {\n      return false;\n    }\n    if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n      return false;\n    }\n  }\n  return true;\n};\nvar didPropChange = (key, newProp, prevProp) => {\n  if (key === \"src\" && !prevProp.startsWith(\"data:\") && !newProp.startsWith(\"data:\")) {\n    return new URL(prevProp, window.origin).toString() !== new URL(newProp, window.origin).toString();\n  }\n  if (prevProp === newProp) {\n    return false;\n  }\n  return true;\n};\nvar SharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar SharedAudioContextProvider = ({ children, numberOfAudioTags, component, audioLatencyHint }) => {\n  const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n  if (numberOfAudioTags !== initialNumberOfAudioTags) {\n    throw new Error(\"The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.\");\n  }\n  const logLevel = useLogLevel();\n  const audioContext = useSingletonAudioContext(logLevel, audioLatencyHint);\n  const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return new Array(numberOfAudioTags).fill(true).map(() => {\n      const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\n      return {\n        id: Math.random(),\n        ref,\n        mediaElementSourceNode: audioContext ? makeSharedElementSourceNode({\n          audioContext,\n          ref\n        }) : null\n      };\n    });\n  }, [audioContext, numberOfAudioTags]);\n  const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n  const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    refs.forEach(({ ref, id }) => {\n      const data = audios.current?.find((a) => a.id === id);\n      const { current } = ref;\n      if (!current) {\n        return;\n      }\n      if (data === undefined) {\n        current.src = EMPTY_AUDIO;\n        return;\n      }\n      if (!data) {\n        throw new TypeError(\"Expected audio data to be there\");\n      }\n      Object.keys(data.props).forEach((key) => {\n        if (didPropChange(key, data.props[key], current[key])) {\n          current[key] = data.props[key];\n        }\n      });\n    });\n  }, [refs]);\n  const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((options) => {\n    const { aud, audioId, premounting } = options;\n    const found = audios.current?.find((a) => a.audioId === audioId);\n    if (found) {\n      return found;\n    }\n    const firstFreeAudio = takenAudios.current.findIndex((a) => a === false);\n    if (firstFreeAudio === -1) {\n      throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Html5Audio /> tags at the same time. With the current settings, the maximum amount of <Html5Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#using-the-numberofsharedaudiotags-prop for more information on how to increase this limit.`);\n    }\n    const { id, ref, mediaElementSourceNode } = refs[firstFreeAudio];\n    const cloned = [...takenAudios.current];\n    cloned[firstFreeAudio] = id;\n    takenAudios.current = cloned;\n    const newElem = {\n      props: aud,\n      id,\n      el: ref,\n      audioId,\n      mediaElementSourceNode,\n      premounting\n    };\n    audios.current?.push(newElem);\n    rerenderAudios();\n    return newElem;\n  }, [numberOfAudioTags, refs, rerenderAudios]);\n  const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    const cloned = [...takenAudios.current];\n    const index = refs.findIndex((r) => r.id === id);\n    if (index === -1) {\n      throw new TypeError(\"Error occured in \");\n    }\n    cloned[index] = false;\n    takenAudios.current = cloned;\n    audios.current = audios.current?.filter((a) => a.id !== id);\n    rerenderAudios();\n  }, [refs, rerenderAudios]);\n  const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({\n    aud,\n    audioId,\n    id,\n    premounting\n  }) => {\n    let changed = false;\n    audios.current = audios.current?.map((prevA) => {\n      if (prevA.id === id) {\n        const isTheSame = compareProps(aud, prevA.props) && prevA.premounting === premounting;\n        if (isTheSame) {\n          return prevA;\n        }\n        changed = true;\n        return {\n          ...prevA,\n          props: aud,\n          premounting,\n          audioId\n        };\n      }\n      return prevA;\n    });\n    if (changed) {\n      rerenderAudios();\n    }\n  }, [rerenderAudios]);\n  const mountTime = useMountTime();\n  const env = useRemotionEnvironment();\n  const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    refs.forEach((ref) => {\n      const audio = audios.current.find((a) => a.el === ref.ref);\n      if (audio?.premounting) {\n        return;\n      }\n      playAndHandleNotAllowedError({\n        mediaRef: ref.ref,\n        mediaType: \"audio\",\n        onAutoPlayError: null,\n        logLevel,\n        mountTime,\n        reason: \"playing all audios\",\n        isPlayer: env.isPlayer\n      });\n    });\n    audioContext?.resume();\n  }, [audioContext, logLevel, mountTime, refs, env.isPlayer]);\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerAudio,\n      unregisterAudio,\n      updateAudio,\n      playAllAudios,\n      numberOfAudioTags,\n      audioContext\n    };\n  }, [\n    numberOfAudioTags,\n    playAllAudios,\n    registerAudio,\n    unregisterAudio,\n    updateAudio,\n    audioContext\n  ]);\n  const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    takenAudios.current = new Array(numberOfAudioTags).fill(false);\n    audios.current = [];\n    rerenderAudios();\n  }, [numberOfAudioTags, rerenderAudios]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return () => {\n      resetAudio();\n    };\n  }, [component, resetAudio]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, {\n    value,\n    children: [\n      refs.map(({ id, ref }) => {\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n          ref,\n          preload: \"metadata\",\n          src: EMPTY_AUDIO\n        }, id);\n      }),\n      children\n    ]\n  });\n};\nvar useSharedAudio = ({\n  aud,\n  audioId,\n  premounting\n}) => {\n  const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n    if (ctx && ctx.numberOfAudioTags > 0) {\n      return ctx.registerAudio({ aud, audioId, premounting });\n    }\n    const el = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n    const mediaElementSourceNode = ctx?.audioContext ? makeSharedElementSourceNode({\n      audioContext: ctx.audioContext,\n      ref: el\n    }) : null;\n    return {\n      el,\n      id: Math.random(),\n      props: aud,\n      audioId,\n      mediaElementSourceNode,\n      premounting\n    };\n  });\n  const effectToUse = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect ?? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n  if (typeof document !== \"undefined\") {\n    effectToUse(() => {\n      if (ctx && ctx.numberOfAudioTags > 0) {\n        ctx.updateAudio({ id: elem.id, aud, audioId, premounting });\n      }\n    }, [aud, ctx, elem.id, audioId, premounting]);\n    effectToUse(() => {\n      return () => {\n        if (ctx && ctx.numberOfAudioTags > 0) {\n          ctx.unregisterAudio(elem.id);\n        }\n      };\n    }, [ctx, elem.id]);\n  }\n  return elem;\n};\n\n// src/is-approximately-the-same.ts\nvar FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nvar isApproximatelyTheSame = (num1, num2) => {\n  return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n\n// src/video/video-fragment.ts\n\nvar toSeconds = (time, fps) => {\n  return Math.round(time / fps * 100) / 100;\n};\nvar isSafari = () => {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n  const isAppleWebKit = /AppleWebKit/.test(window.navigator.userAgent);\n  if (!isAppleWebKit) {\n    return false;\n  }\n  const isNotChrome = !window.navigator.userAgent.includes(\"Chrome/\");\n  return isNotChrome;\n};\nvar isIosSafari = () => {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n  const isIpadIPodIPhone = /iP(ad|od|hone)/i.test(window.navigator.userAgent);\n  return isIpadIPodIPhone && isSafari();\n};\nvar isIOSSafariAndBlob = (actualSrc) => {\n  return isIosSafari() && actualSrc.startsWith(\"blob:\");\n};\nvar getVideoFragmentStart = ({\n  actualFrom,\n  fps\n}) => {\n  return toSeconds(Math.max(0, -actualFrom), fps);\n};\nvar getVideoFragmentEnd = ({\n  duration,\n  fps\n}) => {\n  return toSeconds(duration, fps);\n};\nvar appendVideoFragment = ({\n  actualSrc,\n  actualFrom,\n  duration,\n  fps\n}) => {\n  if (isIOSSafariAndBlob(actualSrc)) {\n    return actualSrc;\n  }\n  if (actualSrc.startsWith(\"data:\")) {\n    return actualSrc;\n  }\n  const existingHash = Boolean(new URL(actualSrc, (typeof window === \"undefined\" ? null : window.location.href) ?? \"http://localhost:3000\").hash);\n  if (existingHash) {\n    return actualSrc;\n  }\n  if (!Number.isFinite(actualFrom)) {\n    return actualSrc;\n  }\n  const withStartHash = `${actualSrc}#t=${getVideoFragmentStart({ actualFrom, fps })}`;\n  if (!Number.isFinite(duration)) {\n    return withStartHash;\n  }\n  return `${withStartHash},${getVideoFragmentEnd({ duration, fps })}`;\n};\nvar isSubsetOfDuration = ({\n  prevStartFrom,\n  newStartFrom,\n  prevDuration,\n  newDuration,\n  fps\n}) => {\n  const previousFrom = getVideoFragmentStart({ actualFrom: prevStartFrom, fps });\n  const newFrom = getVideoFragmentStart({ actualFrom: newStartFrom, fps });\n  const previousEnd = getVideoFragmentEnd({ duration: prevDuration, fps });\n  const newEnd = getVideoFragmentEnd({ duration: newDuration, fps });\n  if (newFrom < previousFrom) {\n    return false;\n  }\n  if (newEnd > previousEnd) {\n    return false;\n  }\n  return true;\n};\nvar useAppendVideoFragment = ({\n  actualSrc: initialActualSrc,\n  actualFrom: initialActualFrom,\n  duration: initialDuration,\n  fps\n}) => {\n  const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n  const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n  const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n  if (!isSubsetOfDuration({\n    prevStartFrom: actualFromRef.current,\n    newStartFrom: initialActualFrom,\n    prevDuration: actualDuration.current,\n    newDuration: initialDuration,\n    fps\n  }) || initialActualSrc !== actualSrc.current) {\n    actualFromRef.current = initialActualFrom;\n    actualDuration.current = initialDuration;\n    actualSrc.current = initialActualSrc;\n  }\n  const appended = appendVideoFragment({\n    actualSrc: actualSrc.current,\n    actualFrom: actualFromRef.current,\n    duration: actualDuration.current,\n    fps\n  });\n  return appended;\n};\n\n// src/use-amplification.ts\nvar warned2 = false;\nvar warnSafariOnce = (logLevel) => {\n  if (warned2) {\n    return;\n  }\n  warned2 = true;\n  Log.warn({ logLevel, tag: null }, \"In Safari, setting a volume and a playback rate at the same time is buggy.\");\n  Log.warn({ logLevel, tag: null }, \"In Desktop Safari, only volumes <= 1 will be applied.\");\n  Log.warn({ logLevel, tag: null }, logLevel, \"In Mobile Safari, the volume will be ignored and set to 1 if a playbackRate is set.\");\n};\nvar useVolume = ({\n  mediaRef,\n  volume,\n  logLevel,\n  source,\n  shouldUseWebAudioApi\n}) => {\n  const audioStuffRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const currentVolumeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(volume);\n  currentVolumeRef.current = volume;\n  const sharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  if (!sharedAudioContext) {\n    throw new Error(\"useAmplification must be used within a SharedAudioContext\");\n  }\n  const { audioContext } = sharedAudioContext;\n  if (typeof window !== \"undefined\") {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (!audioContext) {\n        return;\n      }\n      if (!mediaRef.current) {\n        return;\n      }\n      if (!shouldUseWebAudioApi) {\n        return;\n      }\n      if (mediaRef.current.playbackRate !== 1 && isSafari()) {\n        warnSafariOnce(logLevel);\n        return;\n      }\n      if (!source) {\n        return;\n      }\n      const gainNode = new GainNode(audioContext, {\n        gain: currentVolumeRef.current\n      });\n      source.attemptToConnect();\n      source.get().connect(gainNode);\n      gainNode.connect(audioContext.destination);\n      audioStuffRef.current = {\n        gainNode\n      };\n      Log.trace({ logLevel, tag: null }, `Starting to amplify ${mediaRef.current?.src}. Gain = ${currentVolumeRef.current}, playbackRate = ${mediaRef.current?.playbackRate}`);\n      return () => {\n        audioStuffRef.current = null;\n        gainNode.disconnect();\n        source.get().disconnect();\n      };\n    }, [logLevel, mediaRef, audioContext, source, shouldUseWebAudioApi]);\n  }\n  if (audioStuffRef.current) {\n    const valueToSet = volume;\n    if (!isApproximatelyTheSame(audioStuffRef.current.gainNode.gain.value, valueToSet)) {\n      audioStuffRef.current.gainNode.gain.value = valueToSet;\n      Log.trace({ logLevel, tag: null }, `Setting gain to ${valueToSet} for ${mediaRef.current?.src}`);\n    }\n  }\n  const safariCase = isSafari() && mediaRef.current && mediaRef.current?.playbackRate !== 1;\n  const shouldUseTraditionalVolume = safariCase || !shouldUseWebAudioApi;\n  if (shouldUseTraditionalVolume && mediaRef.current && !isApproximatelyTheSame(volume, mediaRef.current?.volume)) {\n    mediaRef.current.volume = Math.min(volume, 1);\n  }\n  return audioStuffRef;\n};\n\n// src/use-media-in-timeline.ts\n\n\n// src/audio/use-audio-frame.ts\n\nvar useMediaStartsAt = () => {\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const startsAt = Math.min(0, parentSequence?.relativeFrom ?? 0);\n  return startsAt;\n};\nvar useFrameForVolumeProp = (behavior) => {\n  const loop = Loop.useLoop();\n  const frame = useCurrentFrame();\n  const startsAt = useMediaStartsAt();\n  if (behavior === \"repeat\" || loop === null) {\n    return frame + startsAt;\n  }\n  return frame + startsAt + loop.durationInFrames * loop.iteration;\n};\n\n// src/get-asset-file-name.ts\nvar getAssetDisplayName = (filename) => {\n  if (/data:|blob:/.test(filename.substring(0, 5))) {\n    return \"Data URL\";\n  }\n  const splitted = filename.split(\"/\").map((s) => s.split(\"\\\\\")).flat(1);\n  return splitted[splitted.length - 1];\n};\n\n// src/volume-prop.ts\nvar evaluateVolume = ({\n  frame,\n  volume,\n  mediaVolume = 1\n}) => {\n  if (typeof volume === \"number\") {\n    return volume * mediaVolume;\n  }\n  if (typeof volume === \"undefined\") {\n    return Number(mediaVolume);\n  }\n  const evaluated = volume(frame) * mediaVolume;\n  if (typeof evaluated !== \"number\") {\n    throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n  }\n  if (Number.isNaN(evaluated)) {\n    throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n  }\n  if (!Number.isFinite(evaluated)) {\n    throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n  }\n  return Math.max(0, evaluated);\n};\n\n// src/use-media-in-timeline.ts\nvar didWarn = {};\nvar warnOnce2 = (message) => {\n  if (didWarn[message]) {\n    return;\n  }\n  console.warn(message);\n  didWarn[message] = true;\n};\nvar useBasicMediaInTimeline = ({\n  volume,\n  mediaVolume,\n  mediaType,\n  src,\n  displayName,\n  trimBefore,\n  trimAfter,\n  playbackRate\n}) => {\n  if (!src) {\n    throw new Error(\"No src passed\");\n  }\n  const startsAt = useMediaStartsAt();\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const videoConfig = useVideoConfig();\n  const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => volume);\n  const mediaDuration = calculateMediaDuration({\n    mediaDurationInFrames: videoConfig.durationInFrames,\n    playbackRate,\n    trimBefore,\n    trimAfter\n  });\n  const duration = parentSequence ? Math.min(parentSequence.durationInFrames, mediaDuration) : mediaDuration;\n  const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (typeof volume === \"number\") {\n      return volume;\n    }\n    return new Array(Math.floor(Math.max(0, duration + startsAt))).fill(true).map((_, i) => {\n      return evaluateVolume({\n        frame: i + startsAt,\n        volume,\n        mediaVolume\n      });\n    }).join(\",\");\n  }, [duration, startsAt, volume, mediaVolume]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (typeof volume === \"number\" && volume !== initialVolume) {\n      warnOnce2(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/audio/volume`);\n    }\n  }, [initialVolume, mediaType, src, volume]);\n  const doesVolumeChange = typeof volume === \"function\";\n  const nonce = useNonce();\n  const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const env = useRemotionEnvironment();\n  return {\n    volumes,\n    duration,\n    doesVolumeChange,\n    nonce,\n    rootId,\n    isStudio: env.isStudio,\n    finalDisplayName: displayName ?? getAssetDisplayName(src)\n  };\n};\nvar useMediaInTimeline = ({\n  volume,\n  mediaVolume,\n  src,\n  mediaType,\n  playbackRate,\n  displayName,\n  id,\n  stack,\n  showInTimeline,\n  premountDisplay,\n  postmountDisplay,\n  loopDisplay\n}) => {\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const startsAt = useMediaStartsAt();\n  const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n  const {\n    volumes,\n    duration,\n    doesVolumeChange,\n    nonce,\n    rootId,\n    isStudio,\n    finalDisplayName\n  } = useBasicMediaInTimeline({\n    volume,\n    mediaVolume,\n    mediaType,\n    src,\n    displayName,\n    trimAfter: undefined,\n    trimBefore: undefined,\n    playbackRate\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!src) {\n      throw new Error(\"No src passed\");\n    }\n    if (!isStudio && window.process?.env?.NODE_ENV !== \"test\") {\n      return;\n    }\n    if (!showInTimeline) {\n      return;\n    }\n    registerSequence({\n      type: mediaType,\n      src,\n      id,\n      duration,\n      from: 0,\n      parent: parentSequence?.id ?? null,\n      displayName: finalDisplayName,\n      rootId,\n      volume: volumes,\n      showInTimeline: true,\n      nonce,\n      startMediaFrom: 0 - startsAt,\n      doesVolumeChange,\n      loopDisplay,\n      playbackRate,\n      stack,\n      premountDisplay,\n      postmountDisplay\n    });\n    return () => {\n      unregisterSequence(id);\n    };\n  }, [\n    duration,\n    id,\n    parentSequence,\n    src,\n    registerSequence,\n    unregisterSequence,\n    volumes,\n    doesVolumeChange,\n    nonce,\n    mediaType,\n    startsAt,\n    playbackRate,\n    stack,\n    showInTimeline,\n    premountDisplay,\n    postmountDisplay,\n    isStudio,\n    loopDisplay,\n    rootId,\n    finalDisplayName\n  ]);\n};\n\n// src/use-media-playback.ts\n\n\n// src/buffer-until-first-frame.ts\n\n\n// src/use-buffer-state.ts\n\n\n// src/buffering.tsx\n\n\nvar useBufferManager = (logLevel, mountTime) => {\n  const [blocks, setBlocks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [onBufferingCallbacks, setOnBufferingCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [onResumeCallbacks, setOnResumeCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const addBlock = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((block) => {\n    setBlocks((b) => [...b, block]);\n    return {\n      unblock: () => {\n        setBlocks((b) => {\n          const newArr = b.filter((bx) => bx !== block);\n          if (newArr.length === b.length) {\n            return b;\n          }\n          return newArr;\n        });\n      }\n    };\n  }, []);\n  const listenForBuffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback) => {\n    setOnBufferingCallbacks((c) => [...c, callback]);\n    return {\n      remove: () => {\n        setOnBufferingCallbacks((c) => c.filter((cb) => cb !== callback));\n      }\n    };\n  }, []);\n  const listenForResume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback) => {\n    setOnResumeCallbacks((c) => [...c, callback]);\n    return {\n      remove: () => {\n        setOnResumeCallbacks((c) => c.filter((cb) => cb !== callback));\n      }\n    };\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (blocks.length > 0) {\n      onBufferingCallbacks.forEach((c) => c());\n      playbackLogging({\n        logLevel,\n        message: \"Player is entering buffer state\",\n        mountTime,\n        tag: \"player\"\n      });\n    }\n  }, [blocks]);\n  if (typeof window !== \"undefined\") {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (blocks.length === 0) {\n        onResumeCallbacks.forEach((c) => c());\n        playbackLogging({\n          logLevel,\n          message: \"Player is exiting buffer state\",\n          mountTime,\n          tag: \"player\"\n        });\n      }\n    }, [blocks]);\n  }\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return { addBlock, listenForBuffering, listenForResume, buffering };\n  }, [addBlock, buffering, listenForBuffering, listenForResume]);\n};\nvar BufferingContextReact = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar BufferingProvider = ({ children }) => {\n  const { logLevel, mountTime } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LogLevelContext);\n  const bufferManager = useBufferManager(logLevel ?? \"info\", mountTime);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n    value: bufferManager,\n    children\n  });\n};\nvar useIsPlayerBuffering = (bufferManager) => {\n  const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(bufferManager.buffering.current);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const onBuffer = () => {\n      setIsBuffering(true);\n    };\n    const onResume = () => {\n      setIsBuffering(false);\n    };\n    bufferManager.listenForBuffering(onBuffer);\n    bufferManager.listenForResume(onResume);\n    return () => {\n      bufferManager.listenForBuffering(() => {\n        return;\n      });\n      bufferManager.listenForResume(() => {\n        return;\n      });\n    };\n  }, [bufferManager]);\n  return isBuffering;\n};\n\n// src/use-buffer-state.ts\nvar useBufferState = () => {\n  const buffer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n  const addBlock = buffer ? buffer.addBlock : null;\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    delayPlayback: () => {\n      if (!addBlock) {\n        throw new Error(\"Tried to enable the buffering state, but a Remotion context was not found. This API can only be called in a component that was passed to the Remotion Player or a <Composition>. Or you might have experienced a version mismatch - run `npx remotion versions` and ensure all packages have the same version. This error is thrown by the buffer state https://remotion.dev/docs/player/buffer-state\");\n      }\n      const { unblock } = addBlock({\n        id: String(Math.random())\n      });\n      return { unblock };\n    }\n  }), [addBlock]);\n};\n\n// src/buffer-until-first-frame.ts\nvar isSafariWebkit = () => {\n  const isSafari2 = /^((?!chrome|android).)*safari/i.test(window.navigator.userAgent);\n  return isSafari2;\n};\nvar useBufferUntilFirstFrame = ({\n  mediaRef,\n  mediaType,\n  onVariableFpsVideoDetected,\n  pauseWhenBuffering,\n  logLevel,\n  mountTime\n}) => {\n  const bufferingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const { delayPlayback } = useBufferState();\n  const bufferUntilFirstFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((requestedTime) => {\n    if (mediaType !== \"video\") {\n      return;\n    }\n    if (!pauseWhenBuffering) {\n      return;\n    }\n    const current = mediaRef.current;\n    if (!current) {\n      return;\n    }\n    if (current.readyState >= current.HAVE_FUTURE_DATA && !isSafariWebkit()) {\n      playbackLogging({\n        logLevel,\n        message: `Not using buffer until first frame, because readyState is ${current.readyState} and is not Safari or Desktop Chrome`,\n        mountTime,\n        tag: \"buffer\"\n      });\n      return;\n    }\n    if (!current.requestVideoFrameCallback) {\n      playbackLogging({\n        logLevel,\n        message: `Not using buffer until first frame, because requestVideoFrameCallback is not supported`,\n        mountTime,\n        tag: \"buffer\"\n      });\n      return;\n    }\n    bufferingRef.current = true;\n    playbackLogging({\n      logLevel,\n      message: `Buffering ${mediaRef.current?.src} until the first frame is received`,\n      mountTime,\n      tag: \"buffer\"\n    });\n    const playback = delayPlayback();\n    const unblock = () => {\n      playback.unblock();\n      current.removeEventListener(\"ended\", unblock, {\n        once: true\n      });\n      current.removeEventListener(\"pause\", unblock, {\n        once: true\n      });\n      bufferingRef.current = false;\n    };\n    const onEndedOrPauseOrCanPlay = () => {\n      unblock();\n    };\n    current.requestVideoFrameCallback((_, info2) => {\n      const differenceFromRequested = Math.abs(info2.mediaTime - requestedTime);\n      if (differenceFromRequested > 0.5) {\n        onVariableFpsVideoDetected();\n      }\n      unblock();\n    });\n    current.addEventListener(\"ended\", onEndedOrPauseOrCanPlay, { once: true });\n    current.addEventListener(\"pause\", onEndedOrPauseOrCanPlay, { once: true });\n    current.addEventListener(\"canplay\", onEndedOrPauseOrCanPlay, {\n      once: true\n    });\n  }, [\n    delayPlayback,\n    logLevel,\n    mediaRef,\n    mediaType,\n    mountTime,\n    onVariableFpsVideoDetected,\n    pauseWhenBuffering\n  ]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      isBuffering: () => bufferingRef.current,\n      bufferUntilFirstFrame\n    };\n  }, [bufferUntilFirstFrame]);\n};\n\n// src/media-tag-current-time-timestamp.ts\n\nvar useCurrentTimeOfMediaTagWithUpdateTimeStamp = (mediaRef) => {\n  const lastUpdate = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n    time: mediaRef.current?.currentTime ?? 0,\n    lastUpdate: performance.now()\n  });\n  const nowCurrentTime = mediaRef.current?.currentTime ?? null;\n  if (nowCurrentTime !== null) {\n    if (lastUpdate.current.time !== nowCurrentTime) {\n      lastUpdate.current.time = nowCurrentTime;\n      lastUpdate.current.lastUpdate = performance.now();\n    }\n  }\n  return lastUpdate;\n};\n\n// src/seek.ts\nvar seek = ({\n  mediaRef,\n  time,\n  logLevel,\n  why,\n  mountTime\n}) => {\n  const timeToSet = isIosSafari() ? Number(time.toFixed(1)) : time;\n  playbackLogging({\n    logLevel,\n    tag: \"seek\",\n    message: `Seeking from ${mediaRef.currentTime} to ${timeToSet}. src= ${mediaRef.src} Reason: ${why}`,\n    mountTime\n  });\n  mediaRef.currentTime = timeToSet;\n  return timeToSet;\n};\n\n// src/use-media-buffering.ts\n\nvar useMediaBuffering = ({\n  element,\n  shouldBuffer,\n  isPremounting,\n  isPostmounting,\n  logLevel,\n  mountTime,\n  src\n}) => {\n  const buffer = useBufferState();\n  const [isBuffering, setIsBuffering] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    let cleanupFns = [];\n    const { current } = element;\n    if (!current) {\n      return;\n    }\n    if (!shouldBuffer) {\n      return;\n    }\n    if (isPremounting || isPostmounting) {\n      if ((isPremounting || isPostmounting) && current.readyState < current.HAVE_FUTURE_DATA) {\n        if (!navigator.userAgent.includes(\"Firefox/\")) {\n          playbackLogging({\n            logLevel,\n            message: `Calling .load() on ${current.src} because readyState is ${current.readyState} and it is not Firefox. Element is premounted ${current.playbackRate}`,\n            tag: \"load\",\n            mountTime\n          });\n          const previousPlaybackRate = current.playbackRate;\n          current.load();\n          current.playbackRate = previousPlaybackRate;\n        }\n      }\n      return;\n    }\n    const cleanup = (reason) => {\n      let didDoSomething = false;\n      cleanupFns.forEach((fn) => {\n        fn(reason);\n        didDoSomething = true;\n      });\n      cleanupFns = [];\n      setIsBuffering((previous) => {\n        if (previous) {\n          didDoSomething = true;\n        }\n        return false;\n      });\n      if (didDoSomething) {\n        playbackLogging({\n          logLevel,\n          message: `Unmarking as buffering: ${current.src}. Reason: ${reason}`,\n          tag: \"buffer\",\n          mountTime\n        });\n      }\n    };\n    const blockMedia = (reason) => {\n      setIsBuffering(true);\n      playbackLogging({\n        logLevel,\n        message: `Marking as buffering: ${current.src}. Reason: ${reason}`,\n        tag: \"buffer\",\n        mountTime\n      });\n      const { unblock } = buffer.delayPlayback();\n      const onCanPlay = () => {\n        cleanup('\"canplay\" was fired');\n        init();\n      };\n      const onError = () => {\n        cleanup('\"error\" event was occurred');\n        init();\n      };\n      current.addEventListener(\"canplay\", onCanPlay, {\n        once: true\n      });\n      cleanupFns.push(() => {\n        current.removeEventListener(\"canplay\", onCanPlay);\n      });\n      current.addEventListener(\"error\", onError, {\n        once: true\n      });\n      cleanupFns.push(() => {\n        current.removeEventListener(\"error\", onError);\n      });\n      cleanupFns.push((cleanupReason) => {\n        playbackLogging({\n          logLevel,\n          message: `Unblocking ${current.src} from buffer. Reason: ${cleanupReason}`,\n          tag: \"buffer\",\n          mountTime\n        });\n        unblock();\n      });\n    };\n    const init = () => {\n      if (current.readyState < current.HAVE_FUTURE_DATA) {\n        blockMedia(`readyState is ${current.readyState}, which is less than HAVE_FUTURE_DATA`);\n        if (!navigator.userAgent.includes(\"Firefox/\")) {\n          playbackLogging({\n            logLevel,\n            message: `Calling .load() on ${src} because readyState is ${current.readyState} and it is not Firefox. ${current.playbackRate}`,\n            tag: \"load\",\n            mountTime\n          });\n          const previousPlaybackRate = current.playbackRate;\n          current.load();\n          current.playbackRate = previousPlaybackRate;\n        }\n      } else {\n        const onWaiting = () => {\n          blockMedia('\"waiting\" event was fired');\n        };\n        current.addEventListener(\"waiting\", onWaiting);\n        cleanupFns.push(() => {\n          current.removeEventListener(\"waiting\", onWaiting);\n        });\n      }\n    };\n    init();\n    return () => {\n      cleanup(\"element was unmounted or prop changed\");\n    };\n  }, [\n    buffer,\n    src,\n    element,\n    isPremounting,\n    isPostmounting,\n    logLevel,\n    shouldBuffer,\n    mountTime\n  ]);\n  return isBuffering;\n};\n\n// src/use-request-video-callback-time.ts\n\nvar useRequestVideoCallbackTime = ({\n  mediaRef,\n  mediaType,\n  lastSeek,\n  onVariableFpsVideoDetected\n}) => {\n  const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = mediaRef;\n    if (current) {\n      currentTime.current = {\n        time: current.currentTime,\n        lastUpdate: performance.now()\n      };\n    } else {\n      currentTime.current = null;\n      return;\n    }\n    if (mediaType !== \"video\") {\n      currentTime.current = null;\n      return;\n    }\n    const videoTag = current;\n    if (!videoTag.requestVideoFrameCallback) {\n      return;\n    }\n    let cancel = () => {\n      return;\n    };\n    const request = () => {\n      if (!videoTag) {\n        return;\n      }\n      const cb = videoTag.requestVideoFrameCallback((_, info2) => {\n        if (currentTime.current !== null) {\n          const difference = Math.abs(currentTime.current.time - info2.mediaTime);\n          const differenceToLastSeek = Math.abs(lastSeek.current === null ? Infinity : info2.mediaTime - lastSeek.current);\n          if (difference > 0.5 && differenceToLastSeek > 0.5 && info2.mediaTime > currentTime.current.time) {\n            onVariableFpsVideoDetected();\n          }\n        }\n        currentTime.current = {\n          time: info2.mediaTime,\n          lastUpdate: performance.now()\n        };\n        request();\n      });\n      cancel = () => {\n        videoTag.cancelVideoFrameCallback(cb);\n        cancel = () => {\n          return;\n        };\n      };\n    };\n    request();\n    return () => {\n      cancel();\n    };\n  }, [lastSeek, mediaRef, mediaType, onVariableFpsVideoDetected]);\n  return currentTime;\n};\n\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {}\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {}\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\nvar getMediaTime = ({\n  fps,\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  const expectedFrame = getExpectedMediaFrameUncorrected({\n    frame,\n    playbackRate,\n    startFrom\n  });\n  const msPerFrame = 1000 / fps;\n  return expectedFrame * msPerFrame / 1000;\n};\n\n// src/warn-about-non-seekable-media.ts\nvar alreadyWarned = {};\nvar warnAboutNonSeekableMedia = (ref, type) => {\n  if (ref === null) {\n    return;\n  }\n  if (ref.seekable.length === 0) {\n    return;\n  }\n  if (ref.seekable.length > 1) {\n    return;\n  }\n  if (alreadyWarned[ref.src]) {\n    return;\n  }\n  const range = { start: ref.seekable.start(0), end: ref.seekable.end(0) };\n  if (range.start === 0 && range.end === 0) {\n    const msg = [\n      `The media ${ref.src} cannot be seeked. This could be one of few reasons:`,\n      \"1) The media resource was replaced while the video is playing but it was not loaded yet.\",\n      \"2) The media does not support seeking.\",\n      \"3) The media was loaded with security headers prventing it from being included.\",\n      \"Please see https://remotion.dev/docs/non-seekable-media for assistance.\"\n    ].join(`\n`);\n    if (type === \"console-error\") {\n      console.error(msg);\n    } else if (type === \"console-warning\") {\n      console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n    } else {\n      throw new Error(msg);\n    }\n    alreadyWarned[ref.src] = true;\n  }\n};\n\n// src/use-media-playback.ts\nvar useMediaPlayback = ({\n  mediaRef,\n  src,\n  mediaType,\n  playbackRate: localPlaybackRate,\n  onlyWarnForMediaSeekingError,\n  acceptableTimeshift,\n  pauseWhenBuffering,\n  isPremounting,\n  isPostmounting,\n  onAutoPlayError\n}) => {\n  const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const frame = useCurrentFrame();\n  const absoluteFrame = useTimelinePosition();\n  const [playing] = usePlayingState();\n  const buffering = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(BufferingContextReact);\n  const { fps } = useVideoConfig();\n  const mediaStartsAt = useMediaStartsAt();\n  const lastSeekDueToShift = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const lastSeek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  if (!buffering) {\n    throw new Error(\"useMediaPlayback must be used inside a <BufferingContext>\");\n  }\n  const isVariableFpsVideoMap = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  const onVariableFpsVideoDetected = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (!src) {\n      return;\n    }\n    if (isVariableFpsVideoMap.current[src]) {\n      return;\n    }\n    Log.verbose({ logLevel, tag: null }, `Detected ${src} as a variable FPS video. Disabling buffering while seeking.`);\n    isVariableFpsVideoMap.current[src] = true;\n  }, [logLevel, src]);\n  const rvcCurrentTime = useRequestVideoCallbackTime({\n    mediaRef,\n    mediaType,\n    lastSeek,\n    onVariableFpsVideoDetected\n  });\n  const mediaTagCurrentTime = useCurrentTimeOfMediaTagWithUpdateTimeStamp(mediaRef);\n  const desiredUnclampedTime = getMediaTime({\n    frame,\n    playbackRate: localPlaybackRate,\n    startFrom: -mediaStartsAt,\n    fps\n  });\n  const isMediaTagBuffering = useMediaBuffering({\n    element: mediaRef,\n    shouldBuffer: pauseWhenBuffering,\n    isPremounting,\n    isPostmounting,\n    logLevel,\n    mountTime,\n    src: src ?? null\n  });\n  const { bufferUntilFirstFrame, isBuffering } = useBufferUntilFirstFrame({\n    mediaRef,\n    mediaType,\n    onVariableFpsVideoDetected,\n    pauseWhenBuffering,\n    logLevel,\n    mountTime\n  });\n  const playbackRate = localPlaybackRate * globalPlaybackRate;\n  const acceptableTimeShiftButLessThanDuration = (() => {\n    const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK = 0.45;\n    const DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_NORMAL_PLAYBACK + 0.2;\n    const defaultAcceptableTimeshift = DEFAULT_ACCEPTABLE_TIMESHIFT_WITH_AMPLIFICATION;\n    if (mediaRef.current?.duration) {\n      return Math.min(mediaRef.current.duration, acceptableTimeshift ?? defaultAcceptableTimeshift);\n    }\n    return acceptableTimeshift ?? defaultAcceptableTimeshift;\n  })();\n  const isPlayerBuffering = useIsPlayerBuffering(buffering);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (mediaRef.current?.paused) {\n      return;\n    }\n    if (!playing) {\n      playbackLogging({\n        logLevel,\n        tag: \"pause\",\n        message: `Pausing ${mediaRef.current?.src} because ${isPremounting ? \"media is premounting\" : isPostmounting ? \"media is postmounting\" : \"Player is not playing\"}`,\n        mountTime\n      });\n      mediaRef.current?.pause();\n      return;\n    }\n    const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n    const playerBufferingNotStateButLive = buffering.buffering.current;\n    if (playerBufferingNotStateButLive && !isMediaTagBufferingOrStalled) {\n      playbackLogging({\n        logLevel,\n        tag: \"pause\",\n        message: `Pausing ${mediaRef.current?.src} because player is buffering but media tag is not`,\n        mountTime\n      });\n      mediaRef.current?.pause();\n    }\n  }, [\n    isBuffering,\n    isMediaTagBuffering,\n    buffering,\n    isPlayerBuffering,\n    isPremounting,\n    logLevel,\n    mediaRef,\n    mediaType,\n    mountTime,\n    playing,\n    isPostmounting\n  ]);\n  const env = useRemotionEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    const playbackRateToSet = Math.max(0, playbackRate);\n    if (mediaRef.current && mediaRef.current.playbackRate !== playbackRateToSet) {\n      mediaRef.current.playbackRate = playbackRateToSet;\n    }\n  }, [mediaRef, playbackRate]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const tagName = mediaType === \"audio\" ? \"<Html5Audio>\" : \"<Html5Video>\";\n    if (!mediaRef.current) {\n      throw new Error(`No ${mediaType} ref found`);\n    }\n    if (!src) {\n      throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n    }\n    const { duration } = mediaRef.current;\n    const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration) ? Math.min(duration, desiredUnclampedTime) : desiredUnclampedTime;\n    const mediaTagTime = mediaTagCurrentTime.current.time;\n    const rvcTime = rvcCurrentTime.current?.time ?? null;\n    const isVariableFpsVideo = isVariableFpsVideoMap.current[src];\n    const timeShiftMediaTag = Math.abs(shouldBeTime - mediaTagTime);\n    const timeShiftRvcTag = rvcTime ? Math.abs(shouldBeTime - rvcTime) : null;\n    const mostRecentTimeshift = rvcCurrentTime.current?.lastUpdate && rvcCurrentTime.current.time > mediaTagCurrentTime.current.lastUpdate ? timeShiftRvcTag : timeShiftMediaTag;\n    const timeShift = timeShiftRvcTag && !isVariableFpsVideo ? mostRecentTimeshift : timeShiftMediaTag;\n    if (timeShift > acceptableTimeShiftButLessThanDuration && lastSeekDueToShift.current !== shouldBeTime) {\n      lastSeek.current = seek({\n        mediaRef: mediaRef.current,\n        time: shouldBeTime,\n        logLevel,\n        why: `because time shift is too big. shouldBeTime = ${shouldBeTime}, isTime = ${mediaTagTime}, requestVideoCallbackTime = ${rvcTime}, timeShift = ${timeShift}${isVariableFpsVideo ? \", isVariableFpsVideo = true\" : \"\"}, isPremounting = ${isPremounting}, isPostmounting = ${isPostmounting}, pauseWhenBuffering = ${pauseWhenBuffering}`,\n        mountTime\n      });\n      lastSeekDueToShift.current = lastSeek.current;\n      if (playing) {\n        if (playbackRate > 0) {\n          bufferUntilFirstFrame(shouldBeTime);\n        }\n        if (mediaRef.current.paused) {\n          playAndHandleNotAllowedError({\n            mediaRef,\n            mediaType,\n            onAutoPlayError,\n            logLevel,\n            mountTime,\n            reason: \"player is playing but media tag is paused, and just seeked\",\n            isPlayer: env.isPlayer\n          });\n        }\n      }\n      if (!onlyWarnForMediaSeekingError) {\n        warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? \"console-warning\" : \"console-error\");\n      }\n      return;\n    }\n    const seekThreshold = playing ? 0.15 : 0.01;\n    const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > seekThreshold;\n    const isMediaTagBufferingOrStalled = isMediaTagBuffering || isBuffering();\n    const isSomethingElseBuffering = buffering.buffering.current && !isMediaTagBufferingOrStalled;\n    if (!playing || isSomethingElseBuffering) {\n      if (makesSenseToSeek) {\n        lastSeek.current = seek({\n          mediaRef: mediaRef.current,\n          time: shouldBeTime,\n          logLevel,\n          why: `not playing or something else is buffering. time offset is over seek threshold (${seekThreshold})`,\n          mountTime\n        });\n      }\n      return;\n    }\n    if (!playing || buffering.buffering.current) {\n      return;\n    }\n    const pausedCondition = mediaRef.current.paused && !mediaRef.current.ended;\n    const firstFrameCondition = absoluteFrame === 0;\n    if (pausedCondition || firstFrameCondition) {\n      const reason = pausedCondition ? \"media tag is paused\" : \"absolute frame is 0\";\n      if (makesSenseToSeek) {\n        lastSeek.current = seek({\n          mediaRef: mediaRef.current,\n          time: shouldBeTime,\n          logLevel,\n          why: `is over timeshift threshold (threshold = ${seekThreshold}) and ${reason}`,\n          mountTime\n        });\n      }\n      playAndHandleNotAllowedError({\n        mediaRef,\n        mediaType,\n        onAutoPlayError,\n        logLevel,\n        mountTime,\n        reason: `player is playing and ${reason}`,\n        isPlayer: env.isPlayer\n      });\n      if (!isVariableFpsVideo && playbackRate > 0) {\n        bufferUntilFirstFrame(shouldBeTime);\n      }\n    }\n  }, [\n    absoluteFrame,\n    acceptableTimeShiftButLessThanDuration,\n    bufferUntilFirstFrame,\n    buffering.buffering,\n    rvcCurrentTime,\n    logLevel,\n    desiredUnclampedTime,\n    isBuffering,\n    isMediaTagBuffering,\n    mediaRef,\n    mediaType,\n    onlyWarnForMediaSeekingError,\n    playbackRate,\n    playing,\n    src,\n    onAutoPlayError,\n    isPremounting,\n    isPostmounting,\n    pauseWhenBuffering,\n    mountTime,\n    mediaTagCurrentTime,\n    env.isPlayer\n  ]);\n};\n\n// src/use-media-tag.ts\n\nvar useMediaTag = ({\n  mediaRef,\n  id,\n  mediaType,\n  onAutoPlayError,\n  isPremounting,\n  isPostmounting\n}) => {\n  const { audioAndVideoTags, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  const env = useRemotionEnvironment();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const tag = {\n      id,\n      play: (reason) => {\n        if (!imperativePlaying.current) {\n          return;\n        }\n        if (isPremounting || isPostmounting) {\n          return;\n        }\n        return playAndHandleNotAllowedError({\n          mediaRef,\n          mediaType,\n          onAutoPlayError,\n          logLevel,\n          mountTime,\n          reason,\n          isPlayer: env.isPlayer\n        });\n      }\n    };\n    audioAndVideoTags.current.push(tag);\n    return () => {\n      audioAndVideoTags.current = audioAndVideoTags.current.filter((a) => a.id !== id);\n    };\n  }, [\n    audioAndVideoTags,\n    id,\n    mediaRef,\n    mediaType,\n    onAutoPlayError,\n    imperativePlaying,\n    isPremounting,\n    isPostmounting,\n    logLevel,\n    mountTime,\n    env.isPlayer\n  ]);\n};\n\n// src/volume-position-state.ts\n\nvar MediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  mediaMuted: false,\n  mediaVolume: 1\n});\nvar SetMediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  setMediaMuted: () => {\n    throw new Error(\"default\");\n  },\n  setMediaVolume: () => {\n    throw new Error(\"default\");\n  }\n});\nvar useMediaVolumeState = () => {\n  const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n  const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [mediaVolume, setMediaVolume];\n  }, [mediaVolume, setMediaVolume]);\n};\nvar useMediaMutedState = () => {\n  const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n  const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [mediaMuted, setMediaMuted];\n  }, [mediaMuted, setMediaMuted]);\n};\n\n// src/volume-safeguard.ts\nvar warnAboutTooHighVolume = (volume) => {\n  if (volume >= 100) {\n    throw new Error(`Volume was set to ${volume}, but regular volume is 1, not 100. Did you forget to divide by 100? Set a volume of less than 100 to dismiss this error.`);\n  }\n};\n\n// src/audio/AudioForPreview.tsx\n\nvar AudioForDevelopmentForwardRefFunction = (props, ref) => {\n  const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n  if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n    throw new Error(\"Cannot change the behavior for pre-mounting audio tags dynamically.\");\n  }\n  const logLevel = useLogLevel();\n  const {\n    volume,\n    muted,\n    playbackRate,\n    shouldPreMountAudioTags,\n    src,\n    onDuration,\n    acceptableTimeShiftInSeconds,\n    _remotionInternalNeedsDurationCalculation,\n    _remotionInternalNativeLoopPassed,\n    _remotionInternalStack,\n    allowAmplificationDuringRender,\n    name,\n    pauseWhenBuffering,\n    showInTimeline,\n    loopVolumeCurveBehavior,\n    stack,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    toneFrequency,\n    useWebAudioApi,\n    onError,\n    onNativeError,\n    audioStreamIndex,\n    ...nativeProps\n  } = props;\n  const _propsValid = true;\n  if (!_propsValid) {\n    throw new Error(\"typecheck error\");\n  }\n  const [mediaVolume] = useMediaVolumeState();\n  const [mediaMuted] = useMediaMutedState();\n  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n  if (!src) {\n    throw new TypeError(\"No 'src' was passed to <Html5Audio>.\");\n  }\n  const preloadedSrc = usePreload(src);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n  const isSequenceHidden = hidden[timelineId] ?? false;\n  const userPreferredVolume = evaluateVolume({\n    frame: volumePropFrame,\n    volume,\n    mediaVolume\n  });\n  warnAboutTooHighVolume(userPreferredVolume);\n  const crossOriginValue = getCrossOriginValue({\n    crossOrigin,\n    requestsVideoFrame: false\n  });\n  const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n      src: preloadedSrc,\n      loop: _remotionInternalNativeLoopPassed,\n      crossOrigin: crossOriginValue,\n      ...nativeProps\n    };\n  }, [\n    _remotionInternalNativeLoopPassed,\n    isSequenceHidden,\n    mediaMuted,\n    muted,\n    nativeProps,\n    preloadedSrc,\n    userPreferredVolume,\n    crossOriginValue\n  ]);\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [\n    src,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.durationInFrames,\n    props.muted,\n    props.loop\n  ]);\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  if (!context) {\n    throw new Error(\"SharedAudioContext not found\");\n  }\n  const { el: audioRef, mediaElementSourceNode } = useSharedAudio({\n    aud: propsToPass,\n    audioId: id,\n    premounting: Boolean(sequenceContext?.premounting)\n  });\n  useMediaInTimeline({\n    volume,\n    mediaVolume,\n    src,\n    mediaType: \"audio\",\n    playbackRate: playbackRate ?? 1,\n    displayName: name ?? null,\n    id: timelineId,\n    stack: _remotionInternalStack,\n    showInTimeline,\n    premountDisplay: sequenceContext?.premountDisplay ?? null,\n    postmountDisplay: sequenceContext?.postmountDisplay ?? null,\n    loopDisplay: undefined\n  });\n  useMediaPlayback({\n    mediaRef: audioRef,\n    src,\n    mediaType: \"audio\",\n    playbackRate: playbackRate ?? 1,\n    onlyWarnForMediaSeekingError: false,\n    acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n    isPremounting: Boolean(sequenceContext?.premounting),\n    isPostmounting: Boolean(sequenceContext?.postmounting),\n    pauseWhenBuffering,\n    onAutoPlayError: null\n  });\n  useMediaTag({\n    id: timelineId,\n    isPostmounting: Boolean(sequenceContext?.postmounting),\n    isPremounting: Boolean(sequenceContext?.premounting),\n    mediaRef: audioRef,\n    mediaType: \"audio\",\n    onAutoPlayError: null\n  });\n  useVolume({\n    logLevel,\n    mediaRef: audioRef,\n    source: mediaElementSourceNode,\n    volume: userPreferredVolume,\n    shouldUseWebAudioApi: useWebAudioApi ?? false\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return audioRef.current;\n  }, [audioRef]);\n  const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n  currentOnDurationCallback.current = onDuration;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = audioRef;\n    if (!current) {\n      return;\n    }\n    if (current.duration) {\n      currentOnDurationCallback.current?.(current.src, current.duration);\n      return;\n    }\n    const onLoadedMetadata = () => {\n      currentOnDurationCallback.current?.(current.src, current.duration);\n    };\n    current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    return () => {\n      current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n    };\n  }, [audioRef, src]);\n  if (initialShouldPreMountAudioElements) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n    ref: audioRef,\n    preload: \"metadata\",\n    crossOrigin: crossOriginValue,\n    ...propsToPass\n  });\n};\nvar AudioForPreview = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n\n// src/audio/AudioForRendering.tsx\n\n\nvar AudioForRenderingRefForwardingFunction = (props, ref) => {\n  const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const {\n    volume: volumeProp,\n    playbackRate,\n    allowAmplificationDuringRender,\n    onDuration,\n    toneFrequency,\n    _remotionInternalNeedsDurationCalculation,\n    _remotionInternalNativeLoopPassed,\n    acceptableTimeShiftInSeconds,\n    name,\n    onNativeError,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    loopVolumeCurveBehavior,\n    pauseWhenBuffering,\n    audioStreamIndex,\n    ...nativeProps\n  } = props;\n  const absoluteFrame = useTimelinePosition();\n  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const frame = useCurrentFrame();\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(props.src ?? \"\")}-${sequenceContext?.relativeFrom}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.durationInFrames}`, [\n    props.src,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.durationInFrames\n  ]);\n  const volume = evaluateVolume({\n    volume: volumeProp,\n    frame: volumePropFrame,\n    mediaVolume: 1\n  });\n  warnAboutTooHighVolume(volume);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return audioRef.current;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!props.src) {\n      throw new Error(\"No src passed\");\n    }\n    if (!window.remotion_audioEnabled) {\n      return;\n    }\n    if (props.muted) {\n      return;\n    }\n    if (volume <= 0) {\n      return;\n    }\n    registerRenderAsset({\n      type: \"audio\",\n      src: getAbsoluteSrc(props.src),\n      id,\n      frame: absoluteFrame,\n      volume,\n      mediaFrame: frame,\n      playbackRate: props.playbackRate ?? 1,\n      toneFrequency: toneFrequency ?? 1,\n      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n      audioStreamIndex: audioStreamIndex ?? 0\n    });\n    return () => unregisterRenderAsset(id);\n  }, [\n    props.muted,\n    props.src,\n    registerRenderAsset,\n    absoluteFrame,\n    id,\n    unregisterRenderAsset,\n    volume,\n    volumePropFrame,\n    frame,\n    playbackRate,\n    props.playbackRate,\n    toneFrequency,\n    sequenceContext?.relativeFrom,\n    audioStreamIndex\n  ]);\n  const { src } = props;\n  const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (window.process?.env?.NODE_ENV === \"test\") {\n      return;\n    }\n    if (!needsToRenderAudioTag) {\n      return;\n    }\n    const newHandle = delayRender2(\"Loading <Html5Audio> duration with src=\" + src, {\n      retries: delayRenderRetries ?? undefined,\n      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n    });\n    const { current } = audioRef;\n    const didLoad = () => {\n      if (current?.duration) {\n        onDuration(current.src, current.duration);\n      }\n      continueRender2(newHandle);\n    };\n    if (current?.duration) {\n      onDuration(current.src, current.duration);\n      continueRender2(newHandle);\n    } else {\n      current?.addEventListener(\"loadedmetadata\", didLoad, { once: true });\n    }\n    return () => {\n      current?.removeEventListener(\"loadedmetadata\", didLoad);\n      continueRender2(newHandle);\n    };\n  }, [\n    src,\n    onDuration,\n    needsToRenderAudioTag,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    continueRender2,\n    delayRender2\n  ]);\n  if (!needsToRenderAudioTag) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", {\n    ref: audioRef,\n    ...nativeProps,\n    onError: onNativeError\n  });\n};\nvar AudioForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n\n// src/audio/Audio.tsx\n\nvar AudioRefForwardingFunction = (props, ref) => {\n  const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  const {\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter,\n    name,\n    stack,\n    pauseWhenBuffering,\n    showInTimeline,\n    onError: onRemotionError,\n    ...otherProps\n  } = props;\n  const { loop, ...propsOtherThanLoop } = props;\n  const { fps } = useVideoConfig();\n  const environment = useRemotionEnvironment();\n  const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n  if (typeof props.src !== \"string\") {\n    throw new TypeError(`The \\`<Html5Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n  }\n  const preloadedSrc = usePreload(props.src);\n  const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    console.log(e.currentTarget.error);\n    const errMessage = `Could not play audio with src ${preloadedSrc}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n    if (loop) {\n      if (onRemotionError) {\n        onRemotionError(new Error(errMessage));\n        return;\n      }\n      cancelRender(new Error(errMessage));\n    } else {\n      onRemotionError?.(new Error(errMessage));\n      console.warn(errMessage);\n    }\n  }, [loop, onRemotionError, preloadedSrc]);\n  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {\n    setDurations({ type: \"got-duration\", durationInSeconds, src });\n  }, [setDurations]);\n  const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props.src)];\n  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });\n  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter\n  });\n  if (loop && durationFetched !== undefined) {\n    if (!Number.isFinite(durationFetched)) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      });\n    }\n    const duration = durationFetched * fps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n      layout: \"none\",\n      durationInFrames: calculateMediaDuration({\n        trimAfter: trimAfterValue,\n        mediaDurationInFrames: duration,\n        playbackRate: props.playbackRate ?? 1,\n        trimBefore: trimBeforeValue\n      }),\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      })\n    });\n  }\n  if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      layout: \"none\",\n      from: 0 - (trimBeforeValue ?? 0),\n      showInTimeline: false,\n      durationInFrames: trimAfterValue,\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Audio, {\n        _remotionInternalNeedsDurationCalculation: Boolean(loop),\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        ...otherProps,\n        ref\n      })\n    });\n  }\n  validateMediaProps({ playbackRate: props.playbackRate, volume: props.volume }, \"Html5Audio\");\n  if (environment.isRendering) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, {\n      onDuration,\n      ...props,\n      ref,\n      onNativeError: onError,\n      _remotionInternalNeedsDurationCalculation: Boolean(loop)\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForPreview, {\n    _remotionInternalNativeLoopPassed: props._remotionInternalNativeLoopPassed ?? false,\n    _remotionInternalStack: stack ?? null,\n    shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0,\n    ...props,\n    ref,\n    onNativeError: onError,\n    onDuration,\n    pauseWhenBuffering: pauseWhenBuffering ?? false,\n    _remotionInternalNeedsDurationCalculation: Boolean(loop),\n    showInTimeline: showInTimeline ?? true\n  });\n};\nvar Html5Audio = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\naddSequenceStackTraces(Html5Audio);\nvar Audio = Html5Audio;\n// src/Composition.tsx\n\n\n\n// src/Folder.tsx\n\n\n// src/validation/validate-folder-name.ts\nvar getRegex = () => /^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isFolderNameValid = (name) => name.match(getRegex());\nvar validateFolderName = (name) => {\n  if (name === undefined || name === null) {\n    throw new TypeError(\"You must pass a name to a <Folder />.\");\n  }\n  if (typeof name !== \"string\") {\n    throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n  }\n  if (!isFolderNameValid(name)) {\n    throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n  }\n};\nvar invalidFolderNameErrorMessage = `Folder name must match ${String(getRegex())}`;\n\n// src/Folder.tsx\n\nvar FolderContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  folderName: null,\n  parentName: null\n});\nvar Folder = ({ name, children }) => {\n  const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n  const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n  validateFolderName(name);\n  const parentNameArr = [parent.parentName, parent.folderName].filter(truthy);\n  const parentName = parentNameArr.length === 0 ? null : parentNameArr.join(\"/\");\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      folderName: name,\n      parentName\n    };\n  }, [name, parentName]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    registerFolder(name, parentName);\n    return () => {\n      unregisterFolder(name, parentName);\n    };\n  }, [name, parent.folderName, parentName, registerFolder, unregisterFolder]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, {\n    value,\n    children\n  });\n};\n\n// src/loading-indicator.tsx\n\nvar rotate = {\n  transform: `rotate(90deg)`\n};\nvar ICON_SIZE = 40;\nvar label = {\n  color: \"white\",\n  fontSize: 14,\n  fontFamily: \"sans-serif\"\n};\nvar container = {\n  justifyContent: \"center\",\n  alignItems: \"center\"\n};\nvar Loading = () => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, {\n    style: container,\n    id: \"remotion-comp-loading\",\n    children: [\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", {\n        type: \"text/css\",\n        children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t`\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", {\n        width: ICON_SIZE,\n        height: ICON_SIZE,\n        viewBox: \"-100 -100 400 400\",\n        style: rotate,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n          fill: \"#555\",\n          stroke: \"#555\",\n          strokeWidth: \"100\",\n          strokeLinejoin: \"round\",\n          d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\"\n        })\n      }),\n      /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", {\n        style: label,\n        children: [\n          \"Resolving \",\n          \"<Suspense>\",\n          \"...\"\n        ]\n      })\n    ]\n  });\n};\n\n// src/portal-node.ts\nvar _portalNode = null;\nvar portalNode = () => {\n  if (!_portalNode) {\n    if (typeof document === \"undefined\") {\n      throw new Error(\"Tried to call an API that only works in the browser from outside the browser\");\n    }\n    _portalNode = document.createElement(\"div\");\n    _portalNode.style.position = \"absolute\";\n    _portalNode.style.top = \"0px\";\n    _portalNode.style.left = \"0px\";\n    _portalNode.style.right = \"0px\";\n    _portalNode.style.bottom = \"0px\";\n    _portalNode.style.width = \"100%\";\n    _portalNode.style.height = \"100%\";\n    _portalNode.style.display = \"flex\";\n    _portalNode.style.flexDirection = \"column\";\n    const containerNode = document.createElement(\"div\");\n    containerNode.style.position = \"fixed\";\n    containerNode.style.top = -999999 + \"px\";\n    containerNode.appendChild(_portalNode);\n    document.body.appendChild(containerNode);\n  }\n  return _portalNode;\n};\n\n// src/use-lazy-component.ts\n\nvar useLazyComponent = ({\n  compProps,\n  componentName,\n  noSuspense\n}) => {\n  const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (\"component\" in compProps) {\n      if (typeof document === \"undefined\" || noSuspense) {\n        return compProps.component;\n      }\n      if (typeof compProps.component === \"undefined\") {\n        throw new Error(`A value of \\`undefined\\` was passed to the \\`component\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n      }\n      return compProps.component;\n    }\n    if (\"lazyComponent\" in compProps && typeof compProps.lazyComponent !== \"undefined\") {\n      if (typeof compProps.lazyComponent === \"undefined\") {\n        throw new Error(`A value of \\`undefined\\` was passed to the \\`lazyComponent\\` prop. Check the value you are passing to the <${componentName}/> component.`);\n      }\n      return react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n    }\n    throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n  }, [compProps.component, compProps.lazyComponent]);\n  return lazy;\n};\n\n// src/validation/validate-composition-id.ts\nvar getRegex2 = () => /^([a-zA-Z0-9-\\u4E00-\\u9FFF])+$/g;\nvar isCompositionIdValid = (id) => id.match(getRegex2());\nvar validateCompositionId = (id) => {\n  if (!isCompositionIdValid(id)) {\n    throw new Error(`Composition id can only contain a-z, A-Z, 0-9, CJK characters and -. You passed ${id}`);\n  }\n};\nvar invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex2())}`;\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/Composition.tsx\n\nvar Fallback = () => {\n  const { continueRender: continueRender2, delayRender: delayRender2 } = useDelayRender();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const fallback = delayRender2(\"Waiting for Root component to unsuspend\");\n    return () => continueRender2(fallback);\n  }, [continueRender2, delayRender2]);\n  return null;\n};\nvar InnerComposition = ({\n  width,\n  height,\n  fps,\n  durationInFrames,\n  id,\n  defaultProps,\n  schema,\n  ...compProps\n}) => {\n  const compManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n  const { registerComposition, unregisterComposition } = compManager;\n  const video = useVideo();\n  const lazy = useLazyComponent({\n    compProps,\n    componentName: \"Composition\",\n    noSuspense: false\n  });\n  const nonce = useNonce();\n  const isPlayer = useIsPlayer();\n  const environment = useRemotionEnvironment();\n  const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n  if (typeof window !== \"undefined\") {\n    window.remotion_seenCompositionIds = Array.from(new Set([...window.remotion_seenCompositionIds ?? [], id]));\n  }\n  if (canUseComposition) {\n    if (isPlayer) {\n      throw new Error(\"<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n    }\n    throw new Error(\"<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.\");\n  }\n  const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!id) {\n      throw new Error(\"No id for composition passed.\");\n    }\n    validateCompositionId(id);\n    validateDefaultAndInputProps(defaultProps, \"defaultProps\", id);\n    registerComposition({\n      durationInFrames: durationInFrames ?? undefined,\n      fps: fps ?? undefined,\n      height: height ?? undefined,\n      width: width ?? undefined,\n      id,\n      folderName,\n      component: lazy,\n      defaultProps: serializeThenDeserializeInStudio(defaultProps ?? {}),\n      nonce,\n      parentFolderName: parentName,\n      schema: schema ?? null,\n      calculateMetadata: compProps.calculateMetadata ?? null\n    });\n    return () => {\n      unregisterComposition(id);\n    };\n  }, [\n    durationInFrames,\n    fps,\n    height,\n    lazy,\n    id,\n    folderName,\n    defaultProps,\n    width,\n    nonce,\n    parentName,\n    schema,\n    compProps.calculateMetadata,\n    registerComposition,\n    unregisterComposition\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    window.dispatchEvent(new CustomEvent(PROPS_UPDATED_EXTERNALLY, {\n      detail: {\n        resetUnsaved: id\n      }\n    }));\n  }, [defaultProps, id]);\n  const resolved = useResolvedVideoConfig(id);\n  if (environment.isStudio && video && video.component === lazy) {\n    const Comp = lazy;\n    if (resolved === null || resolved.type !== \"success\" && resolved.type !== \"success-and-refreshing\") {\n      return null;\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n          ...resolved.result.props ?? {}\n        })\n      })\n    }), portalNode());\n  }\n  if (environment.isRendering && video && video.component === lazy) {\n    const Comp = lazy;\n    if (resolved === null || resolved.type !== \"success\" && resolved.type !== \"success-and-refreshing\") {\n      return null;\n    }\n    return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(/* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, {\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n        fallback: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}),\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, {\n          ...resolved.result.props ?? {}\n        })\n      })\n    }), portalNode());\n  }\n  return null;\n};\nvar Composition = (props2) => {\n  const { onlyRenderComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionSetters);\n  if (onlyRenderComposition && onlyRenderComposition !== props2.id) {\n    return null;\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerComposition, {\n    ...props2\n  });\n};\n// src/bezier.ts\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1 / (kSplineTableSize - 1);\nvar float32ArraySupported = typeof Float32Array === \"function\";\nfunction a(aA1, aA2) {\n  return 1 - 3 * aA2 + 3 * aA1;\n}\nfunction b(aA1, aA2) {\n  return 3 * aA2 - 6 * aA1;\n}\nfunction c(aA1) {\n  return 3 * aA1;\n}\nfunction calcBezier(aT, aA1, aA2) {\n  return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\nfunction getSlope(aT, aA1, aA2) {\n  return 3 * a(aA1, aA2) * aT * aT + 2 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({\n  aX,\n  _aA,\n  _aB,\n  mX1,\n  mX2\n}) {\n  let currentX;\n  let currentT;\n  let i = 0;\n  let aA = _aA;\n  let aB = _aB;\n  do {\n    currentT = aA + (aB - aA) / 2;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  let aGuessT = _aGuessT;\n  for (let i = 0;i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error(\"bezier x values must be in [0, 1] range\");\n  }\n  const sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (let i = 0;i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n  function getTForX(aX) {\n    let intervalStart = 0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n    for (;currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    }\n    if (initialSlope === 0) {\n      return guessForT;\n    }\n    return binarySubdivide({\n      aX,\n      _aA: intervalStart,\n      _aB: intervalStart + kSampleStepSize,\n      mX1,\n      mX2\n    });\n  }\n  return function(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x;\n    }\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n\n// src/easing.ts\nclass Easing {\n  static step0(n) {\n    return n > 0 ? 1 : 0;\n  }\n  static step1(n) {\n    return n >= 1 ? 1 : 0;\n  }\n  static linear(t) {\n    return t;\n  }\n  static ease(t) {\n    return Easing.bezier(0.42, 0, 1, 1)(t);\n  }\n  static quad(t) {\n    return t * t;\n  }\n  static cubic(t) {\n    return t * t * t;\n  }\n  static poly(n) {\n    return (t) => t ** n;\n  }\n  static sin(t) {\n    return 1 - Math.cos(t * Math.PI / 2);\n  }\n  static circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n  static exp(t) {\n    return 2 ** (10 * (t - 1));\n  }\n  static elastic(bounciness = 1) {\n    const p = bounciness * Math.PI;\n    return (t) => 1 - Math.cos(t * Math.PI / 2) ** 3 * Math.cos(t * p);\n  }\n  static back(s = 1.70158) {\n    return (t) => t * t * ((s + 1) * t - s);\n  }\n  static bounce(t) {\n    if (t < 1 / 2.75) {\n      return 7.5625 * t * t;\n    }\n    if (t < 2 / 2.75) {\n      const t2_ = t - 1.5 / 2.75;\n      return 7.5625 * t2_ * t2_ + 0.75;\n    }\n    if (t < 2.5 / 2.75) {\n      const t2_ = t - 2.25 / 2.75;\n      return 7.5625 * t2_ * t2_ + 0.9375;\n    }\n    const t2 = t - 2.625 / 2.75;\n    return 7.5625 * t2 * t2 + 0.984375;\n  }\n  static bezier(x1, y1, x2, y2) {\n    return bezier(x1, y1, x2, y2);\n  }\n  static in(easing) {\n    return easing;\n  }\n  static out(easing) {\n    return (t) => 1 - easing(1 - t);\n  }\n  static inOut(easing) {\n    return (t) => {\n      if (t < 0.5) {\n        return easing(t * 2) / 2;\n      }\n      return 1 - easing((1 - t) * 2) / 2;\n    };\n  }\n}\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/get-static-files.ts\nvar warnedServer = false;\nvar warnedPlayer = false;\nvar warnServerOnce = () => {\n  if (warnedServer) {\n    return;\n  }\n  warnedServer = true;\n  console.warn(\"Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.\");\n};\nvar warnPlayerOnce = () => {\n  if (warnedPlayer) {\n    return;\n  }\n  warnedPlayer = true;\n  console.warn(\"Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.\");\n};\nvar getStaticFiles = () => {\n  if (ENABLE_V5_BREAKING_CHANGES) {\n    throw new Error(\"getStaticFiles() has moved into the `@remotion/studio` package. Update your imports.\");\n  }\n  if (typeof document === \"undefined\") {\n    warnServerOnce();\n    return [];\n  }\n  if (window.remotion_isPlayer) {\n    warnPlayerOnce();\n    return [];\n  }\n  return window.remotion_staticFiles;\n};\n// src/IFrame.tsx\n\n\nvar IFrameRefForwarding = ({\n  onLoad,\n  onError,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  ...props2\n}, ref) => {\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender2(`Loading <IFrame> with source ${props2.src}`, {\n    retries: delayRenderRetries ?? undefined,\n    timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n  }));\n  const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    continueRender2(handle);\n    onLoad?.(e);\n  }, [handle, onLoad, continueRender2]);\n  const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    continueRender2(handle);\n    if (onError) {\n      onError(e);\n    } else {\n      console.error(\"Error loading iframe:\", e, \"Handle the event using the onError() prop to make this message disappear.\");\n    }\n  }, [handle, onError, continueRender2]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", {\n    ...props2,\n    ref,\n    onError: didGetError,\n    onLoad: didLoad\n  });\n};\nvar IFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n// src/Img.tsx\n\n\nfunction exponentialBackoff(errorCount) {\n  return 1000 * 2 ** (errorCount - 1);\n}\nvar ImgRefForwarding = ({\n  onError,\n  maxRetries = 2,\n  src,\n  pauseWhenLoading,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  onImageFrame,\n  crossOrigin,\n  ...props2\n}, ref) => {\n  const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n  const { delayPlayback } = useBufferState();\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  if (!src) {\n    throw new Error('No \"src\" prop was passed to <Img>.');\n  }\n  const _propsValid = true;\n  if (!_propsValid) {\n    throw new Error(\"typecheck error\");\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return imageRef.current;\n  }, []);\n  const actualSrc = usePreload(src);\n  const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout) => {\n    if (!imageRef.current) {\n      return;\n    }\n    const currentSrc = imageRef.current.src;\n    setTimeout(() => {\n      if (!imageRef.current) {\n        return;\n      }\n      const newSrc = imageRef.current?.src;\n      if (newSrc !== currentSrc) {\n        return;\n      }\n      imageRef.current.removeAttribute(\"src\");\n      imageRef.current.setAttribute(\"src\", newSrc);\n    }, timeout);\n  }, []);\n  const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n    if (!errors.current) {\n      return;\n    }\n    errors.current[imageRef.current?.src] = (errors.current[imageRef.current?.src] ?? 0) + 1;\n    if (onError && (errors.current[imageRef.current?.src] ?? 0) > maxRetries) {\n      onError(e);\n      return;\n    }\n    if ((errors.current[imageRef.current?.src] ?? 0) <= maxRetries) {\n      const backoff = exponentialBackoff(errors.current[imageRef.current?.src] ?? 0);\n      console.warn(`Could not load image with source ${imageRef.current?.src}, retrying again in ${backoff}ms`);\n      retryIn(backoff);\n      return;\n    }\n    cancelRender(\"Error loading image with src: \" + imageRef.current?.src);\n  }, [maxRetries, onError, retryIn]);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  if (typeof window !== \"undefined\") {\n    const isPremounting = Boolean(sequenceContext?.premounting);\n    const isPostmounting = Boolean(sequenceContext?.postmounting);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (window.process?.env?.NODE_ENV === \"test\") {\n        if (imageRef.current) {\n          imageRef.current.src = actualSrc;\n        }\n        return;\n      }\n      const { current } = imageRef;\n      if (!current) {\n        return;\n      }\n      const newHandle = delayRender2(\"Loading <Img> with src=\" + actualSrc, {\n        retries: delayRenderRetries ?? undefined,\n        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n      });\n      const unblock = pauseWhenLoading && !isPremounting && !isPostmounting ? delayPlayback().unblock : () => {\n        return;\n      };\n      let unmounted = false;\n      const onComplete = () => {\n        if (unmounted) {\n          continueRender2(newHandle);\n          return;\n        }\n        if ((errors.current[imageRef.current?.src] ?? 0) > 0) {\n          delete errors.current[imageRef.current?.src];\n          console.info(`Retry successful - ${imageRef.current?.src} is now loaded`);\n        }\n        if (current) {\n          onImageFrame?.(current);\n        }\n        unblock();\n        continueRender2(newHandle);\n      };\n      if (!imageRef.current) {\n        onComplete();\n        return;\n      }\n      current.src = actualSrc;\n      current.decode().then(onComplete).catch((err) => {\n        console.warn(err);\n        if (current.complete) {\n          onComplete();\n        } else {\n          current.addEventListener(\"load\", onComplete);\n        }\n      });\n      return () => {\n        unmounted = true;\n        current.removeEventListener(\"load\", onComplete);\n        unblock();\n        continueRender2(newHandle);\n      };\n    }, [\n      actualSrc,\n      delayPlayback,\n      delayRenderRetries,\n      delayRenderTimeoutInMilliseconds,\n      pauseWhenLoading,\n      isPremounting,\n      isPostmounting,\n      onImageFrame,\n      continueRender2,\n      delayRender2\n    ]);\n  }\n  const crossOriginValue = getCrossOriginValue({\n    crossOrigin,\n    requestsVideoFrame: false\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", {\n    ...props2,\n    ref: imageRef,\n    crossOrigin: crossOriginValue,\n    onError: didGetError,\n    decoding: \"sync\"\n  });\n};\nvar Img = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n// src/internals.ts\n\n\n// src/CompositionManager.tsx\n\n\nvar compositionsRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nvar CompositionManagerProvider = ({\n  children,\n  numberOfAudioTags,\n  onlyRenderComposition,\n  currentCompositionMetadata,\n  audioLatencyHint\n}) => {\n  const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n  const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((updateComps) => {\n    setCompositions((comps) => {\n      const updated = updateComps(comps);\n      currentcompositionsRef.current = updated;\n      return updated;\n    });\n  }, []);\n  const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp) => {\n    updateCompositions((comps) => {\n      if (comps.find((c2) => c2.id === comp.id)) {\n        throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n      }\n      const value = [...comps, comp].slice().sort((a2, b2) => a2.nonce - b2.nonce);\n      return value;\n    });\n  }, [updateCompositions]);\n  const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n    setCompositions((comps) => {\n      return comps.filter((c2) => c2.id !== id);\n    });\n  }, []);\n  const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {\n    setFolders((prevFolders) => {\n      return [\n        ...prevFolders,\n        {\n          name,\n          parent\n        }\n      ];\n    });\n  }, []);\n  const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {\n    setFolders((prevFolders) => {\n      return prevFolders.filter((p) => !(p.name === name && p.parent === parent));\n    });\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, () => {\n    return {\n      getCompositions: () => currentcompositionsRef.current\n    };\n  }, []);\n  const composition = compositions.find((c2) => canvasContent?.type === \"composition\" ? c2.id === canvasContent.compositionId : null);\n  const updateCompositionDefaultProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id, newDefaultProps) => {\n    setCompositions((comps) => {\n      const updated = comps.map((c2) => {\n        if (c2.id === id) {\n          return {\n            ...c2,\n            defaultProps: newDefaultProps\n          };\n        }\n        return c2;\n      });\n      return updated;\n    });\n  }, []);\n  const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      compositions,\n      folders,\n      currentCompositionMetadata,\n      canvasContent\n    };\n  }, [compositions, folders, currentCompositionMetadata, canvasContent]);\n  const setters = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      registerComposition,\n      unregisterComposition,\n      registerFolder,\n      unregisterFolder,\n      setCanvasContent,\n      updateCompositionDefaultProps,\n      onlyRenderComposition\n    };\n  }, [\n    registerComposition,\n    registerFolder,\n    unregisterComposition,\n    unregisterFolder,\n    updateCompositionDefaultProps,\n    onlyRenderComposition\n  ]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n    value: contextValue,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionSetters.Provider, {\n      value: setters,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, {\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, {\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, {\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, {\n              numberOfAudioTags,\n              component: composition?.component ?? null,\n              audioLatencyHint,\n              children\n            })\n          })\n        })\n      })\n    })\n  });\n};\n\n// src/default-css.ts\nvar exports_default_css = {};\n__export(exports_default_css, {\n  makeDefaultPreviewCSS: () => makeDefaultPreviewCSS,\n  injectCSS: () => injectCSS,\n  OBJECTFIT_CONTAIN_CLASS_NAME: () => OBJECTFIT_CONTAIN_CLASS_NAME\n});\nvar injected = {};\nvar injectCSS = (css) => {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n  if (injected[css]) {\n    return;\n  }\n  const head = document.head || document.getElementsByTagName(\"head\")[0];\n  const style = document.createElement(\"style\");\n  style.appendChild(document.createTextNode(css));\n  head.prepend(style);\n  injected[css] = true;\n};\nvar OBJECTFIT_CONTAIN_CLASS_NAME = \"__remotion_objectfitcontain\";\nvar makeDefaultPreviewCSS = (scope, backgroundColor) => {\n  if (!scope) {\n    return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OBJECTFIT_CONTAIN_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n  }\n  return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OBJECTFIT_CONTAIN_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n\n// src/get-preview-dom-element.ts\nvar REMOTION_STUDIO_CONTAINER_ELEMENT = \"__remotion-studio-container\";\nvar getPreviewDomElement = () => {\n  return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n\n// src/register-root.ts\nvar Root = null;\nvar listeners = [];\nvar registerRoot = (comp) => {\n  if (!comp) {\n    throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n  }\n  if (Root) {\n    throw new Error(\"registerRoot() was called more than once.\");\n  }\n  Root = comp;\n  listeners.forEach((l) => {\n    l(comp);\n  });\n};\nvar getRoot = () => {\n  return Root;\n};\nvar waitForRoot = (fn) => {\n  if (Root) {\n    fn(Root);\n    return () => {\n      return;\n    };\n  }\n  listeners.push(fn);\n  return () => {\n    listeners = listeners.filter((l) => l !== fn);\n  };\n};\n\n// src/RemotionRoot.tsx\n\n\n// src/use-media-enabled.tsx\n\n\nvar MediaEnabledContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nvar useVideoEnabled = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaEnabledContext);\n  if (!context) {\n    return window.remotion_videoEnabled;\n  }\n  if (context.videoEnabled === null) {\n    return window.remotion_videoEnabled;\n  }\n  return context.videoEnabled;\n};\nvar useAudioEnabled = () => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaEnabledContext);\n  if (!context) {\n    return window.remotion_audioEnabled;\n  }\n  if (context.audioEnabled === null) {\n    return window.remotion_audioEnabled;\n  }\n  return context.audioEnabled;\n};\nvar MediaEnabledProvider = ({\n  children,\n  videoEnabled,\n  audioEnabled\n}) => {\n  const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({ videoEnabled, audioEnabled }), [videoEnabled, audioEnabled]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MediaEnabledContext.Provider, {\n    value,\n    children\n  });\n};\n\n// src/RemotionRoot.tsx\n\nvar RemotionRoot = ({\n  children,\n  numberOfAudioTags,\n  logLevel,\n  onlyRenderComposition,\n  currentCompositionMetadata,\n  audioLatencyHint,\n  videoEnabled,\n  audioEnabled\n}) => {\n  const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(random(null)));\n  const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getInitialFrameState());\n  const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  const [manualRefreshes, setManualRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n  const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n  const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  if (typeof window !== \"undefined\") {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      window.remotion_setFrame = (f, composition, attempt) => {\n        window.remotion_attempt = attempt;\n        const id = delayRender2(`Setting the current frame to ${f}`);\n        let asyncUpdate = true;\n        setFrame((s) => {\n          const currentFrame = s[composition] ?? window.remotion_initialFrame;\n          if (currentFrame === f) {\n            asyncUpdate = false;\n            return s;\n          }\n          return {\n            ...s,\n            [composition]: f\n          };\n        });\n        if (asyncUpdate) {\n          requestAnimationFrame(() => continueRender2(id));\n        } else {\n          continueRender2(id);\n        }\n      };\n      window.remotion_isPlayer = false;\n    }, [continueRender2, delayRender2]);\n  }\n  const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      frame,\n      playing,\n      imperativePlaying,\n      rootId: remotionRootId,\n      playbackRate,\n      setPlaybackRate,\n      audioAndVideoTags\n    };\n  }, [frame, playbackRate, playing, remotionRootId]);\n  const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      setFrame,\n      setPlaying\n    };\n  }, []);\n  const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let counter = 0;\n    return {\n      getNonce: () => counter++,\n      fastRefreshes,\n      manualRefreshes\n    };\n  }, [fastRefreshes, manualRefreshes]);\n  const setNonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      increaseManualRefreshes: () => {\n        setManualRefreshes((i) => i + 1);\n      }\n    };\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (true) {\n      if (__webpack_module__.hot) {\n        __webpack_module__.hot.addStatusHandler((status) => {\n          if (status === \"idle\") {\n            setFastRefreshes((i) => i + 1);\n          }\n        });\n      }\n    }\n  }, []);\n  const logging = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return { logLevel, mountTime: Date.now() };\n  }, [logLevel]);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n    value: logging,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n      value: nonceContext,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetNonceContext.Provider, {\n        value: setNonceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n          value: timelineContextValue,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n            value: setTimelineContextValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MediaEnabledProvider, {\n              videoEnabled,\n              audioEnabled,\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, {\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, {\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, {\n                    numberOfAudioTags,\n                    onlyRenderComposition,\n                    currentCompositionMetadata,\n                    audioLatencyHint,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, {\n                      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingProvider, {\n                        children\n                      })\n                    })\n                  })\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n};\n\n// src/setup-env-variables.ts\nvar getEnvVariables = () => {\n  if (getRemotionEnvironment().isRendering) {\n    const param = window.remotion_envVariables;\n    if (!param) {\n      return {};\n    }\n    return { ...JSON.parse(param), NODE_ENV: \"production\" };\n  }\n  if (false) {}\n  return {\n    NODE_ENV: \"production\"\n  };\n};\nvar setupEnvVariables = () => {\n  const env = getEnvVariables();\n  if (!window.process) {\n    window.process = {};\n  }\n  if (!window.process.env) {\n    window.process.env = {};\n  }\n  Object.keys(env).forEach((key) => {\n    window.process.env[key] = env[key];\n  });\n};\n\n// src/use-current-scale.ts\n\nvar CurrentScaleContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar PreviewSizeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  setSize: () => {\n    return;\n  },\n  size: { size: \"auto\", translation: { x: 0, y: 0 } }\n});\nvar calculateScale = ({\n  canvasSize,\n  compositionHeight,\n  compositionWidth,\n  previewSize\n}) => {\n  const heightRatio = canvasSize.height / compositionHeight;\n  const widthRatio = canvasSize.width / compositionWidth;\n  const ratio = Math.min(heightRatio, widthRatio);\n  if (previewSize === \"auto\") {\n    if (ratio === 0) {\n      return 1;\n    }\n    return ratio;\n  }\n  return Number(previewSize);\n};\nvar useCurrentScale = (options) => {\n  const hasContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CurrentScaleContext);\n  const zoomContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreviewSizeContext);\n  const config = useUnsafeVideoConfig();\n  const env = useRemotionEnvironment();\n  if (hasContext === null || config === null || zoomContext === null) {\n    if (options?.dontThrowIfOutsideOfRemotion) {\n      return 1;\n    }\n    if (env.isRendering) {\n      return 1;\n    }\n    throw new Error([\n      \"useCurrentScale() was called outside of a Remotion context.\",\n      \"This hook can only be called in a component that is being rendered by Remotion.\",\n      \"If you want to this hook to return 1 outside of Remotion, pass {dontThrowIfOutsideOfRemotion: true} as an option.\",\n      \"If you think you called this hook in a Remotion component, make sure all versions of Remotion are aligned.\"\n    ].join(`\n`));\n  }\n  if (hasContext.type === \"scale\") {\n    return hasContext.scale;\n  }\n  return calculateScale({\n    canvasSize: hasContext.canvasSize,\n    compositionHeight: config.height,\n    compositionWidth: config.width,\n    previewSize: zoomContext.size.size\n  });\n};\n\n// src/video/OffthreadVideo.tsx\n\n\n// src/video/OffthreadVideoForRendering.tsx\n\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/video/OffthreadVideoForRendering.tsx\n\nvar OffthreadVideoForRendering = ({\n  onError,\n  volume: volumeProp,\n  playbackRate,\n  src,\n  muted,\n  allowAmplificationDuringRender,\n  transparent,\n  toneMapped,\n  toneFrequency,\n  name,\n  loopVolumeCurveBehavior,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  onVideoFrame,\n  crossOrigin,\n  audioStreamIndex,\n  ...props2\n}) => {\n  const absoluteFrame = useTimelinePosition();\n  const frame = useCurrentFrame();\n  const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior);\n  const videoConfig = useUnsafeVideoConfig();\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const mediaStartsAt = useMediaStartsAt();\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  if (!src) {\n    throw new TypeError(\"No `src` was passed to <OffthreadVideo>.\");\n  }\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `offthreadvideo-${random(src)}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n    src,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.durationInFrames\n  ]);\n  if (!videoConfig) {\n    throw new Error(\"No video config found\");\n  }\n  const volume = evaluateVolume({\n    volume: volumeProp,\n    frame: volumePropsFrame,\n    mediaVolume: 1\n  });\n  warnAboutTooHighVolume(volume);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!src) {\n      throw new Error(\"No src passed\");\n    }\n    if (!window.remotion_audioEnabled) {\n      return;\n    }\n    if (muted) {\n      return;\n    }\n    if (volume <= 0) {\n      return;\n    }\n    registerRenderAsset({\n      type: \"video\",\n      src: getAbsoluteSrc(src),\n      id,\n      frame: absoluteFrame,\n      volume,\n      mediaFrame: frame,\n      playbackRate,\n      toneFrequency,\n      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n      audioStreamIndex\n    });\n    return () => unregisterRenderAsset(id);\n  }, [\n    muted,\n    src,\n    registerRenderAsset,\n    id,\n    unregisterRenderAsset,\n    volume,\n    frame,\n    absoluteFrame,\n    playbackRate,\n    toneFrequency,\n    sequenceContext?.relativeFrom,\n    audioStreamIndex\n  ]);\n  const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return getExpectedMediaFrameUncorrected({\n      frame,\n      playbackRate: playbackRate || 1,\n      startFrom: -mediaStartsAt\n    }) / videoConfig.fps;\n  }, [frame, mediaStartsAt, playbackRate, videoConfig.fps]);\n  const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return getOffthreadVideoSource({\n      src,\n      currentTime,\n      transparent,\n      toneMapped\n    });\n  }, [toneMapped, currentTime, src, transparent]);\n  const [imageSrc, setImageSrc] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    if (!window.remotion_videoEnabled) {\n      return;\n    }\n    const cleanup = [];\n    setImageSrc(null);\n    const controller = new AbortController;\n    const newHandle = delayRender2(`Fetching ${actualSrc} from server`, {\n      retries: delayRenderRetries ?? undefined,\n      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n    });\n    const execute = async () => {\n      try {\n        const res = await fetch(actualSrc, {\n          signal: controller.signal,\n          cache: \"no-store\"\n        });\n        if (res.status !== 200) {\n          if (res.status === 500) {\n            const json = await res.json();\n            if (json.error) {\n              const cleanedUpErrorMessage = json.error.replace(/^Error: /, \"\");\n              throw new Error(cleanedUpErrorMessage);\n            }\n          }\n          throw new Error(`Server returned status ${res.status} while fetching ${actualSrc}`);\n        }\n        const blob = await res.blob();\n        const url = URL.createObjectURL(blob);\n        cleanup.push(() => URL.revokeObjectURL(url));\n        setImageSrc({\n          src: url,\n          handle: newHandle\n        });\n      } catch (err) {\n        if (err.message.includes(\"aborted\")) {\n          continueRender2(newHandle);\n          return;\n        }\n        if (controller.signal.aborted) {\n          continueRender2(newHandle);\n          return;\n        }\n        if (err.message.includes(\"Failed to fetch\")) {\n          err = new Error(`Failed to fetch ${actualSrc}. This could be caused by Chrome rejecting the request because the disk space is low. Consider increasing the disk size of your environment.`, { cause: err });\n        }\n        if (onError) {\n          onError(err);\n        } else {\n          cancelRender(err);\n        }\n      }\n    };\n    execute();\n    cleanup.push(() => {\n      if (controller.signal.aborted) {\n        return;\n      }\n      controller.abort();\n    });\n    return () => {\n      cleanup.forEach((c2) => c2());\n    };\n  }, [\n    actualSrc,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    onError,\n    continueRender2,\n    delayRender2\n  ]);\n  const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (onError) {\n      onError?.(new Error(\"Failed to load image with src \" + imageSrc));\n    } else {\n      cancelRender(\"Failed to load image with src \" + imageSrc);\n    }\n  }, [imageSrc, onError]);\n  const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return [OBJECTFIT_CONTAIN_CLASS_NAME, props2.className].filter(truthy).join(\" \");\n  }, [props2.className]);\n  const onImageFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((img) => {\n    if (onVideoFrame) {\n      onVideoFrame(img);\n    }\n  }, [onVideoFrame]);\n  if (!imageSrc || !window.remotion_videoEnabled) {\n    return null;\n  }\n  continueRender2(imageSrc.handle);\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, {\n    src: imageSrc.src,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    onImageFrame,\n    ...props2,\n    onError: onErr,\n    className\n  });\n};\n\n// src/video/VideoForPreview.tsx\n\n\n// src/video/emit-video-frame.ts\n\nvar useEmitVideoFrame = ({\n  ref,\n  onVideoFrame\n}) => {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = ref;\n    if (!current) {\n      return;\n    }\n    if (!onVideoFrame) {\n      return;\n    }\n    let handle = 0;\n    const callback = () => {\n      if (!ref.current) {\n        return;\n      }\n      onVideoFrame(ref.current);\n      handle = ref.current.requestVideoFrameCallback(callback);\n    };\n    callback();\n    return () => {\n      current.cancelVideoFrameCallback(handle);\n    };\n  }, [onVideoFrame, ref]);\n};\n\n// src/video/VideoForPreview.tsx\n\nvar VideoForDevelopmentRefForwardingFunction = (props2, ref) => {\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n  if (!context) {\n    throw new Error(\"SharedAudioContext not found\");\n  }\n  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const sharedSource = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    if (!context.audioContext) {\n      return null;\n    }\n    return makeSharedElementSourceNode({\n      audioContext: context.audioContext,\n      ref: videoRef\n    });\n  }, [context.audioContext]);\n  const {\n    volume,\n    muted,\n    playbackRate,\n    onlyWarnForMediaSeekingError,\n    src,\n    onDuration,\n    acceptableTimeShift,\n    acceptableTimeShiftInSeconds,\n    toneFrequency,\n    name,\n    _remotionInternalNativeLoopPassed,\n    _remotionInternalStack,\n    style,\n    pauseWhenBuffering,\n    showInTimeline,\n    loopVolumeCurveBehavior,\n    onError,\n    onAutoPlayError,\n    onVideoFrame,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    allowAmplificationDuringRender,\n    useWebAudioApi,\n    audioStreamIndex,\n    ...nativeProps\n  } = props2;\n  const _propsValid = true;\n  if (!_propsValid) {\n    throw new Error(\"typecheck error\");\n  }\n  const volumePropFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const { fps, durationInFrames } = useVideoConfig();\n  const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const { hidden } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceVisibilityToggleContext);\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  const [timelineId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n  const isSequenceHidden = hidden[timelineId] ?? false;\n  if (typeof acceptableTimeShift !== \"undefined\") {\n    throw new Error(\"acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.\");\n  }\n  const [mediaVolume] = useMediaVolumeState();\n  const [mediaMuted] = useMediaMutedState();\n  const userPreferredVolume = evaluateVolume({\n    frame: volumePropFrame,\n    volume,\n    mediaVolume\n  });\n  warnAboutTooHighVolume(userPreferredVolume);\n  useMediaInTimeline({\n    volume,\n    mediaVolume,\n    mediaType: \"video\",\n    src,\n    playbackRate: props2.playbackRate ?? 1,\n    displayName: name ?? null,\n    id: timelineId,\n    stack: _remotionInternalStack,\n    showInTimeline,\n    premountDisplay: parentSequence?.premountDisplay ?? null,\n    postmountDisplay: parentSequence?.postmountDisplay ?? null,\n    loopDisplay: undefined\n  });\n  useMediaPlayback({\n    mediaRef: videoRef,\n    src,\n    mediaType: \"video\",\n    playbackRate: props2.playbackRate ?? 1,\n    onlyWarnForMediaSeekingError,\n    acceptableTimeshift: acceptableTimeShiftInSeconds ?? null,\n    isPremounting: Boolean(parentSequence?.premounting),\n    isPostmounting: Boolean(parentSequence?.postmounting),\n    pauseWhenBuffering,\n    onAutoPlayError: onAutoPlayError ?? null\n  });\n  useMediaTag({\n    id: timelineId,\n    isPostmounting: Boolean(parentSequence?.postmounting),\n    isPremounting: Boolean(parentSequence?.premounting),\n    mediaRef: videoRef,\n    mediaType: \"video\",\n    onAutoPlayError: onAutoPlayError ?? null\n  });\n  useVolume({\n    logLevel,\n    mediaRef: videoRef,\n    volume: userPreferredVolume,\n    source: sharedSource,\n    shouldUseWebAudioApi: useWebAudioApi ?? false\n  });\n  const actualFrom = parentSequence ? parentSequence.relativeFrom : 0;\n  const duration = parentSequence ? Math.min(parentSequence.durationInFrames, durationInFrames) : durationInFrames;\n  const preloadedSrc = usePreload(src);\n  const actualSrc = useAppendVideoFragment({\n    actualSrc: preloadedSrc,\n    actualFrom,\n    duration,\n    fps\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return videoRef.current;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => playbackLogging({\n    logLevel,\n    message: `Mounting video with source = ${actualSrc}, v=${VERSION}, user agent=${typeof navigator === \"undefined\" ? \"server\" : navigator.userAgent}`,\n    tag: \"video\",\n    mountTime\n  }));\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    const errorHandler = () => {\n      if (current.error) {\n        console.error(\"Error occurred in video\", current?.error);\n        if (onError) {\n          const err = new Error(`Code ${current.error.code}: ${current.error.message}`);\n          onError(err);\n          return;\n        }\n        throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n      } else {\n        if (onError) {\n          const err = new Error(`The browser threw an error while playing the video ${src}`);\n          onError(err);\n          return;\n        }\n        throw new Error(\"The browser threw an error while playing the video\");\n      }\n    };\n    current.addEventListener(\"error\", errorHandler, { once: true });\n    return () => {\n      current.removeEventListener(\"error\", errorHandler);\n    };\n  }, [onError, src]);\n  const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onDuration);\n  currentOnDurationCallback.current = onDuration;\n  useEmitVideoFrame({ ref: videoRef, onVideoFrame });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    if (current.duration) {\n      currentOnDurationCallback.current?.(src, current.duration);\n      return;\n    }\n    const onLoadedMetadata = () => {\n      currentOnDurationCallback.current?.(src, current.duration);\n    };\n    current.addEventListener(\"loadedmetadata\", onLoadedMetadata);\n    return () => {\n      current.removeEventListener(\"loadedmetadata\", onLoadedMetadata);\n    };\n  }, [src]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    if (isIosSafari()) {\n      current.preload = \"metadata\";\n    } else {\n      current.preload = \"auto\";\n    }\n  }, []);\n  const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    return {\n      ...style,\n      opacity: isSequenceHidden ? 0 : style?.opacity ?? 1\n    };\n  }, [isSequenceHidden, style]);\n  const crossOriginValue = getCrossOriginValue({\n    crossOrigin,\n    requestsVideoFrame: Boolean(onVideoFrame)\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n    ref: videoRef,\n    muted: muted || mediaMuted || isSequenceHidden || userPreferredVolume <= 0,\n    playsInline: true,\n    src: actualSrc,\n    loop: _remotionInternalNativeLoopPassed,\n    style: actualStyle,\n    disableRemotePlayback: true,\n    crossOrigin: crossOriginValue,\n    ...nativeProps\n  });\n};\nvar VideoForPreview = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n\n// src/video/OffthreadVideo.tsx\n\nvar InnerOffthreadVideo = (props2) => {\n  const {\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter,\n    name,\n    pauseWhenBuffering,\n    stack,\n    showInTimeline,\n    ...otherProps\n  } = props2;\n  const environment = useRemotionEnvironment();\n  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    return;\n  }, []);\n  if (typeof props2.src !== \"string\") {\n    throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n  }\n  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });\n  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter\n  });\n  if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      layout: \"none\",\n      from: 0 - (trimBeforeValue ?? 0),\n      showInTimeline: false,\n      durationInFrames: trimAfterValue,\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerOffthreadVideo, {\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        ...otherProps,\n        trimAfter: undefined,\n        name: undefined,\n        showInTimeline,\n        trimBefore: undefined,\n        stack: undefined,\n        startFrom: undefined,\n        endAt: undefined\n      })\n    });\n  }\n  validateMediaProps(props2, \"Video\");\n  if (environment.isRendering) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, {\n      pauseWhenBuffering: pauseWhenBuffering ?? false,\n      ...otherProps,\n      trimAfter: undefined,\n      name: undefined,\n      showInTimeline,\n      trimBefore: undefined,\n      stack: undefined,\n      startFrom: undefined,\n      endAt: undefined\n    });\n  }\n  const {\n    transparent,\n    toneMapped,\n    onAutoPlayError,\n    onVideoFrame,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    ...propsForPreview\n  } = otherProps;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n    _remotionInternalStack: stack ?? null,\n    onDuration,\n    onlyWarnForMediaSeekingError: true,\n    pauseWhenBuffering: pauseWhenBuffering ?? false,\n    showInTimeline: showInTimeline ?? true,\n    onAutoPlayError: onAutoPlayError ?? undefined,\n    onVideoFrame: onVideoFrame ?? null,\n    crossOrigin,\n    ...propsForPreview,\n    _remotionInternalNativeLoopPassed: false\n  });\n};\nvar OffthreadVideo = ({\n  src,\n  acceptableTimeShiftInSeconds,\n  allowAmplificationDuringRender,\n  audioStreamIndex,\n  className,\n  crossOrigin,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  id,\n  loopVolumeCurveBehavior,\n  muted,\n  name,\n  onAutoPlayError,\n  onError,\n  onVideoFrame,\n  pauseWhenBuffering,\n  playbackRate,\n  showInTimeline,\n  style,\n  toneFrequency,\n  toneMapped,\n  transparent,\n  trimAfter,\n  trimBefore,\n  useWebAudioApi,\n  volume,\n  _remotionInternalNativeLoopPassed,\n  endAt,\n  stack,\n  startFrom,\n  imageFormat\n}) => {\n  if (imageFormat) {\n    throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InnerOffthreadVideo, {\n    acceptableTimeShiftInSeconds,\n    allowAmplificationDuringRender: allowAmplificationDuringRender ?? true,\n    audioStreamIndex: audioStreamIndex ?? 0,\n    className,\n    crossOrigin,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    id,\n    loopVolumeCurveBehavior: loopVolumeCurveBehavior ?? \"repeat\",\n    muted: muted ?? false,\n    name,\n    onAutoPlayError: onAutoPlayError ?? null,\n    onError,\n    onVideoFrame,\n    pauseWhenBuffering: pauseWhenBuffering ?? true,\n    playbackRate: playbackRate ?? 1,\n    toneFrequency: toneFrequency ?? 1,\n    showInTimeline: showInTimeline ?? true,\n    src,\n    stack,\n    startFrom,\n    _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n    endAt,\n    style,\n    toneMapped: toneMapped ?? true,\n    transparent: transparent ?? false,\n    trimAfter,\n    trimBefore,\n    useWebAudioApi: useWebAudioApi ?? false,\n    volume\n  });\n};\naddSequenceStackTraces(OffthreadVideo);\n\n// src/watch-static-file.ts\nvar WATCH_REMOTION_STATIC_FILES = \"remotion_staticFilesChanged\";\nvar watchStaticFile = (fileName, callback) => {\n  if (ENABLE_V5_BREAKING_CHANGES) {\n    throw new Error(\"watchStaticFile() has moved into the `@remotion/studio` package. Update your imports.\");\n  }\n  if (!getRemotionEnvironment().isStudio) {\n    console.warn(\"The watchStaticFile() API is only available while using the Remotion Studio.\");\n    return { cancel: () => {\n      return;\n    } };\n  }\n  const withoutStaticBase = fileName.startsWith(window.remotion_staticBase) ? fileName.replace(window.remotion_staticBase, \"\") : fileName;\n  const withoutLeadingSlash = withoutStaticBase.startsWith(\"/\") ? withoutStaticBase.slice(1) : withoutStaticBase;\n  let prevFileData = window.remotion_staticFiles.find((file) => file.name === withoutLeadingSlash);\n  const checkFile = (event) => {\n    const staticFiles = event.detail.files;\n    const newFileData = staticFiles.find((file) => file.name === withoutLeadingSlash);\n    if (!newFileData) {\n      if (prevFileData !== undefined) {\n        callback(null);\n      }\n      prevFileData = undefined;\n      return;\n    }\n    if (prevFileData === undefined || prevFileData.lastModified !== newFileData.lastModified) {\n      callback(newFileData);\n      prevFileData = newFileData;\n    }\n  };\n  window.addEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n  const cancel = () => {\n    return window.removeEventListener(WATCH_REMOTION_STATIC_FILES, checkFile);\n  };\n  return { cancel };\n};\n\n// src/wrap-remotion-context.tsx\n\n\nfunction useRemotionContexts() {\n  const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n  const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n  const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n  const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n  const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n  const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n  const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n  const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n  const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n  const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n  const bufferManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(BufferingContextReact);\n  const logLevelContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(LogLevelContext);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n    compositionManagerCtx,\n    timelineContext,\n    setTimelineContext,\n    sequenceContext,\n    nonceContext,\n    canUseRemotionHooksContext,\n    preloadContext,\n    resolveCompositionContext,\n    renderAssetManagerContext,\n    sequenceManagerContext,\n    bufferManagerContext,\n    logLevelContext\n  }), [\n    compositionManagerCtx,\n    nonceContext,\n    sequenceContext,\n    setTimelineContext,\n    timelineContext,\n    canUseRemotionHooksContext,\n    preloadContext,\n    resolveCompositionContext,\n    renderAssetManagerContext,\n    sequenceManagerContext,\n    bufferManagerContext,\n    logLevelContext\n  ]);\n}\nvar RemotionContextProvider = (props2) => {\n  const { children, contexts } = props2;\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(LogLevelContext.Provider, {\n    value: contexts.logLevelContext,\n    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, {\n      value: contexts.canUseRemotionHooksContext,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, {\n        value: contexts.nonceContext,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, {\n          value: contexts.preloadContext,\n          children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, {\n            value: contexts.compositionManagerCtx,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, {\n              value: contexts.sequenceManagerContext,\n              children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, {\n                value: contexts.renderAssetManagerContext,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, {\n                  value: contexts.resolveCompositionContext,\n                  children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, {\n                    value: contexts.timelineContext,\n                    children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, {\n                      value: contexts.setTimelineContext,\n                      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, {\n                        value: contexts.sequenceContext,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(BufferingContextReact.Provider, {\n                          value: contexts.bufferManagerContext,\n                          children\n                        })\n                      })\n                    })\n                  })\n                })\n              })\n            })\n          })\n        })\n      })\n    })\n  });\n};\n\n// src/internals.ts\nvar compositionSelectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nvar Internals = {\n  useUnsafeVideoConfig,\n  useFrameForVolumeProp,\n  useTimelinePosition,\n  evaluateVolume,\n  getAbsoluteSrc,\n  Timeline: exports_timeline_position_state,\n  validateMediaTrimProps,\n  validateMediaProps,\n  resolveTrimProps,\n  VideoForPreview,\n  CompositionManager,\n  CompositionSetters,\n  SequenceManager,\n  SequenceVisibilityToggleContext,\n  RemotionRoot,\n  useVideo,\n  getRoot,\n  useMediaVolumeState,\n  useMediaMutedState,\n  useMediaInTimeline,\n  useLazyComponent,\n  truthy,\n  SequenceContext,\n  useRemotionContexts,\n  RemotionContextProvider,\n  CSSUtils: exports_default_css,\n  setupEnvVariables,\n  MediaVolumeContext,\n  SetMediaVolumeContext,\n  getRemotionEnvironment,\n  SharedAudioContext,\n  SharedAudioContextProvider,\n  invalidCompositionErrorMessage,\n  calculateMediaDuration,\n  isCompositionIdValid,\n  getPreviewDomElement,\n  compositionsRef,\n  portalNode,\n  waitForRoot,\n  CanUseRemotionHooksProvider,\n  CanUseRemotionHooks,\n  PrefetchProvider,\n  DurationsContextProvider,\n  IsPlayerContextProvider,\n  useIsPlayer,\n  EditorPropsProvider,\n  EditorPropsContext,\n  usePreload,\n  NonceContext,\n  SetNonceContext,\n  resolveVideoConfig,\n  useResolvedVideoConfig,\n  resolveCompositionsRef,\n  ResolveCompositionConfig,\n  REMOTION_STUDIO_CONTAINER_ELEMENT,\n  RenderAssetManager,\n  persistCurrentFrame,\n  useTimelineSetFrame,\n  isIosSafari,\n  WATCH_REMOTION_STATIC_FILES,\n  addSequenceStackTraces,\n  useMediaStartsAt,\n  BufferingProvider,\n  BufferingContextReact,\n  enableSequenceStackTraces,\n  CurrentScaleContext,\n  PreviewSizeContext,\n  calculateScale,\n  editorPropsProviderRef,\n  PROPS_UPDATED_EXTERNALLY,\n  validateRenderAsset,\n  Log,\n  LogLevelContext,\n  useLogLevel,\n  playbackLogging,\n  timeValueRef,\n  compositionSelectorRef,\n  RemotionEnvironmentContext,\n  warnAboutTooHighVolume,\n  AudioForPreview,\n  OBJECTFIT_CONTAIN_CLASS_NAME,\n  InnerOffthreadVideo,\n  useBasicMediaInTimeline,\n  getInputPropsOverride,\n  setInputPropsOverride,\n  useVideoEnabled,\n  useAudioEnabled,\n  useIsPlayerBuffering\n};\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b2 = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b2 * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nvar opacity = (c2) => {\n  return (c2 >> 24 & 255) / 255;\n};\nvar red = (c2) => {\n  return c2 >> 16 & 255;\n};\nvar green = (c2) => {\n  return c2 >> 8 & 255;\n};\nvar blue = (c2) => {\n  return c2 & 255;\n};\nvar rgbaColor = (r, g, b2, alpha) => {\n  return `rgba(${r}, ${g}, ${b2}, ${alpha})`;\n};\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\nvar interpolateColorsRGB = (value, inputRange, colors) => {\n  const [r, g, b2, a2] = [red, green, blue, opacity].map((f) => {\n    const unrounded = interpolate(value, inputRange, colors.map((c2) => f(c2)), {\n      extrapolateLeft: \"clamp\",\n      extrapolateRight: \"clamp\"\n    });\n    if (f === opacity) {\n      return Number(unrounded.toFixed(3));\n    }\n    return Math.round(unrounded);\n  });\n  return rgbaColor(r, g, b2, a2);\n};\nvar interpolateColors = (input, inputRange, outputRange) => {\n  if (typeof input === \"undefined\") {\n    throw new TypeError(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new TypeError(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new TypeError(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new TypeError(\"inputRange (\" + inputRange.length + \" values provided) and outputRange (\" + outputRange.length + \" values provided) must have the same length\");\n  }\n  const processedOutputRange = outputRange.map((c2) => processColor(c2));\n  return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n// src/series/index.tsx\n\n\n// src/series/flatten-children.tsx\n\nvar flattenChildren = (children) => {\n  const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n  return childrenArray.reduce((flatChildren, child) => {\n    if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n      return flatChildren.concat(flattenChildren(child.props.children));\n    }\n    flatChildren.push(child);\n    return flatChildren;\n  }, []);\n};\n\n// src/series/is-inside-series.tsx\n\n\nvar IsInsideSeriesContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nvar IsInsideSeriesContainer = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n    value: true,\n    children\n  });\n};\nvar IsNotInsideSeriesProvider = ({ children }) => {\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContext.Provider, {\n    value: false,\n    children\n  });\n};\nvar useRequireToBeInsideSeries = () => {\n  const isInsideSeries = react__WEBPACK_IMPORTED_MODULE_0__.useContext(IsInsideSeriesContext);\n  if (!isInsideSeries) {\n    throw new Error(\"This component must be inside a <Series /> component.\");\n  }\n};\n\n// src/series/index.tsx\n\nvar SeriesSequenceRefForwardingFunction = ({ children }, _ref) => {\n  useRequireToBeInsideSeries();\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsNotInsideSeriesProvider, {\n    children\n  });\n};\nvar SeriesSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\nvar Series = (props2) => {\n  const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    let startFrame = 0;\n    const flattenedChildren = flattenChildren(props2.children);\n    return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i) => {\n      const castedChild = child;\n      if (typeof castedChild === \"string\") {\n        if (castedChild.trim() === \"\") {\n          return null;\n        }\n        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but you passed a string \"${castedChild}\"`);\n      }\n      if (castedChild.type !== SeriesSequence) {\n        throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as its children, but got ${castedChild} instead`);\n      }\n      const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n      if (!castedChild?.props.children) {\n        throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n      }\n      const durationInFramesProp = castedChild.props.durationInFrames;\n      const {\n        durationInFrames,\n        children: _children,\n        from,\n        name,\n        ...passedProps\n      } = castedChild.props;\n      if (i !== flattenedChildren.length - 1 || durationInFramesProp !== Infinity) {\n        validateDurationInFrames(durationInFramesProp, {\n          component: `of a <Series.Sequence /> component`,\n          allowFloats: true\n        });\n      }\n      const offset = castedChild.props.offset ?? 0;\n      if (Number.isNaN(offset)) {\n        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n      }\n      if (!Number.isFinite(offset)) {\n        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n      }\n      if (offset % 1 !== 0) {\n        throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n      }\n      const currentStartFrame = startFrame + offset;\n      startFrame += durationInFramesProp + offset;\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n        name: name || \"<Series.Sequence>\",\n        from: currentStartFrame,\n        durationInFrames: durationInFramesProp,\n        ...passedProps,\n        ref: castedChild.ref,\n        children: child\n      });\n    });\n  }, [props2.children]);\n  if (ENABLE_V5_BREAKING_CHANGES) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n        ...props2,\n        children: childrenValue\n      })\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsInsideSeriesContainer, {\n    children: childrenValue\n  });\n};\nSeries.Sequence = SeriesSequence;\naddSequenceStackTraces(SeriesSequence);\n// src/validation/validation-spring-duration.ts\nvar validateSpringDuration = (dur) => {\n  if (typeof dur === \"undefined\") {\n    return;\n  }\n  if (typeof dur !== \"number\") {\n    throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n  }\n  if (Number.isNaN(dur)) {\n    throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n  }\n  if (!Number.isFinite(dur)) {\n    throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n  }\n  if (dur <= 0) {\n    throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n  }\n};\n\n// src/spring/spring-utils.ts\nvar defaultSpringConfig = {\n  damping: 10,\n  mass: 1,\n  stiffness: 100,\n  overshootClamping: false\n};\nvar advanceCache = {};\nfunction advance({\n  animation,\n  now,\n  config\n}) {\n  const { toValue, lastTimestamp, current, velocity } = animation;\n  const deltaTime = Math.min(now - lastTimestamp, 64);\n  if (config.damping <= 0) {\n    throw new Error(\"Spring damping must be greater than 0, otherwise the spring() animation will never end, causing an infinite loop.\");\n  }\n  const c2 = config.damping;\n  const m = config.mass;\n  const k = config.stiffness;\n  const cacheKey = [\n    toValue,\n    lastTimestamp,\n    current,\n    velocity,\n    c2,\n    m,\n    k,\n    now\n  ].join(\"-\");\n  if (advanceCache[cacheKey]) {\n    return advanceCache[cacheKey];\n  }\n  const v0 = -velocity;\n  const x0 = toValue - current;\n  const zeta = c2 / (2 * Math.sqrt(k * m));\n  const omega0 = Math.sqrt(k / m);\n  const omega1 = omega0 * Math.sqrt(1 - zeta ** 2);\n  const t = deltaTime / 1000;\n  const sin1 = Math.sin(omega1 * t);\n  const cos1 = Math.cos(omega1 * t);\n  const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n  const underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n  const underDampedPosition = toValue - underDampedFrag1;\n  const underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n  const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n  const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n  const criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n  const animationNode = {\n    toValue,\n    prevPosition: current,\n    lastTimestamp: now,\n    current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n    velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity\n  };\n  advanceCache[cacheKey] = animationNode;\n  return animationNode;\n}\nvar calculationCache = {};\nfunction springCalculation({\n  frame,\n  fps,\n  config = {}\n}) {\n  const from = 0;\n  const to = 1;\n  const cacheKey = [\n    frame,\n    fps,\n    config.damping,\n    config.mass,\n    config.overshootClamping,\n    config.stiffness\n  ].join(\"-\");\n  if (calculationCache[cacheKey]) {\n    return calculationCache[cacheKey];\n  }\n  let animation = {\n    lastTimestamp: 0,\n    current: from,\n    toValue: to,\n    velocity: 0,\n    prevPosition: 0\n  };\n  const frameClamped = Math.max(0, frame);\n  const unevenRest = frameClamped % 1;\n  for (let f = 0;f <= Math.floor(frameClamped); f++) {\n    if (f === Math.floor(frameClamped)) {\n      f += unevenRest;\n    }\n    const time = f / fps * 1000;\n    animation = advance({\n      animation,\n      now: time,\n      config: {\n        ...defaultSpringConfig,\n        ...config\n      }\n    });\n  }\n  calculationCache[cacheKey] = animation;\n  return animation;\n}\n\n// src/spring/measure-spring.ts\nvar cache = new Map;\nfunction measureSpring({\n  fps,\n  config = {},\n  threshold = 0.005\n}) {\n  if (typeof threshold !== \"number\") {\n    throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n  }\n  if (threshold === 0) {\n    return Infinity;\n  }\n  if (threshold === 1) {\n    return 0;\n  }\n  if (isNaN(threshold)) {\n    throw new TypeError(\"Threshold is NaN\");\n  }\n  if (!Number.isFinite(threshold)) {\n    throw new TypeError(\"Threshold is not finite\");\n  }\n  if (threshold < 0) {\n    throw new TypeError(\"Threshold is below 0\");\n  }\n  const cacheKey = [\n    fps,\n    config.damping,\n    config.mass,\n    config.overshootClamping,\n    config.stiffness,\n    threshold\n  ].join(\"-\");\n  if (cache.has(cacheKey)) {\n    return cache.get(cacheKey);\n  }\n  validateFps(fps, \"to the measureSpring() function\", false);\n  let frame = 0;\n  let finishedFrame = 0;\n  const calc = () => {\n    return springCalculation({\n      fps,\n      frame,\n      config\n    });\n  };\n  let animation = calc();\n  const calcDifference = () => {\n    return Math.abs(animation.current - animation.toValue);\n  };\n  let difference = calcDifference();\n  while (difference >= threshold) {\n    frame++;\n    animation = calc();\n    difference = calcDifference();\n  }\n  finishedFrame = frame;\n  for (let i = 0;i < 20; i++) {\n    frame++;\n    animation = calc();\n    difference = calcDifference();\n    if (difference >= threshold) {\n      i = 0;\n      finishedFrame = frame + 1;\n    }\n  }\n  cache.set(cacheKey, finishedFrame);\n  return finishedFrame;\n}\n\n// src/spring/index.ts\nfunction spring({\n  frame: passedFrame,\n  fps,\n  config = {},\n  from = 0,\n  to = 1,\n  durationInFrames: passedDurationInFrames,\n  durationRestThreshold,\n  delay = 0,\n  reverse = false\n}) {\n  validateSpringDuration(passedDurationInFrames);\n  validateFrame({\n    frame: passedFrame,\n    durationInFrames: Infinity,\n    allowFloats: true\n  });\n  validateFps(fps, \"to spring()\", false);\n  const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== \"undefined\";\n  const naturalDuration = needsToCalculateNaturalDuration ? measureSpring({\n    fps,\n    config,\n    threshold: durationRestThreshold\n  }) : undefined;\n  const naturalDurationGetter = needsToCalculateNaturalDuration ? {\n    get: () => naturalDuration\n  } : {\n    get: () => {\n      throw new Error(\"did not calculate natural duration, this is an error with Remotion. Please report\");\n    }\n  };\n  const reverseProcessed = reverse ? (passedDurationInFrames ?? naturalDurationGetter.get()) - passedFrame : passedFrame;\n  const delayProcessed = reverseProcessed + (reverse ? delay : -delay);\n  const durationProcessed = passedDurationInFrames === undefined ? delayProcessed : delayProcessed / (passedDurationInFrames / naturalDurationGetter.get());\n  if (passedDurationInFrames && delayProcessed > passedDurationInFrames) {\n    return to;\n  }\n  const spr = springCalculation({\n    fps,\n    frame: durationProcessed,\n    config\n  });\n  const inner = config.overshootClamping ? to >= from ? Math.min(spr.current, to) : Math.max(spr.current, to) : spr.current;\n  const interpolated = from === 0 && to === 1 ? inner : interpolate(inner, [0, 1], [from, to]);\n  return interpolated;\n}\n// src/static-file.ts\nvar problematicCharacters = {\n  \"%3A\": \":\",\n  \"%2F\": \"/\",\n  \"%3F\": \"?\",\n  \"%23\": \"#\",\n  \"%5B\": \"[\",\n  \"%5D\": \"]\",\n  \"%40\": \"@\",\n  \"%21\": \"!\",\n  \"%24\": \"$\",\n  \"%26\": \"&\",\n  \"%27\": \"'\",\n  \"%28\": \"(\",\n  \"%29\": \")\",\n  \"%2A\": \"*\",\n  \"%2B\": \"+\",\n  \"%2C\": \",\",\n  \"%3B\": \";\"\n};\nvar didWarn2 = {};\nvar warnOnce3 = (message) => {\n  if (didWarn2[message]) {\n    return;\n  }\n  console.warn(message);\n  didWarn2[message] = true;\n};\nvar includesHexOfUnsafeChar = (path) => {\n  for (const key of Object.keys(problematicCharacters)) {\n    if (path.includes(key)) {\n      return { containsHex: true, hexCode: key };\n    }\n  }\n  return { containsHex: false };\n};\nvar trimLeadingSlash = (path) => {\n  if (path.startsWith(\"/\")) {\n    return trimLeadingSlash(path.substring(1));\n  }\n  return path;\n};\nvar inner = (path) => {\n  if (typeof window !== \"undefined\" && window.remotion_staticBase) {\n    if (path.startsWith(window.remotion_staticBase)) {\n      throw new Error(`The value \"${path}\" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);\n    }\n    return `${window.remotion_staticBase}/${trimLeadingSlash(path)}`;\n  }\n  return `/${trimLeadingSlash(path)}`;\n};\nvar encodeBySplitting = (path) => {\n  const splitBySlash = path.split(\"/\");\n  const encodedArray = splitBySlash.map((element) => {\n    return encodeURIComponent(element);\n  });\n  const merged = encodedArray.join(\"/\");\n  return merged;\n};\nvar staticFile = (path) => {\n  if (path === null) {\n    throw new TypeError(\"null was passed to staticFile()\");\n  }\n  if (typeof path === \"undefined\") {\n    throw new TypeError(\"undefined was passed to staticFile()\");\n  }\n  if (path.startsWith(\"http://\") || path.startsWith(\"https://\")) {\n    throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n  }\n  if (path.startsWith(\"..\") || path.startsWith(\"./\")) {\n    throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"/Users\") || path.startsWith(\"/home\") || path.startsWith(\"/tmp\") || path.startsWith(\"/etc\") || path.startsWith(\"/opt\") || path.startsWith(\"/var\") || path.startsWith(\"C:\") || path.startsWith(\"D:\") || path.startsWith(\"E:\")) {\n    throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  if (path.startsWith(\"public/\")) {\n    throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n  }\n  const includesHex = includesHexOfUnsafeChar(path);\n  if (includesHex.containsHex) {\n    warnOnce3(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n  }\n  const preprocessed = encodeBySplitting(path);\n  const preparsed = inner(preprocessed);\n  if (!preparsed.startsWith(\"/\")) {\n    return `/${preparsed}`;\n  }\n  return preparsed;\n};\n// src/Still.tsx\n\nvar Still = (props2) => {\n  const newProps = {\n    ...props2,\n    durationInFrames: 1,\n    fps: 1\n  };\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Composition, newProps);\n};\n// src/video/Video.tsx\n\n\n// src/video/VideoForRendering.tsx\n\n\n// src/video/seek-until-right.ts\nvar roundTo6Commas = (num) => {\n  return Math.round(num * 1e5) / 1e5;\n};\nvar seekToTime = ({\n  element,\n  desiredTime,\n  logLevel,\n  mountTime\n}) => {\n  if (isApproximatelyTheSame(element.currentTime, desiredTime)) {\n    return {\n      wait: Promise.resolve(desiredTime),\n      cancel: () => {}\n    };\n  }\n  seek({\n    logLevel,\n    mediaRef: element,\n    time: desiredTime,\n    why: \"Seeking during rendering\",\n    mountTime\n  });\n  let cancel;\n  let cancelSeeked = null;\n  const prom = new Promise((resolve) => {\n    cancel = element.requestVideoFrameCallback((now, metadata) => {\n      const displayIn = metadata.expectedDisplayTime - now;\n      if (displayIn <= 0) {\n        resolve(metadata.mediaTime);\n        return;\n      }\n      setTimeout(() => {\n        resolve(metadata.mediaTime);\n      }, displayIn + 150);\n    });\n  });\n  const waitForSeekedEvent = new Promise((resolve) => {\n    const onDone = () => {\n      resolve();\n    };\n    element.addEventListener(\"seeked\", onDone, {\n      once: true\n    });\n    cancelSeeked = () => {\n      element.removeEventListener(\"seeked\", onDone);\n    };\n  });\n  return {\n    wait: Promise.all([prom, waitForSeekedEvent]).then(([time]) => time),\n    cancel: () => {\n      cancelSeeked?.();\n      element.cancelVideoFrameCallback(cancel);\n    }\n  };\n};\nvar seekToTimeMultipleUntilRight = ({\n  element,\n  desiredTime,\n  fps,\n  logLevel,\n  mountTime\n}) => {\n  const threshold = 1 / fps / 2;\n  let currentCancel = () => {\n    return;\n  };\n  if (Number.isFinite(element.duration) && element.currentTime >= element.duration && desiredTime >= element.duration) {\n    return {\n      prom: Promise.resolve(),\n      cancel: () => {}\n    };\n  }\n  const prom = new Promise((resolve, reject) => {\n    const firstSeek = seekToTime({\n      element,\n      desiredTime: desiredTime + threshold,\n      logLevel,\n      mountTime\n    });\n    firstSeek.wait.then((seekedTo) => {\n      const difference = Math.abs(desiredTime - seekedTo);\n      if (difference <= threshold) {\n        return resolve();\n      }\n      const sign = desiredTime > seekedTo ? 1 : -1;\n      const newSeek = seekToTime({\n        element,\n        desiredTime: seekedTo + threshold * sign,\n        logLevel,\n        mountTime\n      });\n      currentCancel = newSeek.cancel;\n      newSeek.wait.then((newTime) => {\n        const newDifference = Math.abs(desiredTime - newTime);\n        if (roundTo6Commas(newDifference) <= roundTo6Commas(threshold)) {\n          return resolve();\n        }\n        const thirdSeek = seekToTime({\n          element,\n          desiredTime: desiredTime + threshold,\n          logLevel,\n          mountTime\n        });\n        currentCancel = thirdSeek.cancel;\n        return thirdSeek.wait.then(() => {\n          resolve();\n        }).catch((err) => {\n          reject(err);\n        });\n      }).catch((err) => {\n        reject(err);\n      });\n    });\n    currentCancel = firstSeek.cancel;\n  });\n  return {\n    prom,\n    cancel: () => {\n      currentCancel();\n    }\n  };\n};\n\n// src/video/VideoForRendering.tsx\n\nvar VideoForRenderingForwardFunction = ({\n  onError,\n  volume: volumeProp,\n  allowAmplificationDuringRender,\n  playbackRate,\n  onDuration,\n  toneFrequency,\n  name,\n  acceptableTimeShiftInSeconds,\n  delayRenderRetries,\n  delayRenderTimeoutInMilliseconds,\n  loopVolumeCurveBehavior,\n  audioStreamIndex,\n  ...props2\n}, ref) => {\n  const absoluteFrame = useTimelinePosition();\n  const frame = useCurrentFrame();\n  const volumePropsFrame = useFrameForVolumeProp(loopVolumeCurveBehavior ?? \"repeat\");\n  const videoConfig = useUnsafeVideoConfig();\n  const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n  const mediaStartsAt = useMediaStartsAt();\n  const environment = useRemotionEnvironment();\n  const logLevel = useLogLevel();\n  const mountTime = useMountTime();\n  const { delayRender: delayRender2, continueRender: continueRender2 } = useDelayRender();\n  const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n  const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `video-${random(props2.src ?? \"\")}-${sequenceContext?.cumulatedFrom}-${sequenceContext?.relativeFrom}-${sequenceContext?.durationInFrames}`, [\n    props2.src,\n    sequenceContext?.cumulatedFrom,\n    sequenceContext?.relativeFrom,\n    sequenceContext?.durationInFrames\n  ]);\n  if (!videoConfig) {\n    throw new Error(\"No video config found\");\n  }\n  const volume = evaluateVolume({\n    volume: volumeProp,\n    frame: volumePropsFrame,\n    mediaVolume: 1\n  });\n  warnAboutTooHighVolume(volume);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!props2.src) {\n      throw new Error(\"No src passed\");\n    }\n    if (props2.muted) {\n      return;\n    }\n    if (volume <= 0) {\n      return;\n    }\n    if (!window.remotion_audioEnabled) {\n      return;\n    }\n    registerRenderAsset({\n      type: \"video\",\n      src: getAbsoluteSrc(props2.src),\n      id,\n      frame: absoluteFrame,\n      volume,\n      mediaFrame: frame,\n      playbackRate: playbackRate ?? 1,\n      toneFrequency: toneFrequency ?? 1,\n      audioStartFrame: Math.max(0, -(sequenceContext?.relativeFrom ?? 0)),\n      audioStreamIndex: audioStreamIndex ?? 0\n    });\n    return () => unregisterRenderAsset(id);\n  }, [\n    props2.muted,\n    props2.src,\n    registerRenderAsset,\n    id,\n    unregisterRenderAsset,\n    volume,\n    frame,\n    absoluteFrame,\n    playbackRate,\n    toneFrequency,\n    sequenceContext?.relativeFrom,\n    audioStreamIndex\n  ]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n    return videoRef.current;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!window.remotion_videoEnabled) {\n      return;\n    }\n    const { current } = videoRef;\n    if (!current) {\n      return;\n    }\n    const currentTime = getMediaTime({\n      frame,\n      playbackRate: playbackRate || 1,\n      startFrom: -mediaStartsAt,\n      fps: videoConfig.fps\n    });\n    const handle = delayRender2(`Rendering <Html5Video /> with src=\"${props2.src}\" at time ${currentTime}`, {\n      retries: delayRenderRetries ?? undefined,\n      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n    });\n    if (window.process?.env?.NODE_ENV === \"test\") {\n      continueRender2(handle);\n      return;\n    }\n    if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n      if (current.readyState >= 2) {\n        continueRender2(handle);\n        return;\n      }\n      const loadedDataHandler = () => {\n        continueRender2(handle);\n      };\n      current.addEventListener(\"loadeddata\", loadedDataHandler, { once: true });\n      return () => {\n        current.removeEventListener(\"loadeddata\", loadedDataHandler);\n      };\n    }\n    const endedHandler = () => {\n      continueRender2(handle);\n    };\n    const seek2 = seekToTimeMultipleUntilRight({\n      element: current,\n      desiredTime: currentTime,\n      fps: videoConfig.fps,\n      logLevel,\n      mountTime\n    });\n    seek2.prom.then(() => {\n      continueRender2(handle);\n    });\n    current.addEventListener(\"ended\", endedHandler, { once: true });\n    const errorHandler = () => {\n      if (current?.error) {\n        console.error(\"Error occurred in video\", current?.error);\n        if (onError) {\n          return;\n        }\n        throw new Error(`The browser threw an error while playing the video ${props2.src}: Code ${current.error.code} - ${current?.error?.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n      } else {\n        throw new Error(\"The browser threw an error\");\n      }\n    };\n    current.addEventListener(\"error\", errorHandler, { once: true });\n    return () => {\n      seek2.cancel();\n      current.removeEventListener(\"ended\", endedHandler);\n      current.removeEventListener(\"error\", errorHandler);\n      continueRender2(handle);\n    };\n  }, [\n    volumePropsFrame,\n    props2.src,\n    playbackRate,\n    videoConfig.fps,\n    frame,\n    mediaStartsAt,\n    onError,\n    delayRenderRetries,\n    delayRenderTimeoutInMilliseconds,\n    logLevel,\n    mountTime,\n    continueRender2,\n    delayRender2\n  ]);\n  const { src } = props2;\n  if (environment.isRendering) {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      if (window.process?.env?.NODE_ENV === \"test\") {\n        return;\n      }\n      const newHandle = delayRender2(\"Loading <Html5Video> duration with src=\" + src, {\n        retries: delayRenderRetries ?? undefined,\n        timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined\n      });\n      const { current } = videoRef;\n      const didLoad = () => {\n        if (current?.duration) {\n          onDuration(src, current.duration);\n        }\n        continueRender2(newHandle);\n      };\n      if (current?.duration) {\n        onDuration(src, current.duration);\n        continueRender2(newHandle);\n      } else {\n        current?.addEventListener(\"loadedmetadata\", didLoad, { once: true });\n      }\n      return () => {\n        current?.removeEventListener(\"loadedmetadata\", didLoad);\n        continueRender2(newHandle);\n      };\n    }, [\n      src,\n      onDuration,\n      delayRenderRetries,\n      delayRenderTimeoutInMilliseconds,\n      continueRender2,\n      delayRender2\n    ]);\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", {\n    ref: videoRef,\n    disableRemotePlayback: true,\n    ...props2\n  });\n};\nvar VideoForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n\n// src/video/Video.tsx\n\nvar VideoForwardingFunction = (props2, ref) => {\n  const {\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter,\n    name,\n    pauseWhenBuffering,\n    stack,\n    _remotionInternalNativeLoopPassed,\n    showInTimeline,\n    onAutoPlayError,\n    ...otherProps\n  } = props2;\n  const { loop, ...propsOtherThanLoop } = props2;\n  const { fps } = useVideoConfig();\n  const environment = useRemotionEnvironment();\n  const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n  if (typeof ref === \"string\") {\n    throw new Error(\"string refs are not supported\");\n  }\n  if (typeof props2.src !== \"string\") {\n    throw new TypeError(`The \\`<Html5Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props2.src)} instead.`);\n  }\n  const preloadedSrc = usePreload(props2.src);\n  const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {\n    setDurations({ type: \"got-duration\", durationInSeconds, src });\n  }, [setDurations]);\n  const onVideoFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {}, []);\n  const durationFetched = durations[getAbsoluteSrc(preloadedSrc)] ?? durations[getAbsoluteSrc(props2.src)];\n  validateMediaTrimProps({ startFrom, endAt, trimBefore, trimAfter });\n  const { trimBeforeValue, trimAfterValue } = resolveTrimProps({\n    startFrom,\n    endAt,\n    trimBefore,\n    trimAfter\n  });\n  if (loop && durationFetched !== undefined) {\n    if (!Number.isFinite(durationFetched)) {\n      return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      });\n    }\n    const mediaDuration = durationFetched * fps;\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, {\n      durationInFrames: calculateMediaDuration({\n        trimAfter: trimAfterValue,\n        mediaDurationInFrames: mediaDuration,\n        playbackRate: props2.playbackRate ?? 1,\n        trimBefore: trimBeforeValue\n      }),\n      layout: \"none\",\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {\n        ...propsOtherThanLoop,\n        ref,\n        _remotionInternalNativeLoopPassed: true\n      })\n    });\n  }\n  if (typeof trimBeforeValue !== \"undefined\" || typeof trimAfterValue !== \"undefined\") {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, {\n      layout: \"none\",\n      from: 0 - (trimBeforeValue ?? 0),\n      showInTimeline: false,\n      durationInFrames: trimAfterValue,\n      name,\n      children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Html5Video, {\n        pauseWhenBuffering: pauseWhenBuffering ?? false,\n        ...otherProps,\n        ref\n      })\n    });\n  }\n  validateMediaProps({ playbackRate: props2.playbackRate, volume: props2.volume }, \"Html5Video\");\n  if (environment.isRendering) {\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, {\n      onDuration,\n      onVideoFrame: onVideoFrame ?? null,\n      ...otherProps,\n      ref\n    });\n  }\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForPreview, {\n    onlyWarnForMediaSeekingError: false,\n    ...otherProps,\n    ref,\n    onVideoFrame: null,\n    pauseWhenBuffering: pauseWhenBuffering ?? false,\n    onDuration,\n    _remotionInternalStack: stack ?? null,\n    _remotionInternalNativeLoopPassed: _remotionInternalNativeLoopPassed ?? false,\n    showInTimeline: showInTimeline ?? true,\n    onAutoPlayError: onAutoPlayError ?? undefined\n  });\n};\nvar Html5Video = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForwardingFunction);\naddSequenceStackTraces(Html5Video);\nvar Video = Html5Video;\n// src/index.ts\ncheckMultipleRemotionVersions();\nvar Experimental = {\n  Clipper,\n  Null,\n  useIsPlayer\n};\nvar proxyObj = {};\nvar Config = new Proxy(proxyObj, {\n  get(_, prop) {\n    if (prop === \"Bundling\" || prop === \"Rendering\" || prop === \"Log\" || prop === \"Puppeteer\" || prop === \"Output\") {\n      return Config;\n    }\n    return () => {\n      console.warn(\"⚠️  The CLI configuration has been extracted from Remotion Core.\");\n      console.warn(\"Update the import from the config file:\");\n      console.warn();\n      console.warn(\"- Delete:\");\n      console.warn('import {Config} from \"remotion\";');\n      console.warn(\"+ Replace:\");\n      console.warn('import {Config} from \"@remotion/cli/config\";');\n      console.warn();\n      console.warn(\"For more information, see https://www.remotion.dev/docs/4-0-migration.\");\n      process.exit(1);\n    };\n  }\n});\naddSequenceStackTraces(Sequence);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNzQztBQUN0QyxXQUFXLGdEQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQixnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixlQUFlLGlCQUFpQixnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDMEI7QUFDaUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZ0RBQW1CO0FBQy9DLGtCQUFrQixrREFBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0RBQW1CO0FBQ3JCLEVBQUUsa0RBQWM7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNvRTtBQUM1QjtBQUN4QyxzQkFBc0Isb0RBQWM7QUFDcEM7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUIsc0RBQUc7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsU0FBUyxpREFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtRUFBbUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUFBRTtBQUM1RSwwQ0FBMEMsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRTtBQUM1RiwwQ0FBMEMsRUFBRTtBQUM1QywwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLElBQUksR0FBRyxJQUFJLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSxr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QTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsZ0JBQWdCO0FBQ3BEO0FBQ0EsNEJBQTRCLFFBQVEsNEJBQTRCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUE4Q0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tb2Rlcm5pemUtbmV4dC1zdGFydGVya2l0Ly4vbm9kZV9tb2R1bGVzL3JlbW90aW9uL2Rpc3QvZXNtL2luZGV4Lm1qcz84M2I3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwge1xuICAgICAgZ2V0OiBhbGxbbmFtZV0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgc2V0OiAobmV3VmFsdWUpID0+IGFsbFtuYW1lXSA9ICgpID0+IG5ld1ZhbHVlXG4gICAgfSk7XG59O1xuXG4vLyBzcmMvX2NoZWNrLXJzYy50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJyZWFjdFwiO1xuaWYgKHR5cGVvZiBjcmVhdGVDb250ZXh0ICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgY29uc3QgZXJyID0gW1xuICAgICdSZW1vdGlvbiByZXF1aXJlcyBSZWFjdC5jcmVhdGVDb250ZXh0LCBidXQgaXQgaXMgXCJ1bmRlZmluZWRcIi4nLFxuICAgICdJZiB5b3UgYXJlIGluIGEgUmVhY3QgU2VydmVyIENvbXBvbmVudCwgdHVybiBpdCBpbnRvIGEgY2xpZW50IGNvbXBvbmVudCBieSBhZGRpbmcgXCJ1c2UgY2xpZW50XCIgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZS4nLFxuICAgIFwiXCIsXG4gICAgXCJCZWZvcmU6XCIsXG4gICAgJyAgaW1wb3J0IHt1c2VDdXJyZW50RnJhbWV9IGZyb20gXCJyZW1vdGlvblwiOycsXG4gICAgXCJcIixcbiAgICBcIkFmdGVyOlwiLFxuICAgICcgIFwidXNlIGNsaWVudFwiOycsXG4gICAgJyAgaW1wb3J0IHt1c2VDdXJyZW50RnJhbWV9IGZyb20gXCJyZW1vdGlvblwiOydcbiAgXTtcbiAgdGhyb3cgbmV3IEVycm9yKGVyci5qb2luKGBcbmApKTtcbn1cblxuLy8gc3JjL0NsaXBwZXIudHN4XG52YXIgQ2xpcHBlciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiPENsaXBwZXI+IGhhcyBiZWVuIHJlbW92ZWQgYXMgb2YgUmVtb3Rpb24gdjQuMC4yMjguIFRoZSBuYXRpdmUgY2xpcHBpbmcgQVBJcyB3ZXJlIGV4cGVyaW1lbnRhbCBhbmQgc3ViamVjdCB0byByZW1vdmFsIGF0IGFueSB0aW1lLiBXZSByZW1vdmVkIHRoZW0gYmVjYXVzZSB0aGV5IHdlcmUgc3BhcmluZ2x5IHVzZWQgYW5kIG1hZGUgcmVuZGVyaW5nIG9mdGVuIHNsb3dlciByYXRoZXIgdGhhbiBmYXN0ZXIuXCIpO1xufTtcblxuLy8gc3JjL2VuYWJsZS1zZXF1ZW5jZS1zdGFjay10cmFjZXMudHNcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBKc3hSdW50aW1lIGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuXG4vLyBzcmMvZ2V0LXJlbW90aW9uLWVudmlyb25tZW50LnRzXG5mdW5jdGlvbiBnZXROb2RlRW52U3RyaW5nKCkge1xuICByZXR1cm4gW1wiTk9EXCIsIFwiRV9FTlwiLCBcIlZcIl0uam9pbihcIlwiKTtcbn1cbnZhciBnZXRFbnZTdHJpbmcgPSAoKSA9PiB7XG4gIHJldHVybiBbXCJlXCIsIFwibnZcIl0uam9pbihcIlwiKTtcbn07XG52YXIgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCA9ICgpID0+IHtcbiAgY29uc3QgaXNQbGF5ZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcjtcbiAgY29uc3QgaXNSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cucHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MuZW52ICE9PSBcInVuZGVmaW5lZFwiICYmICh3aW5kb3cucHJvY2Vzc1tnZXRFbnZTdHJpbmcoKV1bZ2V0Tm9kZUVudlN0cmluZygpXSA9PT0gXCJ0ZXN0XCIgfHwgd2luZG93LnByb2Nlc3NbZ2V0RW52U3RyaW5nKCldW2dldE5vZGVFbnZTdHJpbmcoKV0gPT09IFwicHJvZHVjdGlvblwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHdpbmRvdy5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0ICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgY29uc3QgaXNTdHVkaW8gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pc1N0dWRpbztcbiAgY29uc3QgaXNSZWFkT25seVN0dWRpbyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LnJlbW90aW9uX2lzUmVhZE9ubHlTdHVkaW87XG4gIHJldHVybiB7XG4gICAgaXNTdHVkaW8sXG4gICAgaXNSZW5kZXJpbmcsXG4gICAgaXNQbGF5ZXIsXG4gICAgaXNSZWFkT25seVN0dWRpbyxcbiAgICBpc0NsaWVudFNpZGVSZW5kZXJpbmc6IGZhbHNlXG4gIH07XG59O1xuXG4vLyBzcmMvZW5hYmxlLXNlcXVlbmNlLXN0YWNrLXRyYWNlcy50c1xudmFyIG9yaWdpbmFsQ3JlYXRlRWxlbWVudCA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQ7XG52YXIgb3JpZ2luYWxKc3ggPSBKc3hSdW50aW1lLmpzeDtcbnZhciBjb21wb25lbnRzVG9BZGRTdGFja3NUbyA9IFtdO1xudmFyIGVuYWJsZVByb3h5ID0gKGFwaSkgPT4ge1xuICByZXR1cm4gbmV3IFByb3h5KGFwaSwge1xuICAgIGFwcGx5KHRhcmdldCwgdGhpc0FyZywgYXJnQXJyYXkpIHtcbiAgICAgIGlmIChjb21wb25lbnRzVG9BZGRTdGFja3NUby5pbmNsdWRlcyhhcmdBcnJheVswXSkpIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBwcm9wcywgLi4ucmVzdF0gPSBhcmdBcnJheTtcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgLi4ucHJvcHMgPz8ge30sXG4gICAgICAgICAgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmFwcGx5KHRhcmdldCwgdGhpc0FyZywgW2ZpcnN0LCBuZXdQcm9wcywgLi4ucmVzdF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJlZmxlY3QuYXBwbHkodGFyZ2V0LCB0aGlzQXJnLCBhcmdBcnJheSk7XG4gICAgfVxuICB9KTtcbn07XG52YXIgZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcyA9ICgpID0+IHtcbiAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgUmVhY3QuY3JlYXRlRWxlbWVudCA9IGVuYWJsZVByb3h5KG9yaWdpbmFsQ3JlYXRlRWxlbWVudCk7XG4gIEpzeFJ1bnRpbWUuanN4ID0gZW5hYmxlUHJveHkob3JpZ2luYWxKc3gpO1xufTtcbnZhciBhZGRTZXF1ZW5jZVN0YWNrVHJhY2VzID0gKGNvbXBvbmVudCkgPT4ge1xuICBjb21wb25lbnRzVG9BZGRTdGFja3NUby5wdXNoKGNvbXBvbmVudCk7XG4gIGVuYWJsZVNlcXVlbmNlU3RhY2tUcmFjZXMoKTtcbn07XG5cbi8vIHNyYy9pcy1wbGF5ZXIudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyLCB1c2VDb250ZXh0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJc1BsYXllckNvbnRleHQgPSBjcmVhdGVDb250ZXh0MihmYWxzZSk7XG52YXIgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlblxufSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChJc1BsYXllckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgdXNlSXNQbGF5ZXIgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KElzUGxheWVyQ29udGV4dCk7XG59O1xuXG4vLyBzcmMvdHJ1dGh5LnRzXG5mdW5jdGlvbiB0cnV0aHkodmFsdWUpIHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufVxuXG4vLyBzcmMvdmVyc2lvbi50c1xudmFyIFZFUlNJT04gPSBcIjQuMC4zNzBcIjtcblxuLy8gc3JjL211bHRpcGxlLXZlcnNpb25zLXdhcm5pbmcudHNcbnZhciBjaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNldCA9ICgpID0+IHtcbiAgICBnbG9iYWxUaGlzLnJlbW90aW9uX2ltcG9ydGVkID0gVkVSU0lPTjtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LnJlbW90aW9uX2ltcG9ydGVkID0gVkVSU0lPTjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGFscmVhZHlJbXBvcnRlZCA9IGdsb2JhbFRoaXMucmVtb3Rpb25faW1wb3J0ZWQgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faW1wb3J0ZWQ7XG4gIGlmIChhbHJlYWR5SW1wb3J0ZWQpIHtcbiAgICBpZiAoYWxyZWFkeUltcG9ydGVkID09PSBWRVJTSU9OKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWxyZWFkeUltcG9ydGVkID09PSBcInN0cmluZ1wiICYmIGFscmVhZHlJbXBvcnRlZC5pbmNsdWRlcyhcIndlYmNvZGVjc1wiKSkge1xuICAgICAgc2V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFxcdUQ4M0RcXHVERUE4IE11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGRldGVjdGVkOiAke1tcbiAgICAgIFZFUlNJT04sXG4gICAgICB0eXBlb2YgYWxyZWFkeUltcG9ydGVkID09PSBcInN0cmluZ1wiID8gYWxyZWFkeUltcG9ydGVkIDogXCJhbiBvbGRlciB2ZXJzaW9uXCJcbiAgICBdLmZpbHRlcih0cnV0aHkpLmpvaW4oXCIgYW5kIFwiKX0uIFRoaXMgd2lsbCBjYXVzZSB0aGluZ3MgdG8gYnJlYWsgaW4gYW4gdW5leHBlY3RlZCB3YXkuXG5DaGVjayB0aGF0IGFsbCB5b3VyIFJlbW90aW9uIHBhY2thZ2VzIGFyZSBvbiB0aGUgc2FtZSB2ZXJzaW9uLiBJZiB5b3VyIGRlcGVuZGVuY2llcyBkZXBlbmQgb24gUmVtb3Rpb24sIG1ha2UgdGhlbSBwZWVyIGRlcGVuZGVuY2llcy4gWW91IGNhbiBhbHNvIHJ1biBcXGBucHggcmVtb3Rpb24gdmVyc2lvbnNcXGAgZnJvbSB5b3VyIHRlcm1pbmFsIHRvIHNlZSB3aGljaCB2ZXJzaW9ucyBhcmUgbWlzbWF0Y2hpbmcuYCk7XG4gIH1cbiAgc2V0KCk7XG59O1xuXG4vLyBzcmMvTnVsbC50c3hcbnZhciBOdWxsID0gKCkgPT4ge1xuICB0aHJvdyBuZXcgRXJyb3IoXCI8TnVsbD4gaGFzIGJlZW4gcmVtb3ZlZCBhcyBvZiBSZW1vdGlvbiB2NC4wLjIyOC4gVGhlIG5hdGl2ZSBjbGlwcGluZyBBUElzIHdlcmUgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIHJlbW92YWwgYXQgYW55IHRpbWUuIFdlIHJlbW92ZWQgdGhlbSBiZWNhdXNlIHRoZXkgd2VyZSBzcGFyaW5nbHkgdXNlZCBhbmQgbWFkZSByZW5kZXJpbmcgb2Z0ZW4gc2xvd2VyIHJhdGhlciB0aGFuIGZhc3Rlci5cIik7XG59O1xuXG4vLyBzcmMvU2VxdWVuY2UudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYyLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDMsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzksXG4gIHVzZVN0YXRlIGFzIHVzZVN0YXRlNVxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0Fic29sdXRlRmlsbC50c3hcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZU1lbW8gfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgaGFzVGFpbHdpbmRDbGFzc05hbWUgPSAoe1xuICBjbGFzc05hbWUsXG4gIGNsYXNzUHJlZml4LFxuICB0eXBlXG59KSA9PiB7XG4gIGlmICghY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlID09PSBcImV4YWN0XCIpIHtcbiAgICBjb25zdCBzcGxpdCA9IGNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgcmV0dXJuIGNsYXNzUHJlZml4LnNvbWUoKHRva2VuKSA9PiB7XG4gICAgICByZXR1cm4gc3BsaXQuc29tZSgocGFydCkgPT4ge1xuICAgICAgICByZXR1cm4gcGFydC50cmltKCkgPT09IHRva2VuIHx8IHBhcnQudHJpbSgpLmVuZHNXaXRoKGA6JHt0b2tlbn1gKSB8fCBwYXJ0LnRyaW0oKS5lbmRzV2l0aChgISR7dG9rZW59YCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY2xhc3NQcmVmaXguc29tZSgocHJlZml4KSA9PiB7XG4gICAgcmV0dXJuIGNsYXNzTmFtZS5zdGFydHNXaXRoKHByZWZpeCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGAgJHtwcmVmaXh9YCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGAhJHtwcmVmaXh9YCkgfHwgY2xhc3NOYW1lLmluY2x1ZGVzKGA6JHtwcmVmaXh9YCk7XG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgeyBzdHlsZSwgLi4ub3RoZXIgfSA9IHByb3BzO1xuICBjb25zdCBhY3R1YWxTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgdG9wOiBoYXNUYWlsd2luZENsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZTogb3RoZXIuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1ByZWZpeDogW1widG9wLVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgbGVmdDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcImxlZnQtXCIsIFwiaW5zZXQtXCJdLFxuICAgICAgICB0eXBlOiBcInByZWZpeFwiXG4gICAgICB9KSA/IHVuZGVmaW5lZCA6IDAsXG4gICAgICByaWdodDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcInJpZ2h0LVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgYm90dG9tOiBoYXNUYWlsd2luZENsYXNzTmFtZSh7XG4gICAgICAgIGNsYXNzTmFtZTogb3RoZXIuY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1ByZWZpeDogW1wiYm90dG9tLVwiLCBcImluc2V0LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiAwLFxuICAgICAgd2lkdGg6IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXCJ3LVwiXSxcbiAgICAgICAgdHlwZTogXCJwcmVmaXhcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiBcIjEwMCVcIixcbiAgICAgIGhlaWdodDogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcImgtXCJdLFxuICAgICAgICB0eXBlOiBcInByZWZpeFwiXG4gICAgICB9KSA/IHVuZGVmaW5lZCA6IFwiMTAwJVwiLFxuICAgICAgZGlzcGxheTogaGFzVGFpbHdpbmRDbGFzc05hbWUoe1xuICAgICAgICBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSxcbiAgICAgICAgY2xhc3NQcmVmaXg6IFtcbiAgICAgICAgICBcImJsb2NrXCIsXG4gICAgICAgICAgXCJpbmxpbmUtYmxvY2tcIixcbiAgICAgICAgICBcImlubGluZVwiLFxuICAgICAgICAgIFwiZmxleFwiLFxuICAgICAgICAgIFwiaW5saW5lLWZsZXhcIixcbiAgICAgICAgICBcImZsb3ctcm9vdFwiLFxuICAgICAgICAgIFwiZ3JpZFwiLFxuICAgICAgICAgIFwiaW5saW5lLWdyaWRcIixcbiAgICAgICAgICBcImNvbnRlbnRzXCIsXG4gICAgICAgICAgXCJsaXN0LWl0ZW1cIixcbiAgICAgICAgICBcImhpZGRlblwiXG4gICAgICAgIF0sXG4gICAgICAgIHR5cGU6IFwiZXhhY3RcIlxuICAgICAgfSkgPyB1bmRlZmluZWQgOiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IGhhc1RhaWx3aW5kQ2xhc3NOYW1lKHtcbiAgICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICAgIGNsYXNzUHJlZml4OiBbXG4gICAgICAgICAgXCJmbGV4LXJvd1wiLFxuICAgICAgICAgIFwiZmxleC1jb2xcIixcbiAgICAgICAgICBcImZsZXgtcm93LXJldmVyc2VcIixcbiAgICAgICAgICBcImZsZXgtY29sLXJldmVyc2VcIlxuICAgICAgICBdLFxuICAgICAgICB0eXBlOiBcImV4YWN0XCJcbiAgICAgIH0pID8gdW5kZWZpbmVkIDogXCJjb2x1bW5cIixcbiAgICAgIC4uLnN0eWxlXG4gICAgfTtcbiAgfSwgW290aGVyLmNsYXNzTmFtZSwgc3R5bGVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFwiZGl2XCIsIHtcbiAgICByZWYsXG4gICAgc3R5bGU6IGFjdHVhbFN0eWxlLFxuICAgIC4uLm90aGVyXG4gIH0pO1xufTtcbnZhciBBYnNvbHV0ZUZpbGwgPSBmb3J3YXJkUmVmKEFic29sdXRlRmlsbFJlZkZvcndhcmRpbmcpO1xuXG4vLyBzcmMvU2VxdWVuY2VDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIFNlcXVlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQzKG51bGwpO1xuXG4vLyBzcmMvU2VxdWVuY2VNYW5hZ2VyLnRzeFxuaW1wb3J0IFJlYWN0MywgeyB1c2VDYWxsYmFjaywgdXNlTWVtbyBhcyB1c2VNZW1vMiwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgU2VxdWVuY2VNYW5hZ2VyID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQoe1xuICByZWdpc3RlclNlcXVlbmNlOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2VxdWVuY2VNYW5hZ2VyQ29udGV4dCBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH0sXG4gIHVucmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkXCIpO1xuICB9LFxuICBzZXF1ZW5jZXM6IFtdXG59KTtcbnZhciBTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGVDb250ZXh0ID0gUmVhY3QzLmNyZWF0ZUNvbnRleHQoe1xuICBoaWRkZW46IHt9LFxuICBzZXRIaWRkZW46ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXF1ZW5jZVZpc2liaWxpdHlUb2dnbGUgbm90IGluaXRpYWxpemVkXCIpO1xuICB9XG59KTtcbnZhciBTZXF1ZW5jZU1hbmFnZXJQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3NlcXVlbmNlcywgc2V0U2VxdWVuY2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2hpZGRlbiwgc2V0SGlkZGVuXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgcmVnaXN0ZXJTZXF1ZW5jZSA9IHVzZUNhbGxiYWNrKChzZXEpID0+IHtcbiAgICBzZXRTZXF1ZW5jZXMoKHNlcXMpID0+IHtcbiAgICAgIHJldHVybiBbLi4uc2Vxcywgc2VxXTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyU2VxdWVuY2UgPSB1c2VDYWxsYmFjaygoc2VxKSA9PiB7XG4gICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiBzZXFzLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc2VxKSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlTWVtbzIoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZWdpc3RlclNlcXVlbmNlLFxuICAgICAgc2VxdWVuY2VzLFxuICAgICAgdW5yZWdpc3RlclNlcXVlbmNlXG4gICAgfTtcbiAgfSwgW3JlZ2lzdGVyU2VxdWVuY2UsIHNlcXVlbmNlcywgdW5yZWdpc3RlclNlcXVlbmNlXSk7XG4gIGNvbnN0IGhpZGRlbkNvbnRleHQgPSB1c2VNZW1vMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhpZGRlbixcbiAgICAgIHNldEhpZGRlblxuICAgIH07XG4gIH0sIFtoaWRkZW5dKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzKFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzZXF1ZW5jZUNvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzKFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBoaWRkZW5Db250ZXh0LFxuICAgICAgY2hpbGRyZW5cbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9ub25jZS50c1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NCwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xudmFyIE5vbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ0KHtcbiAgZ2V0Tm9uY2U6ICgpID0+IDAsXG4gIGZhc3RSZWZyZXNoZXM6IDAsXG4gIG1hbnVhbFJlZnJlc2hlczogMFxufSk7XG52YXIgU2V0Tm9uY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDQoe1xuICBpbmNyZWFzZU1hbnVhbFJlZnJlc2hlczogKCkgPT4ge31cbn0pO1xudmFyIHVzZU5vbmNlID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDIoTm9uY2VDb250ZXh0KTtcbiAgY29uc3QgW25vbmNlLCBzZXROb25jZV0gPSB1c2VTdGF0ZTIoKCkgPT4gY29udGV4dC5nZXROb25jZSgpKTtcbiAgY29uc3QgbGFzdENvbnRleHQgPSB1c2VSZWYoY29udGV4dCk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGxhc3RDb250ZXh0LmN1cnJlbnQgPT09IGNvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdENvbnRleHQuY3VycmVudCA9IGNvbnRleHQ7XG4gICAgc2V0Tm9uY2UoY29udGV4dC5nZXROb25jZSk7XG4gIH0sIFtjb250ZXh0XSk7XG4gIHJldHVybiBub25jZTtcbn07XG5cbi8vIHNyYy90aW1lbGluZS1wb3NpdGlvbi1zdGF0ZS50c1xudmFyIGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUgPSB7fTtcbl9fZXhwb3J0KGV4cG9ydHNfdGltZWxpbmVfcG9zaXRpb25fc3RhdGUsIHtcbiAgdXNlVGltZWxpbmVTZXRGcmFtZTogKCkgPT4gdXNlVGltZWxpbmVTZXRGcmFtZSxcbiAgdXNlVGltZWxpbmVQb3NpdGlvbjogKCkgPT4gdXNlVGltZWxpbmVQb3NpdGlvbixcbiAgdXNlUGxheWluZ1N0YXRlOiAoKSA9PiB1c2VQbGF5aW5nU3RhdGUsXG4gIHBlcnNpc3RDdXJyZW50RnJhbWU6ICgpID0+IHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gIGdldEluaXRpYWxGcmFtZVN0YXRlOiAoKSA9PiBnZXRJbml0aWFsRnJhbWVTdGF0ZSxcbiAgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbjogKCkgPT4gZ2V0RnJhbWVGb3JDb21wb3NpdGlvbixcbiAgVGltZWxpbmVDb250ZXh0OiAoKSA9PiBUaW1lbGluZUNvbnRleHQsXG4gIFNldFRpbWVsaW5lQ29udGV4dDogKCkgPT4gU2V0VGltZWxpbmVDb250ZXh0XG59KTtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDgsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDYsIHVzZU1lbW8gYXMgdXNlTWVtbzYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS1yZW1vdGlvbi1lbnZpcm9ubWVudC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MywgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9yZW1vdGlvbi1lbnZpcm9ubWVudC1jb250ZXh0LnRzXG5pbXBvcnQgUmVhY3Q0IGZyb20gXCJyZWFjdFwiO1xudmFyIFJlbW90aW9uRW52aXJvbm1lbnRDb250ZXh0ID0gUmVhY3Q0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbi8vIHNyYy91c2UtcmVtb3Rpb24tZW52aXJvbm1lbnQudHNcbnZhciB1c2VSZW1vdGlvbkVudmlyb25tZW50ID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDMoUmVtb3Rpb25FbnZpcm9ubWVudENvbnRleHQpO1xuICBjb25zdCBbZW52XSA9IHVzZVN0YXRlMygoKSA9PiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkpO1xuICByZXR1cm4gY29udGV4dCA/PyBlbnY7XG59O1xuXG4vLyBzcmMvdXNlLXZpZGVvLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ1LCB1c2VNZW1vIGFzIHVzZU1lbW81IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9Db21wb3NpdGlvbk1hbmFnZXJDb250ZXh0LnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIENvbXBvc2l0aW9uTWFuYWdlciA9IGNyZWF0ZUNvbnRleHQ1KHtcbiAgY29tcG9zaXRpb25zOiBbXSxcbiAgZm9sZGVyczogW10sXG4gIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhOiBudWxsLFxuICBjYW52YXNDb250ZW50OiBudWxsXG59KTtcbnZhciBDb21wb3NpdGlvblNldHRlcnMgPSBjcmVhdGVDb250ZXh0NSh7XG4gIHJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgIHJldHVybjtcbiAgfSxcbiAgcmVnaXN0ZXJGb2xkZXI6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVucmVnaXN0ZXJGb2xkZXI6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHNldENhbnZhc0NvbnRlbnQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBvbmx5UmVuZGVyQ29tcG9zaXRpb246IG51bGxcbn0pO1xuXG4vLyBzcmMvUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NyxcbiAgY3JlYXRlUmVmLFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazMsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDQsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGUyLFxuICB1c2VNZW1vIGFzIHVzZU1lbW80LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTRcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9FZGl0b3JQcm9wcy50c3hcbmltcG9ydCBSZWFjdDUsIHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0NixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlLFxuICB1c2VNZW1vIGFzIHVzZU1lbW8zXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBFZGl0b3JQcm9wc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0Nih7XG4gIHByb3BzOiB7fSxcbiAgdXBkYXRlUHJvcHM6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH0sXG4gIHJlc2V0VW5zYXZlZDogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxufSk7XG52YXIgZWRpdG9yUHJvcHNQcm92aWRlclJlZiA9IFJlYWN0NS5jcmVhdGVSZWYoKTtcbnZhciB0aW1lVmFsdWVSZWYgPSBSZWFjdDUuY3JlYXRlUmVmKCk7XG52YXIgRWRpdG9yUHJvcHNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW3Byb3BzLCBzZXRQcm9wc10gPSBSZWFjdDUudXNlU3RhdGUoe30pO1xuICBjb25zdCB1cGRhdGVQcm9wcyA9IHVzZUNhbGxiYWNrMigoe1xuICAgIGRlZmF1bHRQcm9wcyxcbiAgICBpZCxcbiAgICBuZXdQcm9wc1xuICB9KSA9PiB7XG4gICAgc2V0UHJvcHMoKHByZXYpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtpZF06IHR5cGVvZiBuZXdQcm9wcyA9PT0gXCJmdW5jdGlvblwiID8gbmV3UHJvcHMocHJldltpZF0gPz8gZGVmYXVsdFByb3BzKSA6IG5ld1Byb3BzXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc2V0VW5zYXZlZCA9IHVzZUNhbGxiYWNrMigoY29tcG9zaXRpb25JZCkgPT4ge1xuICAgIHNldFByb3BzKChwcmV2KSA9PiB7XG4gICAgICBpZiAocHJldltjb21wb3NpdGlvbklkXSkge1xuICAgICAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4ucHJldiB9O1xuICAgICAgICBkZWxldGUgbmV3UHJvcHNbY29tcG9zaXRpb25JZF07XG4gICAgICAgIHJldHVybiBuZXdQcm9wcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZWRpdG9yUHJvcHNQcm92aWRlclJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRQcm9wczogKCkgPT4gcHJvcHMsXG4gICAgICBzZXRQcm9wc1xuICAgIH07XG4gIH0sIFtwcm9wc10pO1xuICBjb25zdCBjdHggPSB1c2VNZW1vMygoKSA9PiB7XG4gICAgcmV0dXJuIHsgcHJvcHMsIHVwZGF0ZVByb3BzLCByZXNldFVuc2F2ZWQgfTtcbiAgfSwgW3Byb3BzLCByZXNldFVuc2F2ZWQsIHVwZGF0ZVByb3BzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NChFZGl0b3JQcm9wc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY3R4LFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL2lucHV0LXByb3BzLW92ZXJyaWRlLnRzXG52YXIgZ2V0S2V5ID0gKCkgPT4ge1xuICByZXR1cm4gYHJlbW90aW9uX2lucHV0UHJvcHNPdmVycmlkZWAgKyB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xufTtcbnZhciBnZXRJbnB1dFByb3BzT3ZlcnJpZGUgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlID09PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBvdmVycmlkZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGdldEtleSgpKTtcbiAgaWYgKCFvdmVycmlkZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIEpTT04ucGFyc2Uob3ZlcnJpZGUpO1xufTtcbnZhciBzZXRJbnB1dFByb3BzT3ZlcnJpZGUgPSAob3ZlcnJpZGUpID0+IHtcbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBpZiAob3ZlcnJpZGUgPT09IG51bGwpIHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShnZXRLZXkoKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGdldEtleSgpLCBKU09OLnN0cmluZ2lmeShvdmVycmlkZSkpO1xufTtcblxuLy8gc3JjL2lucHV0LXByb3BzLXNlcmlhbGl6YXRpb24udHNcbnZhciBEQVRFX1RPS0VOID0gXCJyZW1vdGlvbi1kYXRlOlwiO1xudmFyIEZJTEVfVE9LRU4gPSBcInJlbW90aW9uLWZpbGU6XCI7XG52YXIgc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMgPSAoe1xuICBkYXRhLFxuICBpbmRlbnQsXG4gIHN0YXRpY0Jhc2Vcbn0pID0+IHtcbiAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gIGxldCBjdXN0b21GaWxlVXNlZCA9IGZhbHNlO1xuICBsZXQgbWFwVXNlZCA9IGZhbHNlO1xuICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0RBVEVfVE9LRU59JHtpdGVtLnRvSVNPU3RyaW5nKCl9YDtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiICYmIHN0YXRpY0Jhc2UgIT09IG51bGwgJiYgaXRlbS5zdGFydHNXaXRoKHN0YXRpY0Jhc2UpKSB7XG4gICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGAke0ZJTEVfVE9LRU59JHtpdGVtLnJlcGxhY2Uoc3RhdGljQmFzZSArIFwiL1wiLCBcIlwiKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIGluZGVudCk7XG4gICAgcmV0dXJuIHsgc2VyaWFsaXplZFN0cmluZywgY3VzdG9tRGF0ZVVzZWQsIGN1c3RvbUZpbGVVc2VkLCBtYXBVc2VkLCBzZXRVc2VkIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBzZXJpYWxpemUgdGhlIHBhc3NlZCBpbnB1dCBwcm9wcyB0byBKU09OOiBcIiArIGVyci5tZXNzYWdlKTtcbiAgfVxufTtcbnZhciBkZXNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzID0gKGRhdGEpID0+IHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSwgKF8sIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCBcIlwiKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChGSUxFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3ZhbHVlLnJlcGxhY2UoRklMRV9UT0tFTiwgXCJcIil9YDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn07XG52YXIgc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBkZXNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzKHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzKHtcbiAgICBkYXRhOiBwcm9wcyxcbiAgICBpbmRlbnQ6IDIsXG4gICAgc3RhdGljQmFzZTogd2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2VcbiAgfSkuc2VyaWFsaXplZFN0cmluZyk7XG59O1xudmFyIHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvID0gKHByb3BzKSA9PiB7XG4gIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICByZXR1cm4gc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplKHByb3BzKTtcbiAgfVxuICByZXR1cm4gcHJvcHM7XG59O1xuXG4vLyBzcmMvY29uZmlnL2lucHV0LXByb3BzLnRzXG52YXIgZGlkV2FyblNTUkltcG9ydCA9IGZhbHNlO1xudmFyIHdhcm5PbmNlU1NSSW1wb3J0ID0gKCkgPT4ge1xuICBpZiAoZGlkV2FyblNTUkltcG9ydCkge1xuICAgIHJldHVybjtcbiAgfVxuICBkaWRXYXJuU1NSSW1wb3J0ID0gdHJ1ZTtcbiAgY29uc29sZS53YXJuKFwiQ2FsbGVkIGBnZXRJbnB1dFByb3BzKClgIG9uIHRoZSBzZXJ2ZXIuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBzZXJ2ZXItc2lkZSBhbmQgaGFzIHJldHVybmVkIGFuIGVtcHR5IG9iamVjdC5cIik7XG4gIGNvbnNvbGUud2FybihcIlRvIGhpZGUgdGhpcyB3YXJuaW5nLCBkb24ndCBjYWxsIHRoaXMgZnVuY3Rpb24gb24gdGhlIHNlcnZlcjpcIik7XG4gIGNvbnNvbGUud2FybihcIiAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyB7fSA6IGdldElucHV0UHJvcHMoKVwiKTtcbn07XG52YXIgZ2V0SW5wdXRQcm9wcyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3YXJuT25jZVNTUkltcG9ydCgpO1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBjYWxsIGBnZXRJbnB1dFByb3BzKClgIGZyb20gYSA8UGxheWVyPi4gSW5zdGVhZCwgdGhlIHByb3BzIGFyZSBhdmFpbGFibGUgYXMgUmVhY3QgcHJvcHMgZnJvbSBjb21wb25lbnQgdGhhdCB5b3UgcGFzc2VkIGFzIGBjb21wb25lbnRgIHByb3AuXCIpO1xuICB9XG4gIGNvbnN0IG92ZXJyaWRlID0gZ2V0SW5wdXRQcm9wc092ZXJyaWRlKCk7XG4gIGlmIChvdmVycmlkZSkge1xuICAgIHJldHVybiBvdmVycmlkZTtcbiAgfVxuICBjb25zdCBwYXJhbSA9IHdpbmRvdy5yZW1vdGlvbl9pbnB1dFByb3BzO1xuICBpZiAoIXBhcmFtKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHBhcnNlZCA9IGRlc2VyaWFsaXplSlNPTldpdGhTcGVjaWFsVHlwZXMocGFyYW0pO1xuICByZXR1cm4gcGFyc2VkO1xufTtcblxuLy8gc3JjL2NvZGVjLnRzXG52YXIgdmFsaWRDb2RlY3MgPSBbXG4gIFwiaDI2NFwiLFxuICBcImgyNjVcIixcbiAgXCJ2cDhcIixcbiAgXCJ2cDlcIixcbiAgXCJtcDNcIixcbiAgXCJhYWNcIixcbiAgXCJ3YXZcIixcbiAgXCJwcm9yZXNcIixcbiAgXCJoMjY0LW1rdlwiLFxuICBcImgyNjQtdHNcIixcbiAgXCJnaWZcIlxuXTtcblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGVmYXVsdC1jb2RlYy50c1xuZnVuY3Rpb24gdmFsaWRhdGVDb2RlYyhkZWZhdWx0Q29kZWMsIGxvY2F0aW9uLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgZGVmYXVsdENvZGVjID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdENvZGVjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhIHN0cmluZywgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGRlZmF1bHRDb2RlY30uYCk7XG4gIH1cbiAgaWYgKCF2YWxpZENvZGVjcy5pbmNsdWRlcyhkZWZhdWx0Q29kZWMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWV9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIG9uZSBvZiAke3ZhbGlkQ29kZWNzLmpvaW4oXCIsIFwiKX0sIGJ1dCB5b3UgcGFzc2VkICR7ZGVmYXVsdENvZGVjfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kaW1lbnNpb25zLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gIGlmICh0eXBlb2YgYW1vdW50ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgYW1vdW50fWApO1xuICB9XG4gIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7YW1vdW50fS5gKTtcbiAgfVxuICBpZiAoYW1vdW50IDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1kdXJhdGlvbi1pbi1mcmFtZXMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgYWxsb3dGbG9hdHMsIGNvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgfVxuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgfVxuICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxuICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uSW5GcmFtZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZnBzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICBpZiAodHlwZW9mIGZwcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGZwcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBub3QgYmUgTmFOLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChmcHMgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNHaWYgJiYgZnBzID4gNTApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICB9XG59XG5cbi8vIHNyYy9yZXNvbHZlLXZpZGVvLWNvbmZpZy50c1xudmFyIHZhbGlkYXRlQ2FsY3VsYXRlZCA9ICh7XG4gIGNhbGN1bGF0ZWQsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRnBzLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aCxcbiAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA9IGBjYWxjdWxhdGVkIGJ5IGNhbGN1bGF0ZU1ldGFkYXRhKCkgZm9yIHRoZSBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImA7XG4gIGNvbnN0IGRlZmF1bHRFcnJvckxvY2F0aW9uID0gYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb25JZH1cImA7XG4gIGNvbnN0IHdpZHRoID0gY2FsY3VsYXRlZD8ud2lkdGggPz8gY29tcG9zaXRpb25XaWR0aCA/PyB1bmRlZmluZWQ7XG4gIHZhbGlkYXRlRGltZW5zaW9uKHdpZHRoLCBcIndpZHRoXCIsIGNhbGN1bGF0ZWQ/LndpZHRoID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24pO1xuICBjb25zdCBoZWlnaHQgPSBjYWxjdWxhdGVkPy5oZWlnaHQgPz8gY29tcG9zaXRpb25IZWlnaHQgPz8gdW5kZWZpbmVkO1xuICB2YWxpZGF0ZURpbWVuc2lvbihoZWlnaHQsIFwiaGVpZ2h0XCIsIGNhbGN1bGF0ZWQ/LmhlaWdodCA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uKTtcbiAgY29uc3QgZnBzID0gY2FsY3VsYXRlZD8uZnBzID8/IGNvbXBvc2l0aW9uRnBzID8/IG51bGw7XG4gIHZhbGlkYXRlRnBzKGZwcywgY2FsY3VsYXRlZD8uZnBzID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24sIGZhbHNlKTtcbiAgY29uc3QgZHVyYXRpb25JbkZyYW1lcyA9IGNhbGN1bGF0ZWQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzID8/IG51bGw7XG4gIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgYWxsb3dGbG9hdHM6IGZhbHNlLFxuICAgIGNvbXBvbmVudDogYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb25JZH1cImBcbiAgfSk7XG4gIGNvbnN0IGRlZmF1bHRDb2RlYyA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRDb2RlYztcbiAgdmFsaWRhdGVDb2RlYyhkZWZhdWx0Q29kZWMsIGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiwgXCJkZWZhdWx0Q29kZWNcIik7XG4gIGNvbnN0IGRlZmF1bHRPdXROYW1lID0gY2FsY3VsYXRlZD8uZGVmYXVsdE91dE5hbWU7XG4gIGNvbnN0IGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0ID0gY2FsY3VsYXRlZD8uZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ7XG4gIGNvbnN0IGRlZmF1bHRQaXhlbEZvcm1hdCA9IGNhbGN1bGF0ZWQ/LmRlZmF1bHRQaXhlbEZvcm1hdDtcbiAgY29uc3QgZGVmYXVsdFByb1Jlc1Byb2ZpbGUgPSBjYWxjdWxhdGVkPy5kZWZhdWx0UHJvUmVzUHJvZmlsZTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZnBzLFxuICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgZGVmYXVsdENvZGVjLFxuICAgIGRlZmF1bHRPdXROYW1lLFxuICAgIGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0LFxuICAgIGRlZmF1bHRQaXhlbEZvcm1hdCxcbiAgICBkZWZhdWx0UHJvUmVzUHJvZmlsZVxuICB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWcgPSAoe1xuICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgc2lnbmFsLFxuICBkZWZhdWx0UHJvcHMsXG4gIG9yaWdpbmFsUHJvcHMsXG4gIGNvbXBvc2l0aW9uSWQsXG4gIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgY29tcG9zaXRpb25GcHMsXG4gIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICBjb21wb3NpdGlvbldpZHRoXG59KSA9PiB7XG4gIGNvbnN0IGNhbGN1bGF0ZWRQcm9tID0gY2FsY3VsYXRlTWV0YWRhdGEgPyBjYWxjdWxhdGVNZXRhZGF0YSh7XG4gICAgZGVmYXVsdFByb3BzLFxuICAgIHByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgIGFib3J0U2lnbmFsOiBzaWduYWwsXG4gICAgY29tcG9zaXRpb25JZCxcbiAgICBpc1JlbmRlcmluZzogZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nXG4gIH0pIDogbnVsbDtcbiAgaWYgKGNhbGN1bGF0ZWRQcm9tICE9PSBudWxsICYmIHR5cGVvZiBjYWxjdWxhdGVkUHJvbSA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiBjYWxjdWxhdGVkUHJvbSkge1xuICAgIHJldHVybiBjYWxjdWxhdGVkUHJvbS50aGVuKChjKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGZwcyxcbiAgICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgICBkZWZhdWx0T3V0TmFtZSxcbiAgICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQsXG4gICAgICAgIGRlZmF1bHRQaXhlbEZvcm1hdCxcbiAgICAgICAgZGVmYXVsdFByb1Jlc1Byb2ZpbGVcbiAgICAgIH0gPSB2YWxpZGF0ZUNhbGN1bGF0ZWQoe1xuICAgICAgICBjYWxjdWxhdGVkOiBjLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgICAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICAgICAgY29tcG9zaXRpb25XaWR0aCxcbiAgICAgICAgY29tcG9zaXRpb25JZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBmcHMsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGlkOiBjb21wb3NpdGlvbklkLFxuICAgICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyksXG4gICAgICAgIHByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhjLnByb3BzID8/IG9yaWdpbmFsUHJvcHMpLFxuICAgICAgICBkZWZhdWx0Q29kZWM6IGRlZmF1bHRDb2RlYyA/PyBudWxsLFxuICAgICAgICBkZWZhdWx0T3V0TmFtZTogZGVmYXVsdE91dE5hbWUgPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0ID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQaXhlbEZvcm1hdDogZGVmYXVsdFBpeGVsRm9ybWF0ID8/IG51bGwsXG4gICAgICAgIGRlZmF1bHRQcm9SZXNQcm9maWxlOiBkZWZhdWx0UHJvUmVzUHJvZmlsZSA/PyBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IGRhdGEgPSB2YWxpZGF0ZUNhbGN1bGF0ZWQoe1xuICAgIGNhbGN1bGF0ZWQ6IGNhbGN1bGF0ZWRQcm9tLFxuICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICBjb21wb3NpdGlvbkZwcyxcbiAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgIGNvbXBvc2l0aW9uSWRcbiAgfSk7XG4gIGlmIChjYWxjdWxhdGVkUHJvbSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kYXRhLFxuICAgICAgaWQ6IGNvbXBvc2l0aW9uSWQsXG4gICAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgICBwcm9wczogc2VyaWFsaXplVGhlbkRlc2VyaWFsaXplSW5TdHVkaW8ob3JpZ2luYWxQcm9wcyksXG4gICAgICBkZWZhdWx0Q29kZWM6IG51bGwsXG4gICAgICBkZWZhdWx0T3V0TmFtZTogbnVsbCxcbiAgICAgIGRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0OiBudWxsLFxuICAgICAgZGVmYXVsdFBpeGVsRm9ybWF0OiBudWxsLFxuICAgICAgZGVmYXVsdFByb1Jlc1Byb2ZpbGU6IG51bGxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGF0YSxcbiAgICBpZDogY29tcG9zaXRpb25JZCxcbiAgICBkZWZhdWx0UHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGRlZmF1bHRQcm9wcyA/PyB7fSksXG4gICAgcHJvcHM6IHNlcmlhbGl6ZVRoZW5EZXNlcmlhbGl6ZUluU3R1ZGlvKGNhbGN1bGF0ZWRQcm9tLnByb3BzID8/IG9yaWdpbmFsUHJvcHMpLFxuICAgIGRlZmF1bHRDb2RlYzogY2FsY3VsYXRlZFByb20uZGVmYXVsdENvZGVjID8/IG51bGwsXG4gICAgZGVmYXVsdE91dE5hbWU6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRPdXROYW1lID8/IG51bGwsXG4gICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IGNhbGN1bGF0ZWRQcm9tLmRlZmF1bHRWaWRlb0ltYWdlRm9ybWF0ID8/IG51bGwsXG4gICAgZGVmYXVsdFBpeGVsRm9ybWF0OiBjYWxjdWxhdGVkUHJvbS5kZWZhdWx0UGl4ZWxGb3JtYXQgPz8gbnVsbCxcbiAgICBkZWZhdWx0UHJvUmVzUHJvZmlsZTogY2FsY3VsYXRlZFByb20uZGVmYXVsdFByb1Jlc1Byb2ZpbGUgPz8gbnVsbFxuICB9O1xufTtcbnZhciByZXNvbHZlVmlkZW9Db25maWdPckNhdGNoID0gKHBhcmFtcykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb21pc2VPclJldHVyblZhbHVlID0gcmVzb2x2ZVZpZGVvQ29uZmlnKHBhcmFtcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgcmVzdWx0OiBwcm9taXNlT3JSZXR1cm5WYWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICBlcnJvcjogZXJyXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL1Jlc29sdmVDb21wb3NpdGlvbkNvbmZpZy50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3g1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ3KG51bGwpO1xudmFyIHJlc29sdmVDb21wb3NpdGlvbnNSZWYgPSBjcmVhdGVSZWYoKTtcbnZhciBuZWVkc1Jlc29sdXRpb24gPSAoY29tcG9zaXRpb24pID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4oY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEpO1xufTtcbnZhciBQUk9QU19VUERBVEVEX0VYVEVSTkFMTFkgPSBcInJlbW90aW9uLnByb3BzVXBkYXRlZEV4dGVybmFsbHlcIjtcbnZhciBSZXNvbHZlQ29tcG9zaXRpb25Db25maWcgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtjdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbiwgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb25dID0gdXNlU3RhdGU0KG51bGwpO1xuICBjb25zdCB7IGNvbXBvc2l0aW9ucywgY2FudmFzQ29udGVudCwgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHsgZmFzdFJlZnJlc2hlcywgbWFudWFsUmVmcmVzaGVzIH0gPSB1c2VDb250ZXh0NChOb25jZUNvbnRleHQpO1xuICBpZiAobWFudWFsUmVmcmVzaGVzKSB7fVxuICBjb25zdCBzZWxlY3RlZENvbXBvc2l0aW9uID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudCAmJiBjYW52YXNDb250ZW50LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiAmJiBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgPT09IGMuaWQpO1xuICB9LCBbY2FudmFzQ29udGVudCwgY29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24pO1xuICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dDQoRWRpdG9yUHJvcHNDb250ZXh0KTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBpbnB1dFByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGVudi5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9O1xuICB9LCBbZW52LmlzUGxheWVyXSk7XG4gIGNvbnN0IFtyZXNvbHZlZENvbmZpZ3MsIHNldFJlc29sdmVkQ29uZmlnc10gPSB1c2VTdGF0ZTQoe30pO1xuICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RlZENvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbc2VsZWN0ZWRDb21wb3NpdGlvbi5pZF0gPz8ge30gOiB7fTtcbiAgfSwgW2FsbEVkaXRvclByb3BzLCBzZWxlY3RlZENvbXBvc2l0aW9uXSk7XG4gIGNvbnN0IHJlbmRlck1vZGFsUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHJlbmRlck1vZGFsQ29tcG9zaXRpb24gPyBhbGxFZGl0b3JQcm9wc1tyZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkXSA/PyB7fSA6IHt9O1xuICB9LCBbYWxsRWRpdG9yUHJvcHMsIHJlbmRlck1vZGFsQ29tcG9zaXRpb25dKTtcbiAgY29uc3QgaGFzUmVzb2x1dGlvbiA9IEJvb2xlYW4oY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpO1xuICBjb25zdCBkb1Jlc29sdXRpb24gPSB1c2VDYWxsYmFjazMoKHtcbiAgICBjYWxjdWxhdGVNZXRhZGF0YSxcbiAgICBjb21iaW5lZFByb3BzLFxuICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICBjb21wb3NpdGlvbkZwcyxcbiAgICBjb21wb3NpdGlvbkhlaWdodCxcbiAgICBjb21wb3NpdGlvbklkLFxuICAgIGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgZGVmYXVsdFByb3BzXG4gIH0pID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBpZiAoaGFzUmVzb2x1dGlvbikge1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBjb250cm9sbGVyO1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVWaWRlb0NvbmZpZ09yQ2F0Y2goe1xuICAgICAgY29tcG9zaXRpb25JZCxcbiAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgb3JpZ2luYWxQcm9wczogY29tYmluZWRQcm9wcyxcbiAgICAgIHNpZ25hbCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIGNvbXBvc2l0aW9uRHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGNvbXBvc2l0aW9uRnBzLFxuICAgICAgY29tcG9zaXRpb25IZWlnaHQsXG4gICAgICBjb21wb3NpdGlvbldpZHRoXG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgLi4ucixcbiAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgIGVycm9yOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGNvbnN0IHByb21Pck5vdCA9IHJlc3VsdC5yZXN1bHQ7XG4gICAgaWYgKHR5cGVvZiBwcm9tT3JOb3QgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gcHJvbU9yTm90KSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+IHtcbiAgICAgICAgY29uc3QgcHJldiA9IHJbY29tcG9zaXRpb25JZF07XG4gICAgICAgIGlmIChwcmV2Py50eXBlID09PSBcInN1Y2Nlc3NcIiB8fCBwcmV2Py50eXBlID09PSBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIikge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yLFxuICAgICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3VjY2Vzcy1hbmQtcmVmcmVzaGluZ1wiLFxuICAgICAgICAgICAgICByZXN1bHQ6IHByZXYucmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcImxvYWRpbmdcIlxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcHJvbU9yTm90LnRoZW4oKGMpID0+IHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVzb2x2ZWRDb25maWdzKChyKSA9PiAoe1xuICAgICAgICAgIC4uLnIsXG4gICAgICAgICAgW2NvbXBvc2l0aW9uSWRdOiB7XG4gICAgICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIHJlc3VsdDogY1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgICAgLi4ucixcbiAgICAgICAgICBbY29tcG9zaXRpb25JZF06IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgIC4uLnIsXG4gICAgICAgIFtjb21wb3NpdGlvbklkXToge1xuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgIHJlc3VsdDogcHJvbU9yTm90XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xsZXI7XG4gIH0sIFtoYXNSZXNvbHV0aW9uXSk7XG4gIGNvbnN0IGN1cnJlbnRDb21wb3NpdGlvbiA9IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGw7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUyKHJlc29sdmVDb21wb3NpdGlvbnNSZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0Q3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb246IChpZCkgPT4ge1xuICAgICAgICBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbihpZCk7XG4gICAgICB9LFxuICAgICAgcmVsb2FkQ3VycmVudGx5U2VsZWN0ZWRDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjLmlkID09PSBjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgICBpZiAoIWNvbXBvc2l0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y3VycmVudENvbXBvc2l0aW9ufWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvclByb3BzID0gYWxsRWRpdG9yUHJvcHNbY3VycmVudENvbXBvc2l0aW9uXSA/PyB7fTtcbiAgICAgICAgY29uc3QgZGVmYXVsdFByb3BzID0ge1xuICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAuLi5lZGl0b3JQcm9wcyA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgICAgLi4uaW5wdXRQcm9wcyA/PyB7fVxuICAgICAgICB9O1xuICAgICAgICBkb1Jlc29sdXRpb24oe1xuICAgICAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgICAgICAgY29tYmluZWRQcm9wczogcHJvcHMsXG4gICAgICAgICAgY29tcG9zaXRpb25EdXJhdGlvbkluRnJhbWVzOiBjb21wb3NpdGlvbi5kdXJhdGlvbkluRnJhbWVzID8/IG51bGwsXG4gICAgICAgICAgY29tcG9zaXRpb25GcHM6IGNvbXBvc2l0aW9uLmZwcyA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQgPz8gbnVsbCxcbiAgICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBjb21wb3NpdGlvbi53aWR0aCA/PyBudWxsLFxuICAgICAgICAgIGNvbXBvc2l0aW9uSWQ6IGNvbXBvc2l0aW9uLmlkXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtcbiAgICBhbGxFZGl0b3JQcm9wcyxcbiAgICBjb21wb3NpdGlvbnMsXG4gICAgY3VycmVudENvbXBvc2l0aW9uLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBpbnB1dFByb3BzXG4gIF0pO1xuICBjb25zdCBpc1RoZVNhbWUgPSBzZWxlY3RlZENvbXBvc2l0aW9uPy5pZCA9PT0gcmVuZGVyTW9kYWxDb21wb3NpdGlvbj8uaWQ7XG4gIGNvbnN0IGN1cnJlbnREZWZhdWx0UHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnNlbGVjdGVkQ29tcG9zaXRpb24/LmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge31cbiAgICB9O1xuICB9LCBbc2VsZWN0ZWRDb21wb3NpdGlvbj8uZGVmYXVsdFByb3BzLCBzZWxlY3RlZEVkaXRvclByb3BzXSk7XG4gIGNvbnN0IG9yaWdpbmFsUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmN1cnJlbnREZWZhdWx0UHJvcHMsXG4gICAgICAuLi5pbnB1dFByb3BzID8/IHt9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnREZWZhdWx0UHJvcHMsIGlucHV0UHJvcHNdKTtcbiAgY29uc3QgY2FuUmVzb2x2ZSA9IHNlbGVjdGVkQ29tcG9zaXRpb24gJiYgbmVlZHNSZXNvbHV0aW9uKHNlbGVjdGVkQ29tcG9zaXRpb24pO1xuICBjb25zdCBzaG91bGRJZ25vcmVVcGRhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5yZW1vdGlvbl9pZ25vcmVGYXN0UmVmcmVzaFVwZGF0ZSAmJiBmYXN0UmVmcmVzaGVzIDw9IHdpbmRvdy5yZW1vdGlvbl9pZ25vcmVGYXN0UmVmcmVzaFVwZGF0ZTtcbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgaWYgKHNob3VsZElnbm9yZVVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2FuUmVzb2x2ZSkge1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGRvUmVzb2x1dGlvbih7XG4gICAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBzZWxlY3RlZENvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICBjb21iaW5lZFByb3BzOiBvcmlnaW5hbFByb3BzLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXM6IHNlbGVjdGVkQ29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkZwczogc2VsZWN0ZWRDb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IHNlbGVjdGVkQ29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IHNlbGVjdGVkQ29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgICBjb21wb3NpdGlvbklkOiBzZWxlY3RlZENvbXBvc2l0aW9uLmlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgY2FuUmVzb2x2ZSxcbiAgICBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgIGRvUmVzb2x1dGlvbixcbiAgICBvcmlnaW5hbFByb3BzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgc2VsZWN0ZWRDb21wb3NpdGlvbj8uZnBzLFxuICAgIHNlbGVjdGVkQ29tcG9zaXRpb24/LmhlaWdodCxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy5pZCxcbiAgICBzZWxlY3RlZENvbXBvc2l0aW9uPy53aWR0aCxcbiAgICBzaG91bGRJZ25vcmVVcGRhdGVcbiAgXSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGlmIChyZW5kZXJNb2RhbENvbXBvc2l0aW9uICYmICFpc1RoZVNhbWUpIHtcbiAgICAgIGNvbnN0IGNvbWJpbmVkUHJvcHMgPSB7XG4gICAgICAgIC4uLnJlbmRlck1vZGFsQ29tcG9zaXRpb24uZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgICAuLi5yZW5kZXJNb2RhbFByb3BzID8/IHt9LFxuICAgICAgICAuLi5pbnB1dFByb3BzID8/IHt9XG4gICAgICB9O1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGRvUmVzb2x1dGlvbih7XG4gICAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgICAgICBjb21wb3NpdGlvbkR1cmF0aW9uSW5GcmFtZXM6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyA/PyBudWxsLFxuICAgICAgICBjb21wb3NpdGlvbkZwczogcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5mcHMgPz8gbnVsbCxcbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uaGVpZ2h0ID8/IG51bGwsXG4gICAgICAgIGNvbXBvc2l0aW9uSWQ6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24uaWQsXG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IHJlbmRlck1vZGFsQ29tcG9zaXRpb24ud2lkdGggPz8gbnVsbCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiBjdXJyZW50RGVmYXVsdFByb3BzLFxuICAgICAgICBjb21iaW5lZFByb3BzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbXG4gICAgY3VycmVudERlZmF1bHRQcm9wcyxcbiAgICBkb1Jlc29sdXRpb24sXG4gICAgaW5wdXRQcm9wcyxcbiAgICBpc1RoZVNhbWUsXG4gICAgcmVuZGVyTW9kYWxDb21wb3NpdGlvbixcbiAgICByZW5kZXJNb2RhbFByb3BzXG4gIF0pO1xuICBjb25zdCByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzID0gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRpY0NvbXBzID0gY29tcG9zaXRpb25zLmZpbHRlcigoYykgPT4ge1xuICAgICAgcmV0dXJuIGMuY2FsY3VsYXRlTWV0YWRhdGEgPT09IG51bGw7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkQ29uZmlncyxcbiAgICAgIC4uLnN0YXRpY0NvbXBzLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uYWNjLFxuICAgICAgICAgIFtjdXJyLmlkXToge1xuICAgICAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICByZXN1bHQ6IHsgLi4uY3VyciwgZGVmYXVsdFByb3BzOiBjdXJyLmRlZmF1bHRQcm9wcyA/PyB7fSB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSwge30pXG4gICAgfTtcbiAgfSwgW2NvbXBvc2l0aW9ucywgcmVzb2x2ZWRDb25maWdzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4NShSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZVJlc29sdmVkVmlkZW9Db25maWcgPSAocHJlZmVycmVkQ29tcG9zaXRpb25JZCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gIGNvbnN0IHsgcHJvcHM6IGFsbEVkaXRvclByb3BzIH0gPSB1c2VDb250ZXh0NChFZGl0b3JQcm9wc0NvbnRleHQpO1xuICBjb25zdCB7IGNvbXBvc2l0aW9ucywgY2FudmFzQ29udGVudCwgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IGN1cnJlbnRDb21wb3NpdGlvbiA9IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGw7XG4gIGNvbnN0IGNvbXBvc2l0aW9uSWQgPSBwcmVmZXJyZWRDb21wb3NpdGlvbklkID8/IGN1cnJlbnRDb21wb3NpdGlvbjtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gYy5pZCA9PT0gY29tcG9zaXRpb25JZCk7XG4gIGNvbnN0IHNlbGVjdGVkRWRpdG9yUHJvcHMgPSB1c2VNZW1vNCgoKSA9PiB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uID8gYWxsRWRpdG9yUHJvcHNbY29tcG9zaXRpb24uaWRdID8/IHt9IDoge307XG4gIH0sIFthbGxFZGl0b3JQcm9wcywgY29tcG9zaXRpb25dKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICByZXR1cm4gdXNlTWVtbzQoKCkgPT4ge1xuICAgIGlmICghY29tcG9zaXRpb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAuLi5jdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgICAgICBpZDogY29tcG9zaXRpb24uaWQsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge31cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFuZWVkc1Jlc29sdXRpb24oY29tcG9zaXRpb24pKSB7XG4gICAgICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMoY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcywge1xuICAgICAgICBhbGxvd0Zsb2F0czogZmFsc2UsXG4gICAgICAgIGNvbXBvbmVudDogYGluIDxDb21wb3NpdGlvbiBpZD1cIiR7Y29tcG9zaXRpb24uaWR9XCI+YFxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZUZwcyhjb21wb3NpdGlvbi5mcHMsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmAsIGZhbHNlKTtcbiAgICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uLndpZHRoLCBcIndpZHRoXCIsIGBpbiA8Q29tcG9zaXRpb24gaWQ9XCIke2NvbXBvc2l0aW9uLmlkfVwiPmApO1xuICAgICAgdmFsaWRhdGVEaW1lbnNpb24oY29tcG9zaXRpb24uaGVpZ2h0LCBcImhlaWdodFwiLCBgaW4gPENvbXBvc2l0aW9uIGlkPVwiJHtjb21wb3NpdGlvbi5pZH1cIj5gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICB3aWR0aDogY29tcG9zaXRpb24ud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjb21wb3NpdGlvbi5oZWlnaHQsXG4gICAgICAgICAgZnBzOiBjb21wb3NpdGlvbi5mcHMsXG4gICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgZGVmYXVsdFByb3BzOiBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMgPz8ge30sXG4gICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIC4uLmNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcyA/PyB7fSxcbiAgICAgICAgICAgIC4uLnNlbGVjdGVkRWRpdG9yUHJvcHMgPz8ge30sXG4gICAgICAgICAgICAuLi50eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8IGVudi5pc1BsYXllciA/IHt9IDogZ2V0SW5wdXRQcm9wcygpID8/IHt9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZhdWx0Q29kZWM6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdE91dE5hbWU6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgZGVmYXVsdFBpeGVsRm9ybWF0OiBudWxsLFxuICAgICAgICAgIGRlZmF1bHRQcm9SZXNQcm9maWxlOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghY29udGV4dFtjb21wb3NpdGlvbi5pZF0pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dFtjb21wb3NpdGlvbi5pZF07XG4gIH0sIFtcbiAgICBjb21wb3NpdGlvbixcbiAgICBjb250ZXh0LFxuICAgIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgIHNlbGVjdGVkRWRpdG9yUHJvcHMsXG4gICAgZW52LmlzUGxheWVyXG4gIF0pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby50c1xudmFyIHVzZVZpZGVvID0gKCkgPT4ge1xuICBjb25zdCB7IGNhbnZhc0NvbnRlbnQsIGNvbXBvc2l0aW9ucywgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgfSA9IHVzZUNvbnRleHQ1KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gIGNvbnN0IHNlbGVjdGVkID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IHtcbiAgICByZXR1cm4gY2FudmFzQ29udGVudD8udHlwZSA9PT0gXCJjb21wb3NpdGlvblwiICYmIGMuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZDtcbiAgfSk7XG4gIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhzZWxlY3RlZD8uaWQgPz8gbnVsbCk7XG4gIHJldHVybiB1c2VNZW1vNSgoKSA9PiB7XG4gICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzb2x2ZWQudHlwZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc29sdmVkLnJlc3VsdCxcbiAgICAgIGRlZmF1bHRQcm9wczogc2VsZWN0ZWQuZGVmYXVsdFByb3BzID8/IHt9LFxuICAgICAgaWQ6IHNlbGVjdGVkLmlkLFxuICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgPz8ge30sXG4gICAgICBjb21wb25lbnQ6IHNlbGVjdGVkLmNvbXBvbmVudFxuICAgIH07XG4gIH0sIFtjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgcmVzb2x2ZWQsIHNlbGVjdGVkXSk7XG59O1xuXG4vLyBzcmMvdGltZWxpbmUtcG9zaXRpb24tc3RhdGUudHNcbnZhciBUaW1lbGluZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0OCh7XG4gIGZyYW1lOiB7fSxcbiAgcGxheWluZzogZmFsc2UsXG4gIHBsYXliYWNrUmF0ZTogMSxcbiAgcm9vdElkOiBcIlwiLFxuICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgIGN1cnJlbnQ6IGZhbHNlXG4gIH0sXG4gIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHRcIik7XG4gIH0sXG4gIGF1ZGlvQW5kVmlkZW9UYWdzOiB7IGN1cnJlbnQ6IFtdIH1cbn0pO1xudmFyIFNldFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ4KHtcbiAgc2V0RnJhbWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9LFxuICBzZXRQbGF5aW5nOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfVxufSk7XG52YXIgbWFrZUtleSA9ICgpID0+IHtcbiAgcmV0dXJuIGByZW1vdGlvbi50aW1lLWFsbGA7XG59O1xudmFyIHBlcnNpc3RDdXJyZW50RnJhbWUgPSAodGltZSkgPT4ge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShtYWtlS2V5KCksIEpTT04uc3RyaW5naWZ5KHRpbWUpKTtcbn07XG52YXIgZ2V0SW5pdGlhbEZyYW1lU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShtYWtlS2V5KCkpID8/IFwie31cIjtcbiAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgcmV0dXJuIG9iajtcbn07XG52YXIgZ2V0RnJhbWVGb3JDb21wb3NpdGlvbiA9IChjb21wb3NpdGlvbikgPT4ge1xuICBjb25zdCBpdGVtID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0obWFrZUtleSgpKSA/PyBcInt9XCI7XG4gIGNvbnN0IG9iaiA9IEpTT04ucGFyc2UoaXRlbSk7XG4gIGlmIChvYmpbY29tcG9zaXRpb25dICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gTnVtYmVyKG9ialtjb21wb3NpdGlvbl0pO1xuICB9XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbn07XG52YXIgdXNlVGltZWxpbmVQb3NpdGlvbiA9ICgpID0+IHtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlbygpO1xuICBjb25zdCBzdGF0ZSA9IHVzZUNvbnRleHQ2KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gMCA6IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUgPz8gMDtcbiAgfVxuICBjb25zdCB1bmNsYW1wZWQgPSBzdGF0ZS5mcmFtZVt2aWRlb0NvbmZpZy5pZF0gPz8gKGVudi5pc1BsYXllciA/IDAgOiBnZXRGcmFtZUZvckNvbXBvc2l0aW9uKHZpZGVvQ29uZmlnLmlkKSk7XG4gIHJldHVybiBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gMSwgdW5jbGFtcGVkKTtcbn07XG52YXIgdXNlVGltZWxpbmVTZXRGcmFtZSA9ICgpID0+IHtcbiAgY29uc3QgeyBzZXRGcmFtZSB9ID0gdXNlQ29udGV4dDYoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgcmV0dXJuIHNldEZyYW1lO1xufTtcbnZhciB1c2VQbGF5aW5nU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgcGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQ2KFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0UGxheWluZyB9ID0gdXNlQ29udGV4dDYoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgcmV0dXJuIHVzZU1lbW82KCgpID0+IFtwbGF5aW5nLCBzZXRQbGF5aW5nLCBpbXBlcmF0aXZlUGxheWluZ10sIFtpbXBlcmF0aXZlUGxheWluZywgcGxheWluZywgc2V0UGxheWluZ10pO1xufTtcblxuLy8gc3JjL3VzZS12aWRlby1jb25maWcudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDggfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL0NhblVzZVJlbW90aW9uSG9va3MudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQ5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4NiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIENhblVzZVJlbW90aW9uSG9va3MgPSBjcmVhdGVDb250ZXh0OShmYWxzZSk7XG52YXIgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDYoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cnVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL3VzZS11bnNhZmUtdmlkZW8tY29uZmlnLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQ3LCB1c2VNZW1vIGFzIHVzZU1lbW83IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlVW5zYWZlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0NyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjdHhXaWR0aCA9IGNvbnRleHQ/LndpZHRoID8/IG51bGw7XG4gIGNvbnN0IGN0eEhlaWdodCA9IGNvbnRleHQ/LmhlaWdodCA/PyBudWxsO1xuICBjb25zdCBjdHhEdXJhdGlvbiA9IGNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXMgPz8gbnVsbDtcbiAgY29uc3QgdmlkZW8gPSB1c2VWaWRlbygpO1xuICByZXR1cm4gdXNlTWVtbzcoKCkgPT4ge1xuICAgIGlmICghdmlkZW8pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aCxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHByb3BzLFxuICAgICAgZGVmYXVsdENvZGVjLFxuICAgICAgZGVmYXVsdE91dE5hbWUsXG4gICAgICBkZWZhdWx0VmlkZW9JbWFnZUZvcm1hdCxcbiAgICAgIGRlZmF1bHRQaXhlbEZvcm1hdCxcbiAgICAgIGRlZmF1bHRQcm9SZXNQcm9maWxlXG4gICAgfSA9IHZpZGVvO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHdpZHRoOiBjdHhXaWR0aCA/PyB3aWR0aCxcbiAgICAgIGhlaWdodDogY3R4SGVpZ2h0ID8/IGhlaWdodCxcbiAgICAgIGZwcyxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGN0eER1cmF0aW9uID8/IGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBkZWZhdWx0UHJvcHMsXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRDb2RlYyxcbiAgICAgIGRlZmF1bHRPdXROYW1lLFxuICAgICAgZGVmYXVsdFZpZGVvSW1hZ2VGb3JtYXQsXG4gICAgICBkZWZhdWx0UGl4ZWxGb3JtYXQsXG4gICAgICBkZWZhdWx0UHJvUmVzUHJvZmlsZVxuICAgIH07XG4gIH0sIFtjdHhEdXJhdGlvbiwgY3R4SGVpZ2h0LCBjdHhXaWR0aCwgdmlkZW9dKTtcbn07XG5cbi8vIHNyYy91c2UtdmlkZW8tY29uZmlnLnRzXG52YXIgdXNlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQ4KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBjb25zdCBpc1BsYXllciA9IHVzZUlzUGxheWVyKCk7XG4gIGlmICghdmlkZW9Db25maWcpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgfHwgaXNQbGF5ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgIFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kLiBMaWtlbHkgcmVhc29uczpcIixcbiAgICAgICAgXCItIFlvdSBhcmUgcHJvYmFibHkgY2FsbGluZyB1c2VWaWRlb0NvbmZpZygpIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50IHBhc3NlZCB0byA8UGxheWVyIC8+LiBTZWUgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2V4YW1wbGVzIGZvciBob3cgdG8gc2V0IHVwIHRoZSBQbGF5ZXIgY29ycmVjdGx5LlwiLFxuICAgICAgICBcIi0gWW91IGhhdmUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgUmVtb3Rpb24gaW5zdGFsbGVkIHdoaWNoIGNhdXNlcyB0aGUgUmVhY3QgY29udGV4dCB0byBnZXQgbG9zdC5cIlxuICAgICAgXS5qb2luKFwiLVwiKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZC4gWW91IGFyZSBwcm9iYWJseSBjYWxsaW5nIHVzZVZpZGVvQ29uZmlnKCkgZnJvbSBhIGNvbXBvbmVudCB3aGljaCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCBhcyBhIDxDb21wb3NpdGlvbiAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcbiAgfVxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsZWQgdXNlVmlkZW9Db25maWcoKSBvdXRzaWRlIGEgUmVtb3Rpb24gY29tcG9zaXRpb24uXCIpO1xuICB9XG4gIHJldHVybiB2aWRlb0NvbmZpZztcbn07XG5cbi8vIHNyYy9mcmVlemUudHN4XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMCwgdXNlTWVtbyBhcyB1c2VNZW1vOCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtZnJhbWUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDkgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VDdXJyZW50RnJhbWUgPSAoKSA9PiB7XG4gIGNvbnN0IGNhblVzZVJlbW90aW9uSG9va3MgPSB1c2VDb250ZXh0OShDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBpZiAoIWNhblVzZVJlbW90aW9uSG9va3MpIHtcbiAgICBpZiAoZW52LmlzUGxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVzZUN1cnJlbnRGcmFtZSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCB0byA8UGxheWVyPi4gU2VlOiBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXNgKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUoKSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjb21wb3NpdGlvbi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zYCk7XG4gIH1cbiAgY29uc3QgZnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0OShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBjb250ZXh0T2Zmc2V0ID0gY29udGV4dCA/IGNvbnRleHQuY3VtdWxhdGVkRnJvbSArIGNvbnRleHQucmVsYXRpdmVGcm9tIDogMDtcbiAgcmV0dXJuIGZyYW1lIC0gY29udGV4dE9mZnNldDtcbn07XG5cbi8vIHNyYy9mcmVlemUudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4NyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEZyZWV6ZSA9ICh7XG4gIGZyYW1lOiBmcmFtZVRvRnJlZXplLFxuICBjaGlsZHJlbixcbiAgYWN0aXZlID0gdHJ1ZVxufSkgPT4ge1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGlmICh0eXBlb2YgZnJhbWVUb0ZyZWV6ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIDxGcmVlemUgLz4gY29tcG9uZW50IHJlcXVpcmVzIGEgJ2ZyYW1lJyBwcm9wLCBidXQgbm9uZSB3YXMgcGFzc2VkLmApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJhbWVUb0ZyZWV6ZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdmcmFtZScgcHJvcCBvZiA8RnJlZXplIC8+IG11c3QgYmUgYSBudW1iZXIsIGJ1dCBpcyBvZiB0eXBlICR7dHlwZW9mIGZyYW1lVG9GcmVlemV9YCk7XG4gIH1cbiAgaWYgKE51bWJlci5pc05hTihmcmFtZVRvRnJlZXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdmcmFtZScgcHJvcCBvZiA8RnJlZXplIC8+IG11c3QgYmUgYSByZWFsIG51bWJlciwgYnV0IGl0IGlzIE5hTi5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZVRvRnJlZXplKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdmcmFtZScgcHJvcCBvZiA8RnJlZXplIC8+IG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyLCBidXQgaXQgaXMgJHtmcmFtZVRvRnJlZXplfS5gKTtcbiAgfVxuICBjb25zdCBpc0FjdGl2ZSA9IHVzZU1lbW84KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIGFjdGl2ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiBhY3RpdmU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYWN0aXZlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBhY3RpdmUoZnJhbWUpO1xuICAgIH1cbiAgfSwgW2FjdGl2ZSwgZnJhbWVdKTtcbiAgY29uc3QgdGltZWxpbmVDb250ZXh0ID0gdXNlQ29udGV4dDEwKFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQxMChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCByZWxhdGl2ZUZyb20gPSBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSA/PyAwO1xuICBjb25zdCB0aW1lbGluZVZhbHVlID0gdXNlTWVtbzgoKCkgPT4ge1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiB0aW1lbGluZUNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi50aW1lbGluZUNvbnRleHQsXG4gICAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nOiB7XG4gICAgICAgIGN1cnJlbnQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZnJhbWU6IHtcbiAgICAgICAgW3ZpZGVvQ29uZmlnLmlkXTogZnJhbWVUb0ZyZWV6ZSArIHJlbGF0aXZlRnJvbVxuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc0FjdGl2ZSwgdGltZWxpbmVDb250ZXh0LCB2aWRlb0NvbmZpZy5pZCwgZnJhbWVUb0ZyZWV6ZSwgcmVsYXRpdmVGcm9tXSk7XG4gIGNvbnN0IG5ld1NlcXVlbmNlQ29udGV4dCA9IHVzZU1lbW84KCgpID0+IHtcbiAgICBpZiAoIXNlcXVlbmNlQ29udGV4dCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgIHJldHVybiBzZXF1ZW5jZUNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5zZXF1ZW5jZUNvbnRleHQsXG4gICAgICByZWxhdGl2ZUZyb206IDAsXG4gICAgICBjdW11bGF0ZWRGcm9tOiAwXG4gICAgfTtcbiAgfSwgW3NlcXVlbmNlQ29udGV4dCwgaXNBY3RpdmVdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3g3KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0aW1lbGluZVZhbHVlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4NyhTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBuZXdTZXF1ZW5jZUNvbnRleHQsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL1NlcXVlbmNlLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAoe1xuICBmcm9tID0gMCxcbiAgZHVyYXRpb25JbkZyYW1lcyA9IEluZmluaXR5LFxuICBjaGlsZHJlbixcbiAgbmFtZSxcbiAgaGVpZ2h0LFxuICB3aWR0aCxcbiAgc2hvd0luVGltZWxpbmUgPSB0cnVlLFxuICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2ssXG4gIF9yZW1vdGlvbkludGVybmFsUHJlbW91bnREaXNwbGF5OiBwcmVtb3VudERpc3BsYXksXG4gIF9yZW1vdGlvbkludGVybmFsUG9zdG1vdW50RGlzcGxheTogcG9zdG1vdW50RGlzcGxheSxcbiAgLi4ub3RoZXJcbn0sIHJlZikgPT4ge1xuICBjb25zdCB7IGxheW91dCA9IFwiYWJzb2x1dGUtZmlsbFwiIH0gPSBvdGhlcjtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlNSgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxMShTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB7IHJvb3RJZCB9ID0gdXNlQ29udGV4dDExKFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IGN1bXVsYXRlZEZyb20gPSBwYXJlbnRTZXF1ZW5jZSA/IHBhcmVudFNlcXVlbmNlLmN1bXVsYXRlZEZyb20gKyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gOiAwO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGlmIChsYXlvdXQgIT09IFwiYWJzb2x1dGUtZmlsbFwiICYmIGxheW91dCAhPT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgbGF5b3V0IHByb3Agb2YgPFNlcXVlbmNlIC8+IGV4cGVjdHMgZWl0aGVyIFwiYWJzb2x1dGUtZmlsbFwiIG9yIFwibm9uZVwiLCBidXQgeW91IHBhc3NlZDogJHtsYXlvdXR9YCk7XG4gIH1cbiAgaWYgKGxheW91dCA9PT0gXCJub25lXCIgJiYgdHlwZW9mIG90aGVyLnN0eWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgbGF5b3V0PVwibm9uZVwiLCB5b3UgbWF5IG5vdCBwYXNzIGEgc3R5bGUuJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBkdXJhdGlvbkluRnJhbWVzIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkdXJhdGlvbkluRnJhbWVzIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJvbSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgdG8gdGhlIFwiZnJvbVwiIHByb3BzIG9mIHlvdXIgPFNlcXVlbmNlPiBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIGZyb219LCBidXQgaXQgbXVzdCBiZSBhIG51bWJlci5gKTtcbiAgfVxuICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcm9tKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImZyb21cIiBwcm9wIG9mIGEgc2VxdWVuY2UgbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtmcm9tfS5gKTtcbiAgfVxuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlRHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBkdXJhdGlvbkluRnJhbWVzKSA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gZnJvbSwgcGFyZW50U2VxdWVuY2VEdXJhdGlvbikpO1xuICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dDExKFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MTEoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IHByZW1vdW50aW5nID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnRpbmcgfHwgQm9vbGVhbihvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUHJlbW91bnRpbmcpO1xuICB9LCBbb3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nLCBwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnRpbmddKTtcbiAgY29uc3QgcG9zdG1vdW50aW5nID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiBwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nIHx8IEJvb2xlYW4ob3RoZXIuX3JlbW90aW9uSW50ZXJuYWxJc1Bvc3Rtb3VudGluZyk7XG4gIH0sIFtvdGhlci5fcmVtb3Rpb25JbnRlcm5hbElzUG9zdG1vdW50aW5nLCBwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VtdWxhdGVkRnJvbSxcbiAgICAgIHJlbGF0aXZlRnJvbTogZnJvbSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBwYXJlbnRGcm9tOiBwYXJlbnRTZXF1ZW5jZT8ucmVsYXRpdmVGcm9tID8/IDAsXG4gICAgICBpZCxcbiAgICAgIGhlaWdodDogaGVpZ2h0ID8/IHBhcmVudFNlcXVlbmNlPy5oZWlnaHQgPz8gbnVsbCxcbiAgICAgIHdpZHRoOiB3aWR0aCA/PyBwYXJlbnRTZXF1ZW5jZT8ud2lkdGggPz8gbnVsbCxcbiAgICAgIHByZW1vdW50aW5nLFxuICAgICAgcG9zdG1vdW50aW5nLFxuICAgICAgcHJlbW91bnREaXNwbGF5OiBwcmVtb3VudERpc3BsYXkgPz8gbnVsbCxcbiAgICAgIHBvc3Rtb3VudERpc3BsYXk6IHBvc3Rtb3VudERpc3BsYXkgPz8gbnVsbFxuICAgIH07XG4gIH0sIFtcbiAgICBjdW11bGF0ZWRGcm9tLFxuICAgIGZyb20sXG4gICAgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBpZCxcbiAgICBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgcHJlbW91bnRpbmcsXG4gICAgcG9zdG1vdW50aW5nLFxuICAgIHByZW1vdW50RGlzcGxheSxcbiAgICBwb3N0bW91bnREaXNwbGF5XG4gIF0pO1xuICBjb25zdCB0aW1lbGluZUNsaXBOYW1lID0gdXNlTWVtbzkoKCkgPT4ge1xuICAgIHJldHVybiBuYW1lID8/IFwiXCI7XG4gIH0sIFtuYW1lXSk7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgdXNlRWZmZWN0MygoKSA9PiB7XG4gICAgaWYgKCFlbnYuaXNTdHVkaW8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSh7XG4gICAgICBmcm9tLFxuICAgICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBpZCxcbiAgICAgIGRpc3BsYXlOYW1lOiB0aW1lbGluZUNsaXBOYW1lLFxuICAgICAgcGFyZW50OiBwYXJlbnRTZXF1ZW5jZT8uaWQgPz8gbnVsbCxcbiAgICAgIHR5cGU6IFwic2VxdWVuY2VcIixcbiAgICAgIHJvb3RJZCxcbiAgICAgIHNob3dJblRpbWVsaW5lLFxuICAgICAgbm9uY2UsXG4gICAgICBsb29wRGlzcGxheSxcbiAgICAgIHN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgICAgcHJlbW91bnREaXNwbGF5OiBwcmVtb3VudERpc3BsYXkgPz8gbnVsbCxcbiAgICAgIHBvc3Rtb3VudERpc3BsYXk6IHBvc3Rtb3VudERpc3BsYXkgPz8gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyU2VxdWVuY2UoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgIGlkLFxuICAgIG5hbWUsXG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICB0aW1lbGluZUNsaXBOYW1lLFxuICAgIHVucmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICBwYXJlbnRTZXF1ZW5jZT8uaWQsXG4gICAgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyxcbiAgICByb290SWQsXG4gICAgZnJvbSxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBub25jZSxcbiAgICBsb29wRGlzcGxheSxcbiAgICBzdGFjayxcbiAgICBwcmVtb3VudERpc3BsYXksXG4gICAgcG9zdG1vdW50RGlzcGxheSxcbiAgICBlbnYuaXNTdHVkaW9cbiAgXSk7XG4gIGNvbnN0IGVuZFRocmVzaG9sZCA9IE1hdGguY2VpbChjdW11bGF0ZWRGcm9tICsgZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxKTtcbiAgY29uc3QgY29udGVudCA9IGFic29sdXRlRnJhbWUgPCBjdW11bGF0ZWRGcm9tICsgZnJvbSA/IG51bGwgOiBhYnNvbHV0ZUZyYW1lID4gZW5kVGhyZXNob2xkID8gbnVsbCA6IGNoaWxkcmVuO1xuICBjb25zdCBzdHlsZUlmVGhlcmUgPSBvdGhlci5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogb3RoZXIuc3R5bGU7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHVzZU1lbW85KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZmxleERpcmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgLi4ud2lkdGggPyB7IHdpZHRoIH0gOiB7fSxcbiAgICAgIC4uLmhlaWdodCA/IHsgaGVpZ2h0IH0gOiB7fSxcbiAgICAgIC4uLnN0eWxlSWZUaGVyZSA/PyB7fVxuICAgIH07XG4gIH0sIFtoZWlnaHQsIHN0eWxlSWZUaGVyZSwgd2lkdGhdKTtcbiAgaWYgKHJlZiAhPT0gbnVsbCAmJiBsYXlvdXQgPT09IFwibm9uZVwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSXQgaXMgbm90IHN1cHBvcnRlZCB0byBwYXNzIGJvdGggYSBgcmVmYCBhbmQgYGxheW91dD1cIm5vbmVcImAgdG8gPFNlcXVlbmNlIC8+LicpO1xuICB9XG4gIGNvbnN0IGlzU2VxdWVuY2VIaWRkZW4gPSBoaWRkZW5baWRdID8/IGZhbHNlO1xuICBpZiAoaXNTZXF1ZW5jZUhpZGRlbikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuOiBjb250ZW50ID09PSBudWxsID8gbnVsbCA6IG90aGVyLmxheW91dCA9PT0gXCJub25lXCIgPyBjb250ZW50IDogLyogQF9fUFVSRV9fICovIGpzeDgoQWJzb2x1dGVGaWxsLCB7XG4gICAgICByZWYsXG4gICAgICBzdHlsZTogZGVmYXVsdFN0eWxlLFxuICAgICAgY2xhc3NOYW1lOiBvdGhlci5jbGFzc05hbWUsXG4gICAgICBjaGlsZHJlbjogY29udGVudFxuICAgIH0pXG4gIH0pO1xufTtcbnZhciBSZWd1bGFyU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihSZWd1bGFyU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xudmFyIFByZW1vdW50ZWRQb3N0bW91bnRlZFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgaWYgKHByb3BzLmxheW91dCA9PT0gXCJub25lXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2A8U2VxdWVuY2U+YCB3aXRoIGBwcmVtb3VudEZvcmAgYW5kIGBwb3N0bW91bnRGb3JgIHByb3BzIGRvZXMgbm90IHN1cHBvcnQgbGF5b3V0PVwibm9uZVwiJyk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHN0eWxlOiBwYXNzZWRTdHlsZSxcbiAgICBmcm9tID0gMCxcbiAgICBkdXJhdGlvbkluRnJhbWVzID0gSW5maW5pdHksXG4gICAgcHJlbW91bnRGb3IgPSAwLFxuICAgIHBvc3Rtb3VudEZvciA9IDAsXG4gICAgc3R5bGVXaGlsZVByZW1vdW50ZWQsXG4gICAgc3R5bGVXaGlsZVBvc3Rtb3VudGVkLFxuICAgIC4uLm90aGVyUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBlbmRUaHJlc2hvbGQgPSBNYXRoLmNlaWwoZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxKTtcbiAgY29uc3QgcHJlbW91bnRpbmdBY3RpdmUgPSBmcmFtZSA8IGZyb20gJiYgZnJhbWUgPj0gZnJvbSAtIHByZW1vdW50Rm9yO1xuICBjb25zdCBwb3N0bW91bnRpbmdBY3RpdmUgPSBmcmFtZSA+IGVuZFRocmVzaG9sZCAmJiBmcmFtZSA8PSBlbmRUaHJlc2hvbGQgKyBwb3N0bW91bnRGb3I7XG4gIGNvbnN0IGZyZWV6ZUZyYW1lID0gcHJlbW91bnRpbmdBY3RpdmUgPyBmcm9tIDogcG9zdG1vdW50aW5nQWN0aXZlID8gZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxIDogMDtcbiAgY29uc3QgaXNGcmVlemluZ0FjdGl2ZSA9IHByZW1vdW50aW5nQWN0aXZlIHx8IHBvc3Rtb3VudGluZ0FjdGl2ZTtcbiAgY29uc3Qgc3R5bGUgPSB1c2VNZW1vOSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBhc3NlZFN0eWxlLFxuICAgICAgb3BhY2l0eTogcHJlbW91bnRpbmdBY3RpdmUgfHwgcG9zdG1vdW50aW5nQWN0aXZlID8gMCA6IDEsXG4gICAgICBwb2ludGVyRXZlbnRzOiBwcmVtb3VudGluZ0FjdGl2ZSB8fCBwb3N0bW91bnRpbmdBY3RpdmUgPyBcIm5vbmVcIiA6IHBhc3NlZFN0eWxlPy5wb2ludGVyRXZlbnRzID8/IHVuZGVmaW5lZCxcbiAgICAgIC4uLnByZW1vdW50aW5nQWN0aXZlID8gc3R5bGVXaGlsZVByZW1vdW50ZWQgOiB7fSxcbiAgICAgIC4uLnBvc3Rtb3VudGluZ0FjdGl2ZSA/IHN0eWxlV2hpbGVQb3N0bW91bnRlZCA6IHt9XG4gICAgfTtcbiAgfSwgW1xuICAgIHBhc3NlZFN0eWxlLFxuICAgIHByZW1vdW50aW5nQWN0aXZlLFxuICAgIHBvc3Rtb3VudGluZ0FjdGl2ZSxcbiAgICBzdHlsZVdoaWxlUHJlbW91bnRlZCxcbiAgICBzdHlsZVdoaWxlUG9zdG1vdW50ZWRcbiAgXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChGcmVlemUsIHtcbiAgICBmcmFtZTogZnJlZXplRnJhbWUsXG4gICAgYWN0aXZlOiBpc0ZyZWV6aW5nQWN0aXZlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4OChTZXF1ZW5jZSwge1xuICAgICAgcmVmLFxuICAgICAgZnJvbSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICBzdHlsZSxcbiAgICAgIF9yZW1vdGlvbkludGVybmFsUHJlbW91bnREaXNwbGF5OiBwcmVtb3VudEZvcixcbiAgICAgIF9yZW1vdGlvbkludGVybmFsUG9zdG1vdW50RGlzcGxheTogcG9zdG1vdW50Rm9yLFxuICAgICAgX3JlbW90aW9uSW50ZXJuYWxJc1ByZW1vdW50aW5nOiBwcmVtb3VudGluZ0FjdGl2ZSxcbiAgICAgIF9yZW1vdGlvbkludGVybmFsSXNQb3N0bW91bnRpbmc6IHBvc3Rtb3VudGluZ0FjdGl2ZSxcbiAgICAgIC4uLm90aGVyUHJvcHNcbiAgICB9KVxuICB9KTtcbn07XG52YXIgUHJlbW91bnRlZFBvc3Rtb3VudGVkU2VxdWVuY2UgPSBmb3J3YXJkUmVmMihQcmVtb3VudGVkUG9zdG1vdW50ZWRTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG52YXIgU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGlmIChwcm9wcy5sYXlvdXQgIT09IFwibm9uZVwiICYmICFlbnYuaXNSZW5kZXJpbmcpIHtcbiAgICBpZiAocHJvcHMucHJlbW91bnRGb3IgfHwgcHJvcHMucG9zdG1vdW50Rm9yKSB7XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDgoUHJlbW91bnRlZFBvc3Rtb3VudGVkU2VxdWVuY2UsIHtcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIHJlZlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OChSZWd1bGFyU2VxdWVuY2UsIHtcbiAgICAuLi5wcm9wcyxcbiAgICByZWZcbiAgfSk7XG59O1xudmFyIFNlcXVlbmNlID0gZm9yd2FyZFJlZjIoU2VxdWVuY2VSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuLy8gc3JjL2FuaW1hdGVkLWltYWdlL0FuaW1hdGVkSW1hZ2UudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNCxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VSZWYgYXMgdXNlUmVmMyxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGU2XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvY2FuY2VsLXJlbmRlci50c1xudmFyIGlzRXJyb3JMaWtlID0gKGVycikgPT4ge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghKFwic3RhY2tcIiBpbiBlcnIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZXJyLnN0YWNrICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghKFwibWVzc2FnZVwiIGluIGVycikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnIubWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBjYW5jZWxSZW5kZXIoZXJyKSB7XG4gIGxldCBlcnJvcjtcbiAgaWYgKGlzRXJyb3JMaWtlKGVycikpIHtcbiAgICBlcnJvciA9IGVycjtcbiAgICBpZiAoIWVycm9yLnN0YWNrKSB7XG4gICAgICBlcnJvci5zdGFjayA9IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKS5zdGFjaztcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikge1xuICAgIGVycm9yID0gRXJyb3IoZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBlcnJvciA9IEVycm9yKFwiUmVuZGVyaW5nIHdhcyBjYW5jZWxsZWRcIik7XG4gIH1cbiAgd2luZG93LnJlbW90aW9uX2NhbmNlbGxlZEVycm9yID0gZXJyb3Iuc3RhY2s7XG4gIHRocm93IGVycm9yO1xufVxuXG4vLyBzcmMvdXNlLWRlbGF5LXJlbmRlci50c1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9sb2cudHNcbnZhciBsb2dMZXZlbHMgPSBbXCJ0cmFjZVwiLCBcInZlcmJvc2VcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xudmFyIGdldE51bWJlckZvckxvZ0xldmVsID0gKGxldmVsKSA9PiB7XG4gIHJldHVybiBsb2dMZXZlbHMuaW5kZXhPZihsZXZlbCk7XG59O1xudmFyIGlzRXF1YWxPckJlbG93TG9nTGV2ZWwgPSAoY3VycmVudExldmVsLCBsZXZlbCkgPT4ge1xuICByZXR1cm4gZ2V0TnVtYmVyRm9yTG9nTGV2ZWwoY3VycmVudExldmVsKSA8PSBnZXROdW1iZXJGb3JMb2dMZXZlbChsZXZlbCk7XG59O1xudmFyIHRyYW5zZm9ybUFyZ3MgPSAoe1xuICBhcmdzLFxuICBsb2dMZXZlbCxcbiAgdGFnXG59KSA9PiB7XG4gIGNvbnN0IGFyciA9IFsuLi5hcmdzXTtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZyAmJiAhZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzQ2xpZW50U2lkZVJlbmRlcmluZykge1xuICAgIGFyci51bnNoaWZ0KFN5bWJvbC5mb3IoYF9fcmVtb3Rpb25fbGV2ZWxfJHtsb2dMZXZlbH1gKSk7XG4gIH1cbiAgaWYgKHRhZyAmJiBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcgJiYgIWdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc0NsaWVudFNpZGVSZW5kZXJpbmcpIHtcbiAgICBhcnIudW5zaGlmdChTeW1ib2wuZm9yKGBfX3JlbW90aW9uX3RhZ18ke3RhZ31gKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG52YXIgdmVyYm9zZSA9IChvcHRpb25zLCAuLi5hcmdzKSA9PiB7XG4gIGlmIChpc0VxdWFsT3JCZWxvd0xvZ0xldmVsKG9wdGlvbnMubG9nTGV2ZWwsIFwidmVyYm9zZVwiKSkge1xuICAgIHJldHVybiBjb25zb2xlLmRlYnVnKC4uLnRyYW5zZm9ybUFyZ3MoeyBhcmdzLCBsb2dMZXZlbDogXCJ2ZXJib3NlXCIsIHRhZzogb3B0aW9ucy50YWcgfSkpO1xuICB9XG59O1xudmFyIHRyYWNlID0gKG9wdGlvbnMsIC4uLmFyZ3MpID0+IHtcbiAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCwgXCJ0cmFjZVwiKSkge1xuICAgIHJldHVybiBjb25zb2xlLmRlYnVnKC4uLnRyYW5zZm9ybUFyZ3MoeyBhcmdzLCBsb2dMZXZlbDogXCJ0cmFjZVwiLCB0YWc6IG9wdGlvbnMudGFnIH0pKTtcbiAgfVxufTtcbnZhciBpbmZvID0gKG9wdGlvbnMsIC4uLmFyZ3MpID0+IHtcbiAgaWYgKGlzRXF1YWxPckJlbG93TG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCwgXCJpbmZvXCIpKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUubG9nKC4uLnRyYW5zZm9ybUFyZ3MoeyBhcmdzLCBsb2dMZXZlbDogXCJpbmZvXCIsIHRhZzogb3B0aW9ucy50YWcgfSkpO1xuICB9XG59O1xudmFyIHdhcm4gPSAob3B0aW9ucywgLi4uYXJncykgPT4ge1xuICBpZiAoaXNFcXVhbE9yQmVsb3dMb2dMZXZlbChvcHRpb25zLmxvZ0xldmVsLCBcIndhcm5cIikpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKC4uLnRyYW5zZm9ybUFyZ3MoeyBhcmdzLCBsb2dMZXZlbDogXCJ3YXJuXCIsIHRhZzogb3B0aW9ucy50YWcgfSkpO1xuICB9XG59O1xudmFyIGVycm9yID0gKG9wdGlvbnMsIC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoLi4udHJhbnNmb3JtQXJncyh7IGFyZ3MsIGxvZ0xldmVsOiBcImVycm9yXCIsIHRhZzogb3B0aW9ucy50YWcgfSkpO1xufTtcbnZhciBMb2cgPSB7XG4gIHRyYWNlLFxuICB2ZXJib3NlLFxuICBpbmZvLFxuICB3YXJuLFxuICBlcnJvclxufTtcblxuLy8gc3JjL2RlbGF5LXJlbmRlci50c1xudmFyIGhhbmRsZXMgPSBbXTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xuICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzKSB7XG4gICAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMgPSB7fTtcbiAgfVxufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiA9IFwiaGFuZGxlIHdhcyBjbGVhcmVkIGFmdGVyXCI7XG52YXIgZGVmYXVsdFRpbWVvdXQgPSAzMDAwMDtcbnZhciBkZWxheVJlbmRlckludGVybmFsID0gKGVudmlyb25tZW50LCBsYWJlbCwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIGxhYmVsICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBsYWJlbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBsYWJlbCBwYXJhbWV0ZXIgb2YgZGVsYXlSZW5kZXIoKSBtdXN0IGJlIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCwgZ290OiBcIiArIEpTT04uc3RyaW5naWZ5KGxhYmVsKSk7XG4gIH1cbiAgY29uc3QgaGFuZGxlID0gTWF0aC5yYW5kb20oKTtcbiAgaGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gIGNvbnN0IGNhbGxlZCA9IEVycm9yKCkuc3RhY2s/LnJlcGxhY2UoL15FcnJvci9nLCBcIlwiKSA/PyBcIlwiO1xuICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICBjb25zdCB0aW1lb3V0VG9Vc2UgPSAob3B0aW9ucz8udGltZW91dEluTWlsbGlzZWNvbmRzID8/ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFRpbWVvdXQgOiB3aW5kb3cucmVtb3Rpb25fcHVwcGV0ZWVyVGltZW91dCA/PyBkZWZhdWx0VGltZW91dCkpIC0gMjAwMDtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3QgcmV0cmllc0xlZnQgPSAob3B0aW9ucz8ucmV0cmllcyA/PyAwKSAtICh3aW5kb3cucmVtb3Rpb25fYXR0ZW1wdCAtIDEpO1xuICAgICAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXSA9IHtcbiAgICAgICAgbGFiZWw6IGxhYmVsID8/IG51bGwsXG4gICAgICAgIHN0YXJ0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZSA9IFtcbiAgICAgICAgICAgIGBBIGRlbGF5UmVuZGVyKClgLFxuICAgICAgICAgICAgbGFiZWwgPyBgXCIke2xhYmVsfVwiYCA6IG51bGwsXG4gICAgICAgICAgICBgd2FzIGNhbGxlZCBidXQgbm90IGNsZWFyZWQgYWZ0ZXIgJHt0aW1lb3V0VG9Vc2V9bXMuIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3RpbWVvdXQgZm9yIGhlbHAuYCxcbiAgICAgICAgICAgIHJldHJpZXNMZWZ0ID4gMCA/IERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgKyByZXRyaWVzTGVmdCA6IG51bGwsXG4gICAgICAgICAgICByZXRyaWVzTGVmdCA+IDAgPyBERUxBWV9SRU5ERVJfUkVUUllfVE9LRU4gOiBudWxsLFxuICAgICAgICAgICAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgICAgICAgICAgIGNhbGxlZFxuICAgICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgICAgY2FuY2VsUmVuZGVyKEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgfSwgdGltZW91dFRvVXNlKVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gaGFuZGxlO1xufTtcbnZhciBkZWxheVJlbmRlciA9IChsYWJlbCwgb3B0aW9ucykgPT4ge1xuICByZXR1cm4gZGVsYXlSZW5kZXJJbnRlcm5hbChnZXRSZW1vdGlvbkVudmlyb25tZW50KCksIGxhYmVsLCBvcHRpb25zKTtcbn07XG52YXIgY29udGludWVSZW5kZXJJbnRlcm5hbCA9IChoYW5kbGUsIGVudmlyb25tZW50KSA9PiB7XG4gIGlmICh0eXBlb2YgaGFuZGxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjb250aW51ZVJlbmRlcigpIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgcGFyYW1ldGVyIHRoYXQgaXMgdGhlIHJldHVybiB2YWx1ZSBvZiBkZWxheVJlbmRlcigpLiBObyB2YWx1ZSB3YXMgcGFzc2VkLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGhhbmRsZSAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgcGFyYW1ldGVyIHBhc3NlZCBpbnRvIGNvbnRpbnVlUmVuZGVyKCkgbXVzdCBiZSB0aGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkgd2hpY2ggaXMgYSBudW1iZXIuIEdvdDogXCIgKyBKU09OLnN0cmluZ2lmeShoYW5kbGUpKTtcbiAgfVxuICBoYW5kbGVzID0gaGFuZGxlcy5maWx0ZXIoKGgpID0+IHtcbiAgICBpZiAoaCA9PT0gaGFuZGxlKSB7XG4gICAgICBpZiAoZW52aXJvbm1lbnQuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbGFiZWwsIHN0YXJ0VGltZSwgdGltZW91dCB9ID0gd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHNbaGFuZGxlXTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgIGxhYmVsID8gYFwiJHtsYWJlbH1cImAgOiBcIkEgaGFuZGxlXCIsXG4gICAgICAgICAgREVMQVlfUkVOREVSX0NMRUFSX1RPS0VOLFxuICAgICAgICAgIGAke0RhdGUubm93KCkgLSBzdGFydFRpbWV9bXNgXG4gICAgICAgIF0uZmlsdGVyKHRydXRoeSkuam9pbihcIiBcIik7XG4gICAgICAgIExvZy52ZXJib3NlKHsgbG9nTGV2ZWw6IHdpbmRvdy5yZW1vdGlvbl9sb2dMZXZlbCwgdGFnOiBcImRlbGF5UmVuZGVyKClcIiB9LCBtZXNzYWdlKTtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgaWYgKGhhbmRsZXMubGVuZ3RoID09PSAwICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSB0cnVlO1xuICB9XG59O1xudmFyIGNvbnRpbnVlUmVuZGVyID0gKGhhbmRsZSkgPT4ge1xuICBjb250aW51ZVJlbmRlckludGVybmFsKGhhbmRsZSwgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpKTtcbn07XG5cbi8vIHNyYy91c2UtZGVsYXktcmVuZGVyLnRzXG52YXIgdXNlRGVsYXlSZW5kZXIgPSAoKSA9PiB7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBkZWxheVJlbmRlcjIgPSB1c2VDYWxsYmFjazQoKGxhYmVsLCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGRlbGF5UmVuZGVySW50ZXJuYWwoZW52aXJvbm1lbnQsIGxhYmVsLCBvcHRpb25zKTtcbiAgfSwgW2Vudmlyb25tZW50XSk7XG4gIGNvbnN0IGNvbnRpbnVlUmVuZGVyMiA9IHVzZUNhbGxiYWNrNCgoaGFuZGxlKSA9PiB7XG4gICAgY29udGludWVSZW5kZXJJbnRlcm5hbChoYW5kbGUsIGVudmlyb25tZW50KTtcbiAgfSwgW2Vudmlyb25tZW50XSk7XG4gIHJldHVybiB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfTtcbn07XG5cbi8vIHNyYy9hbmltYXRlZC1pbWFnZS9jYW52YXMudHN4XG5pbXBvcnQgUmVhY3Q5LCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNSwgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlMywgdXNlUmVmIGFzIHVzZVJlZjIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3g5IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgY2FsY0FyZ3MgPSAoZml0LCBmcmFtZVNpemUsIGNhbnZhc1NpemUpID0+IHtcbiAgc3dpdGNoIChmaXQpIHtcbiAgICBjYXNlIFwiZmlsbFwiOiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmcmFtZVNpemUud2lkdGgsXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgIGNhbnZhc1NpemUuaGVpZ2h0XG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY29udGFpblwiOiB7XG4gICAgICBjb25zdCByYXRpbyA9IE1hdGgubWluKGNhbnZhc1NpemUud2lkdGggLyBmcmFtZVNpemUud2lkdGgsIGNhbnZhc1NpemUuaGVpZ2h0IC8gZnJhbWVTaXplLmhlaWdodCk7XG4gICAgICBjb25zdCBjZW50ZXJYID0gKGNhbnZhc1NpemUud2lkdGggLSBmcmFtZVNpemUud2lkdGggKiByYXRpbykgLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IChjYW52YXNTaXplLmhlaWdodCAtIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpbykgLyAyO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoLFxuICAgICAgICBmcmFtZVNpemUuaGVpZ2h0LFxuICAgICAgICBjZW50ZXJYLFxuICAgICAgICBjZW50ZXJZLFxuICAgICAgICBmcmFtZVNpemUud2lkdGggKiByYXRpbyxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCAqIHJhdGlvXG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwiY292ZXJcIjoge1xuICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1heChjYW52YXNTaXplLndpZHRoIC8gZnJhbWVTaXplLndpZHRoLCBjYW52YXNTaXplLmhlaWdodCAvIGZyYW1lU2l6ZS5oZWlnaHQpO1xuICAgICAgY29uc3QgY2VudGVyWCA9IChjYW52YXNTaXplLndpZHRoIC0gZnJhbWVTaXplLndpZHRoICogcmF0aW8pIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclkgPSAoY2FudmFzU2l6ZS5oZWlnaHQgLSBmcmFtZVNpemUuaGVpZ2h0ICogcmF0aW8pIC8gMjtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZyYW1lU2l6ZS53aWR0aCxcbiAgICAgICAgZnJhbWVTaXplLmhlaWdodCxcbiAgICAgICAgY2VudGVyWCxcbiAgICAgICAgY2VudGVyWSxcbiAgICAgICAgZnJhbWVTaXplLndpZHRoICogcmF0aW8sXG4gICAgICAgIGZyYW1lU2l6ZS5oZWlnaHQgKiByYXRpb1xuICAgICAgXTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZml0OiBcIiArIGZpdCk7XG4gIH1cbn07XG52YXIgQ2FudmFzUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHsgd2lkdGgsIGhlaWdodCwgZml0LCBjbGFzc05hbWUsIHN0eWxlIH0sIHJlZikgPT4ge1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWYyKG51bGwpO1xuICBjb25zdCBkcmF3ID0gdXNlQ2FsbGJhY2s1KChpbWFnZURhdGEpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpZHRoID8/IGltYWdlRGF0YS5kaXNwbGF5V2lkdGg7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ID8/IGltYWdlRGF0YS5kaXNwbGF5SGVpZ2h0O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmIGlzIG5vdCBzZXRcIik7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IGNhbnZhc1JlZi5jdXJyZW50Py5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgMmQgY29udGV4dFwiKTtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlRGF0YSwgLi4uY2FsY0FyZ3MoZml0LCB7XG4gICAgICBoZWlnaHQ6IGltYWdlRGF0YS5kaXNwbGF5SGVpZ2h0LFxuICAgICAgd2lkdGg6IGltYWdlRGF0YS5kaXNwbGF5V2lkdGhcbiAgICB9LCB7XG4gICAgICB3aWR0aDogY2FudmFzV2lkdGgsXG4gICAgICBoZWlnaHQ6IGNhbnZhc0hlaWdodFxuICAgIH0pKTtcbiAgfSwgW2ZpdCwgaGVpZ2h0LCB3aWR0aF0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlMyhyZWYsICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHJhdyxcbiAgICAgIGdldENhbnZhczogKCkgPT4ge1xuICAgICAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZiBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgIH0sXG4gICAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXNSZWYuY3VycmVudD8uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBpZiAoIWN0eCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgMmQgY29udGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoLCBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtkcmF3XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4OShcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgY2xhc3NOYW1lLFxuICAgIHN0eWxlXG4gIH0pO1xufTtcbnZhciBDYW52YXMgPSBSZWFjdDkuZm9yd2FyZFJlZihDYW52YXNSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvZGVjb2RlLWltYWdlLnRzXG52YXIgQ0FDSEVfU0laRSA9IDU7XG52YXIgZ2V0QWN0dWFsVGltZSA9ICh7XG4gIGxvb3BCZWhhdmlvcixcbiAgZHVyYXRpb25Gb3VuZCxcbiAgdGltZUluU2VjXG59KSA9PiB7XG4gIHJldHVybiBsb29wQmVoYXZpb3IgPT09IFwibG9vcFwiID8gZHVyYXRpb25Gb3VuZCA/IHRpbWVJblNlYyAlIGR1cmF0aW9uRm91bmQgOiB0aW1lSW5TZWMgOiBNYXRoLm1pbih0aW1lSW5TZWMsIGR1cmF0aW9uRm91bmQgfHwgSW5maW5pdHkpO1xufTtcbnZhciBkZWNvZGVJbWFnZSA9IGFzeW5jICh7XG4gIHJlc29sdmVkU3JjLFxuICBzaWduYWwsXG4gIGN1cnJlbnRUaW1lLFxuICBpbml0aWFsTG9vcEJlaGF2aW9yXG59KSA9PiB7XG4gIGlmICh0eXBlb2YgSW1hZ2VEZWNvZGVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIFdlYkNvZGVjcyBJbWFnZURlY29kZXIgQVBJLlwiKTtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChyZXNvbHZlZFNyYywgeyBzaWduYWwgfSk7XG4gIGNvbnN0IHsgYm9keSB9ID0gcmVzO1xuICBpZiAoIWJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHb3Qgbm8gYm9keVwiKTtcbiAgfVxuICBjb25zdCBkZWNvZGVyID0gbmV3IEltYWdlRGVjb2Rlcih7XG4gICAgZGF0YTogYm9keSxcbiAgICB0eXBlOiByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikgfHwgXCJpbWFnZS9naWZcIlxuICB9KTtcbiAgYXdhaXQgZGVjb2Rlci5jb21wbGV0ZWQ7XG4gIGNvbnN0IHsgc2VsZWN0ZWRUcmFjayB9ID0gZGVjb2Rlci50cmFja3M7XG4gIGlmICghc2VsZWN0ZWRUcmFjaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlbGVjdGVkIHRyYWNrXCIpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGxldCBkdXJhdGlvbkZvdW5kID0gbnVsbDtcbiAgY29uc3QgZ2V0RnJhbWVCeUluZGV4ID0gYXN5bmMgKGZyYW1lSW5kZXgpID0+IHtcbiAgICBjb25zdCBmb3VuZEluQ2FjaGUgPSBjYWNoZS5maW5kKChjKSA9PiBjLmZyYW1lSW5kZXggPT09IGZyYW1lSW5kZXgpO1xuICAgIGlmIChmb3VuZEluQ2FjaGUgJiYgZm91bmRJbkNhY2hlLmZyYW1lKSB7XG4gICAgICByZXR1cm4gZm91bmRJbkNhY2hlO1xuICAgIH1cbiAgICBjb25zdCBmcmFtZSA9IGF3YWl0IGRlY29kZXIuZGVjb2RlKHtcbiAgICAgIGZyYW1lSW5kZXgsXG4gICAgICBjb21wbGV0ZUZyYW1lc09ubHk6IHRydWVcbiAgICB9KTtcbiAgICBpZiAoZm91bmRJbkNhY2hlKSB7XG4gICAgICBmb3VuZEluQ2FjaGUuZnJhbWUgPSBmcmFtZS5pbWFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUucHVzaCh7XG4gICAgICAgIGZyYW1lOiBmcmFtZS5pbWFnZSxcbiAgICAgICAgZnJhbWVJbmRleCxcbiAgICAgICAgdGltZUluU2Vjb25kczogZnJhbWUuaW1hZ2UudGltZXN0YW1wIC8gMWU2XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lOiBmcmFtZS5pbWFnZSxcbiAgICAgIGZyYW1lSW5kZXgsXG4gICAgICB0aW1lSW5TZWNvbmRzOiBmcmFtZS5pbWFnZS50aW1lc3RhbXAgLyAxZTZcbiAgICB9O1xuICB9O1xuICBjb25zdCBjbGVhckNhY2hlID0gKGNsb3NlVG9UaW1lSW5TZWMpID0+IHtcbiAgICBjb25zdCBpdGVtc0luQ2FjaGUgPSBjYWNoZS5maWx0ZXIoKGMpID0+IGMuZnJhbWUpO1xuICAgIGNvbnN0IHNvcnRCeUNsb3Nlc3RUb0N1cnJlbnRUaW1lID0gaXRlbXNJbkNhY2hlLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoYS50aW1lSW5TZWNvbmRzIC0gY2xvc2VUb1RpbWVJblNlYyk7XG4gICAgICBjb25zdCBiRGlmZiA9IE1hdGguYWJzKGIudGltZUluU2Vjb25kcyAtIGNsb3NlVG9UaW1lSW5TZWMpO1xuICAgICAgcmV0dXJuIGFEaWZmIC0gYkRpZmY7XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7aSA8IHNvcnRCeUNsb3Nlc3RUb0N1cnJlbnRUaW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA8IENBQ0hFX1NJWkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtID0gc29ydEJ5Q2xvc2VzdFRvQ3VycmVudFRpbWVbaV07XG4gICAgICBpdGVtLmZyYW1lID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIgPSBhc3luYyAoe1xuICAgIHRpbWVJblNlYyxcbiAgICBsb29wQmVoYXZpb3JcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGFjdHVhbFRpbWVJblNlYyA9IGdldEFjdHVhbFRpbWUoe1xuICAgICAgZHVyYXRpb25Gb3VuZCxcbiAgICAgIGxvb3BCZWhhdmlvcixcbiAgICAgIHRpbWVJblNlY1xuICAgIH0pO1xuICAgIGNvbnN0IGZyYW1lc0JlZm9yZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy50aW1lSW5TZWNvbmRzIDw9IGFjdHVhbFRpbWVJblNlYyk7XG4gICAgY29uc3QgYmlnZ2VzdEluZGV4ID0gZnJhbWVzQmVmb3JlLm1hcCgoYykgPT4gYy5mcmFtZUluZGV4KS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpLCAwKTtcbiAgICBsZXQgaSA9IGJpZ2dlc3RJbmRleDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgZiA9IGF3YWl0IGdldEZyYW1lQnlJbmRleChpKTtcbiAgICAgIGkrKztcbiAgICAgIGlmICghZi5mcmFtZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmcmFtZSBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghZi5mcmFtZS5kdXJhdGlvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBzZWxlY3RlZFRyYWNrLmZyYW1lQ291bnQgJiYgZHVyYXRpb25Gb3VuZCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IChmLmZyYW1lLnRpbWVzdGFtcCArIGYuZnJhbWUuZHVyYXRpb24pIC8gMWU2O1xuICAgICAgICBkdXJhdGlvbkZvdW5kID0gZHVyYXRpb247XG4gICAgICB9XG4gICAgICBpZiAoZi50aW1lSW5TZWNvbmRzID4gYWN0dWFsVGltZUluU2VjIHx8IGkgPT09IHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkVHJhY2suZnJhbWVDb3VudCAtIGJpZ2dlc3RJbmRleCA8IDMgJiYgbG9vcEJlaGF2aW9yID09PSBcImxvb3BcIikge1xuICAgICAgYXdhaXQgZ2V0RnJhbWVCeUluZGV4KDApO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKGFjdHVhbFRpbWVJblNlYyk7XG4gIH07XG4gIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoe1xuICAgIHRpbWVJblNlYzogY3VycmVudFRpbWUsXG4gICAgbG9vcEJlaGF2aW9yOiBpbml0aWFsTG9vcEJlaGF2aW9yXG4gIH0pO1xuICBhd2FpdCBlbnN1cmVGcmFtZUJlZm9yZUFuZEFmdGVyKHtcbiAgICB0aW1lSW5TZWM6IGN1cnJlbnRUaW1lLFxuICAgIGxvb3BCZWhhdmlvcjogaW5pdGlhbExvb3BCZWhhdmlvclxuICB9KTtcbiAgY29uc3QgZ2V0RnJhbWUgPSBhc3luYyAodGltZUluU2VjLCBsb29wQmVoYXZpb3IpID0+IHtcbiAgICBpZiAoZHVyYXRpb25Gb3VuZCAhPT0gbnVsbCAmJiB0aW1lSW5TZWMgPiBkdXJhdGlvbkZvdW5kICYmIGxvb3BCZWhhdmlvciA9PT0gXCJjbGVhci1hZnRlci1maW5pc2hcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbFRpbWVJblNlYyA9IGdldEFjdHVhbFRpbWUoe1xuICAgICAgbG9vcEJlaGF2aW9yLFxuICAgICAgZHVyYXRpb25Gb3VuZCxcbiAgICAgIHRpbWVJblNlY1xuICAgIH0pO1xuICAgIGF3YWl0IGVuc3VyZUZyYW1lQmVmb3JlQW5kQWZ0ZXIoeyB0aW1lSW5TZWM6IGFjdHVhbFRpbWVJblNlYywgbG9vcEJlaGF2aW9yIH0pO1xuICAgIGNvbnN0IGl0ZW1zSW5DYWNoZSA9IGNhY2hlLmZpbHRlcigoYykgPT4gYy5mcmFtZSk7XG4gICAgY29uc3QgY2xvc2VzdCA9IGl0ZW1zSW5DYWNoZS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgIGNvbnN0IGFEaWZmID0gTWF0aC5hYnMoYS50aW1lSW5TZWNvbmRzIC0gYWN0dWFsVGltZUluU2VjKTtcbiAgICAgIGNvbnN0IGJEaWZmID0gTWF0aC5hYnMoYi50aW1lSW5TZWNvbmRzIC0gYWN0dWFsVGltZUluU2VjKTtcbiAgICAgIHJldHVybiBhRGlmZiA8IGJEaWZmID8gYSA6IGI7XG4gICAgfSk7XG4gICAgaWYgKCFjbG9zZXN0LmZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmcmFtZSBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3Q7XG4gIH07XG4gIHJldHVybiB7XG4gICAgZ2V0RnJhbWUsXG4gICAgZnJhbWVDb3VudDogc2VsZWN0ZWRUcmFjay5mcmFtZUNvdW50XG4gIH07XG59O1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvcmVzb2x2ZS1pbWFnZS1zb3VyY2UudHN4XG52YXIgcmVzb2x2ZUFuaW1hdGVkSW1hZ2VTb3VyY2UgPSAoc3JjKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICByZXR1cm4gbmV3IFVSTChzcmMsIHdpbmRvdy5vcmlnaW4pLmhyZWY7XG59O1xuXG4vLyBzcmMvYW5pbWF0ZWQtaW1hZ2UvQW5pbWF0ZWRJbWFnZS50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gxMCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIEFuaW1hdGVkSW1hZ2UgPSBmb3J3YXJkUmVmMygoe1xuICBzcmMsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG9uRXJyb3IsXG4gIGxvb3BCZWhhdmlvciA9IFwibG9vcFwiLFxuICBwbGF5YmFja1JhdGUgPSAxLFxuICBmaXQgPSBcImZpbGxcIixcbiAgLi4ucHJvcHNcbn0sIGNhbnZhc1JlZikgPT4ge1xuICBjb25zdCBtb3VudFN0YXRlID0gdXNlUmVmMyh7IGlzTW91bnRlZDogdHJ1ZSB9KTtcbiAgdXNlRWZmZWN0NCgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBtb3VudFN0YXRlO1xuICAgIGN1cnJlbnQuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlc29sdmVkU3JjID0gcmVzb2x2ZUFuaW1hdGVkSW1hZ2VTb3VyY2Uoc3JjKTtcbiAgY29uc3QgW2ltYWdlRGVjb2Rlciwgc2V0SW1hZ2VEZWNvZGVyXSA9IHVzZVN0YXRlNihudWxsKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBjb25zdCBbZGVjb2RlSGFuZGxlXSA9IHVzZVN0YXRlNigoKSA9PiBkZWxheVJlbmRlcjIoYFJlbmRlcmluZyA8QW5pbWF0ZWRJbWFnZS8+IHdpdGggc3JjPVwiJHtyZXNvbHZlZFNyY31cImApKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gZnJhbWUgLyBwbGF5YmFja1JhdGUgLyBmcHM7XG4gIGNvbnN0IGN1cnJlbnRUaW1lUmVmID0gdXNlUmVmMyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUaW1lUmVmLmN1cnJlbnQgPSBjdXJyZW50VGltZTtcbiAgY29uc3QgcmVmID0gdXNlUmVmMyhudWxsKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTQoY2FudmFzUmVmLCAoKSA9PiB7XG4gICAgY29uc3QgYyA9IHJlZi5jdXJyZW50Py5nZXRDYW52YXMoKTtcbiAgICBpZiAoIWMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWYgaXMgbm90IHNldFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGM7XG4gIH0sIFtdKTtcbiAgY29uc3QgW2luaXRpYWxMb29wQmVoYXZpb3JdID0gdXNlU3RhdGU2KCgpID0+IGxvb3BCZWhhdmlvcik7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyO1xuICAgIGRlY29kZUltYWdlKHtcbiAgICAgIHJlc29sdmVkU3JjLFxuICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIGN1cnJlbnRUaW1lOiBjdXJyZW50VGltZVJlZi5jdXJyZW50LFxuICAgICAgaW5pdGlhbExvb3BCZWhhdmlvclxuICAgIH0pLnRoZW4oKGQpID0+IHtcbiAgICAgIHNldEltYWdlRGVjb2RlcihkKTtcbiAgICAgIGNvbnRpbnVlUmVuZGVyMihkZWNvZGVIYW5kbGUpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgY29udGludWVSZW5kZXIyKGRlY29kZUhhbmRsZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3I/LihlcnIpO1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoZGVjb2RlSGFuZGxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIHJlc29sdmVkU3JjLFxuICAgIGRlY29kZUhhbmRsZSxcbiAgICBvbkVycm9yLFxuICAgIGluaXRpYWxMb29wQmVoYXZpb3IsXG4gICAgY29udGludWVSZW5kZXIyXG4gIF0pO1xuICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaW1hZ2VEZWNvZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRlbGF5ID0gZGVsYXlSZW5kZXIyKGBSZW5kZXJpbmcgZnJhbWUgYXQgJHtjdXJyZW50VGltZX0gb2YgPEFuaW1hdGVkSW1hZ2Ugc3JjPVwiJHtzcmN9XCIvPmApO1xuICAgIGltYWdlRGVjb2Rlci5nZXRGcmFtZShjdXJyZW50VGltZSwgbG9vcEJlaGF2aW9yKS50aGVuKCh2aWRlb0ZyYW1lKSA9PiB7XG4gICAgICBpZiAobW91bnRTdGF0ZS5jdXJyZW50LmlzTW91bnRlZCkge1xuICAgICAgICBpZiAodmlkZW9GcmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlZi5jdXJyZW50Py5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZi5jdXJyZW50Py5kcmF3KHZpZGVvRnJhbWUuZnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZVJlbmRlcjIoZGVsYXkpO1xuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgY29udGludWVSZW5kZXIyKGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbFJlbmRlcihlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbXG4gICAgY3VycmVudFRpbWUsXG4gICAgaW1hZ2VEZWNvZGVyLFxuICAgIGxvb3BCZWhhdmlvcixcbiAgICBvbkVycm9yLFxuICAgIHNyYyxcbiAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgZGVsYXlSZW5kZXIyXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDEwKENhbnZhcywge1xuICAgIHJlZixcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZml0LFxuICAgIC4uLnByb3BzXG4gIH0pO1xufSk7XG4vLyBzcmMvQXJ0aWZhY3QudHN4XG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxMiwgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDUsIHVzZVN0YXRlIGFzIHVzZVN0YXRlOCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvUmVuZGVyQXNzZXRNYW5hZ2VyLnRzeFxuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTAsXG4gIHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrNixcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDIsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzEwLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTdcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWFydGlmYWN0LnRzXG52YXIgdmFsaWRhdGVBcnRpZmFjdEZpbGVuYW1lID0gKGZpbGVuYW1lKSA9PiB7XG4gIGlmICh0eXBlb2YgZmlsZW5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmaWxlbmFtZVwiIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmaWxlbmFtZX1gKTtcbiAgfVxuICBpZiAoZmlsZW5hbWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBmaWxlbmFtZWAgbXVzdCBub3QgYmUgZW1wdHlcIik7XG4gIH1cbiAgaWYgKCFmaWxlbmFtZS5tYXRjaCgvXihbMC05YS16QS1aLSFfLionKCkvOiYkQD07Kyw/XSspL2cpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGZpbGVuYW1lYCBtdXN0IG1hdGNoIFwiL14oWzAtOWEtekEtWi0hXy4qXFwnKCkvOiYkQD07Kyw/XSspL2dcIi4gVXNlIGZvcndhcmQgc2xhc2hlcyBvbmx5LCBldmVuIG9uIFdpbmRvd3MuJyk7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVDb250ZW50ID0gKGNvbnRlbnQpID0+IHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiICYmICEoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiY29udGVudFwiIG11c3QgYmUgYSBzdHJpbmcgb3IgVWludDhBcnJheSwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGNvbnRlbnR9YCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiICYmIGNvbnRlbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBjb250ZW50YCBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZVJlbmRlckFzc2V0ID0gKGFydGlmYWN0KSA9PiB7XG4gIGlmIChhcnRpZmFjdC50eXBlICE9PSBcImFydGlmYWN0XCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFsaWRhdGVBcnRpZmFjdEZpbGVuYW1lKGFydGlmYWN0LmZpbGVuYW1lKTtcbiAgaWYgKGFydGlmYWN0LmNvbnRlbnRUeXBlID09PSBcInRodW1ibmFpbFwiKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhbGlkYXRlQ29udGVudChhcnRpZmFjdC5jb250ZW50KTtcbn07XG5cbi8vIHNyYy9SZW5kZXJBc3NldE1hbmFnZXIudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTEgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBSZW5kZXJBc3NldE1hbmFnZXIgPSBjcmVhdGVDb250ZXh0MTAoe1xuICByZWdpc3RlclJlbmRlckFzc2V0OiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQ6ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH0sXG4gIHJlbmRlckFzc2V0czogW11cbn0pO1xudmFyIFJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbcmVuZGVyQXNzZXRzLCBzZXRSZW5kZXJBc3NldHNdID0gdXNlU3RhdGU3KFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrNigocmVuZGVyQXNzZXQpID0+IHtcbiAgICB2YWxpZGF0ZVJlbmRlckFzc2V0KHJlbmRlckFzc2V0KTtcbiAgICBzZXRSZW5kZXJBc3NldHMoKGFzc2V0cykgPT4ge1xuICAgICAgcmV0dXJuIFsuLi5hc3NldHMsIHJlbmRlckFzc2V0XTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgPSB1c2VDYWxsYmFjazYoKGlkKSA9PiB7XG4gICAgc2V0UmVuZGVyQXNzZXRzKChhc3N0cykgPT4ge1xuICAgICAgcmV0dXJuIGFzc3RzLmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUxheW91dEVmZmVjdDIoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB3aW5kb3cucmVtb3Rpb25fY29sbGVjdEFzc2V0cyA9ICgpID0+IHtcbiAgICAgICAgc2V0UmVuZGVyQXNzZXRzKFtdKTtcbiAgICAgICAgcmV0dXJuIHJlbmRlckFzc2V0cztcbiAgICAgIH07XG4gICAgfVxuICB9LCBbcmVuZGVyQXNzZXRzXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8xMCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICByZW5kZXJBc3NldHNcbiAgICB9O1xuICB9LCBbcmVuZGVyQXNzZXRzLCByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMShSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcblxuLy8gc3JjL0FydGlmYWN0LnRzeFxudmFyIEFydGlmYWN0VGh1bWJuYWlsID0gU3ltYm9sKFwiVGh1bWJuYWlsXCIpO1xudmFyIEFydGlmYWN0ID0gKHsgZmlsZW5hbWUsIGNvbnRlbnQsIGRvd25sb2FkQmVoYXZpb3IgfSkgPT4ge1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDEyKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IGVudiA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgW2lkXSA9IHVzZVN0YXRlOCgoKSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKTtcbiAgfSk7XG4gIHVzZUVmZmVjdDUoKCkgPT4ge1xuICAgIGlmICghZW52LmlzUmVuZGVyaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgIHR5cGU6IFwiYXJ0aWZhY3RcIixcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbnRlbnQ6IGJ0b2EobmV3IFRleHREZWNvZGVyKFwidXRmOFwiKS5kZWNvZGUoY29udGVudCkpLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImJpbmFyeVwiLFxuICAgICAgICBkb3dubG9hZEJlaGF2aW9yOiBkb3dubG9hZEJlaGF2aW9yID8/IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29udGVudCA9PT0gQXJ0aWZhY3RUaHVtYm5haWwpIHtcbiAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQoe1xuICAgICAgICB0eXBlOiBcImFydGlmYWN0XCIsXG4gICAgICAgIGlkLFxuICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcInRodW1ibmFpbFwiLFxuICAgICAgICBkb3dubG9hZEJlaGF2aW9yOiBkb3dubG9hZEJlaGF2aW9yID8/IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgdHlwZTogXCJhcnRpZmFjdFwiLFxuICAgICAgICBpZCxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGRvd25sb2FkQmVoYXZpb3I6IGRvd25sb2FkQmVoYXZpb3IgPz8gbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgY29udGVudCxcbiAgICBlbnYuaXNSZW5kZXJpbmcsXG4gICAgZmlsZW5hbWUsXG4gICAgZnJhbWUsXG4gICAgaWQsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgZG93bmxvYWRCZWhhdmlvclxuICBdKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuQXJ0aWZhY3QuVGh1bWJuYWlsID0gQXJ0aWZhY3RUaHVtYm5haWw7XG4vLyBzcmMvYXVkaW8vQXVkaW8udHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY2LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazExLCB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYWJzb2x1dGUtc3JjLnRzXG52YXIgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVTcmM7XG4gIH1cbiAgaWYgKHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiZmlsZTovL1wiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlU3JjO1xuICB9XG4gIHJldHVybiBuZXcgVVJMKHJlbGF0aXZlU3JjLCB3aW5kb3cub3JpZ2luKS5ocmVmO1xufTtcblxuLy8gc3JjL2NhbGN1bGF0ZS1tZWRpYS1kdXJhdGlvbi50c1xudmFyIGNhbGN1bGF0ZU1lZGlhRHVyYXRpb24gPSAoe1xuICB0cmltQWZ0ZXIsXG4gIG1lZGlhRHVyYXRpb25JbkZyYW1lcyxcbiAgcGxheWJhY2tSYXRlLFxuICB0cmltQmVmb3JlXG59KSA9PiB7XG4gIGxldCBkdXJhdGlvbiA9IG1lZGlhRHVyYXRpb25JbkZyYW1lcztcbiAgaWYgKHR5cGVvZiB0cmltQWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiA9IHRyaW1BZnRlcjtcbiAgfVxuICBpZiAodHlwZW9mIHRyaW1CZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBkdXJhdGlvbiAtPSB0cmltQmVmb3JlO1xuICB9XG4gIGNvbnN0IGFjdHVhbER1cmF0aW9uID0gZHVyYXRpb24gLyBwbGF5YmFja1JhdGU7XG4gIHJldHVybiBNYXRoLmZsb29yKGFjdHVhbER1cmF0aW9uKTtcbn07XG5cbi8vIHNyYy9sb29wL2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0MTAsIHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTEsIHVzZU1lbW8gYXMgdXNlTWVtbzExIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBMb29wQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxMShudWxsKTtcbnZhciB1c2VMb29wID0gKCkgPT4ge1xuICByZXR1cm4gUmVhY3QxMC51c2VDb250ZXh0KExvb3BDb250ZXh0KTtcbn07XG52YXIgTG9vcCA9ICh7IGR1cmF0aW9uSW5GcmFtZXMsIHRpbWVzID0gSW5maW5pdHksIGNoaWxkcmVuLCBuYW1lLCAuLi5wcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB7IGR1cmF0aW9uSW5GcmFtZXM6IGNvbXBEdXJhdGlvbiB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICBjb21wb25lbnQ6IFwib2YgdGhlIDxMb29wIC8+IGNvbXBvbmVudFwiLFxuICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gIH0pO1xuICBpZiAodHlwZW9mIHRpbWVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBcInRpbWVzXCIgYW4gYXJndW1lbnQgb2YgdHlwZSAke3R5cGVvZiB0aW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICB9XG4gIGlmICh0aW1lcyAhPT0gSW5maW5pdHkgJiYgdGltZXMgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwidGltZXNcIiBwcm9wIG9mIGEgbG9vcCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHt0aW1lc30uYCk7XG4gIH1cbiAgaWYgKHRpbWVzIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7dGltZXN9YCk7XG4gIH1cbiAgY29uc3QgbWF4VGltZXMgPSBNYXRoLmNlaWwoY29tcER1cmF0aW9uIC8gZHVyYXRpb25JbkZyYW1lcyk7XG4gIGNvbnN0IGFjdHVhbFRpbWVzID0gTWF0aC5taW4obWF4VGltZXMsIHRpbWVzKTtcbiAgY29uc3Qgc3R5bGUgPSBwcm9wcy5sYXlvdXQgPT09IFwibm9uZVwiID8gdW5kZWZpbmVkIDogcHJvcHMuc3R5bGU7XG4gIGNvbnN0IG1heEZyYW1lID0gZHVyYXRpb25JbkZyYW1lcyAqIChhY3R1YWxUaW1lcyAtIDEpO1xuICBjb25zdCBpdGVyYXRpb24gPSBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICBjb25zdCBzdGFydCA9IGl0ZXJhdGlvbiAqIGR1cmF0aW9uSW5GcmFtZXM7XG4gIGNvbnN0IGZyb20gPSBNYXRoLm1pbihzdGFydCwgbWF4RnJhbWUpO1xuICBjb25zdCBsb29wRGlzcGxheSA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mVGltZXM6IGFjdHVhbFRpbWVzLFxuICAgICAgc3RhcnRPZmZzZXQ6IC1mcm9tLFxuICAgICAgZHVyYXRpb25JbkZyYW1lc1xuICAgIH07XG4gIH0sIFthY3R1YWxUaW1lcywgZHVyYXRpb25JbkZyYW1lcywgZnJvbV0pO1xuICBjb25zdCBsb29wQ29udGV4dCA9IHVzZU1lbW8xMSgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZXJhdGlvbjogTWF0aC5mbG9vcihjdXJyZW50RnJhbWUgLyBkdXJhdGlvbkluRnJhbWVzKSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXNcbiAgICB9O1xuICB9LCBbY3VycmVudEZyYW1lLCBkdXJhdGlvbkluRnJhbWVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTIoTG9vcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9vcENvbnRleHQsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gxMihTZXF1ZW5jZSwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgIGZyb20sXG4gICAgICBuYW1lOiBuYW1lID8/IFwiPExvb3A+XCIsXG4gICAgICBfcmVtb3Rpb25JbnRlcm5hbExvb3BEaXNwbGF5OiBsb29wRGlzcGxheSxcbiAgICAgIGxheW91dDogcHJvcHMubGF5b3V0LFxuICAgICAgc3R5bGUsXG4gICAgICBjaGlsZHJlblxuICAgIH0pXG4gIH0pO1xufTtcbkxvb3AudXNlTG9vcCA9IHVzZUxvb3A7XG5cbi8vIHNyYy9wcmVmZXRjaC50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTMgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3BsYXliYWNrLWxvZ2dpbmcudHNcbnZhciBwbGF5YmFja0xvZ2dpbmcgPSAoe1xuICBsb2dMZXZlbCxcbiAgdGFnLFxuICBtZXNzYWdlLFxuICBtb3VudFRpbWVcbn0pID0+IHtcbiAgY29uc3QgdGFncyA9IFttb3VudFRpbWUgPyBEYXRlLm5vdygpIC0gbW91bnRUaW1lICsgXCJtcyBcIiA6IG51bGwsIHRhZ10uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICBMb2cudHJhY2UoeyBsb2dMZXZlbCwgdGFnOiBudWxsIH0sIGBbJHt0YWdzfV1gLCBtZXNzYWdlKTtcbn07XG5cbi8vIHNyYy9wcmVmZXRjaC1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEyLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0NiwgdXNlU3RhdGUgYXMgdXNlU3RhdGU5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBQcmVsb2FkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxMih7fSk7XG52YXIgcHJlbG9hZHMgPSB7fTtcbnZhciB1cGRhdGVycyA9IFtdO1xudmFyIHNldFByZWxvYWRzID0gKHVwZGF0ZXIpID0+IHtcbiAgcHJlbG9hZHMgPSB1cGRhdGVyKHByZWxvYWRzKTtcbiAgdXBkYXRlcnMuZm9yRWFjaCgodSkgPT4gdSgpKTtcbn07XG52YXIgUHJlZmV0Y2hQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW19wcmVsb2FkcywgX3NldFByZWxvYWRzXSA9IHVzZVN0YXRlOSgoKSA9PiBwcmVsb2Fkcyk7XG4gIHVzZUVmZmVjdDYoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZXJGdW5jdGlvbiA9ICgpID0+IHtcbiAgICAgIF9zZXRQcmVsb2FkcyhwcmVsb2Fkcyk7XG4gICAgfTtcbiAgICB1cGRhdGVycy5wdXNoKHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHVwZGF0ZXJzID0gdXBkYXRlcnMuZmlsdGVyKCh1KSA9PiB1ICE9PSB1cGRhdGVyRnVuY3Rpb24pO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxMyhQcmVsb2FkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBfcHJlbG9hZHMsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvcHJlZmV0Y2gudHNcbnZhciByZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQgPSAoc3JjKSA9PiB7XG4gIGNvbnN0IGhhc2hJbmRleCA9IHNyYy5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGhhc2hJbmRleCA9PT0gLTEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaGFzaEluZGV4O1xufTtcbnZhciBnZXRTcmNXaXRob3V0SGFzaCA9IChzcmMpID0+IHtcbiAgY29uc3QgaGFzaEluZGV4ID0gcmVtb3ZlQW5kR2V0SGFzaEZyYWdtZW50KHNyYyk7XG4gIGlmIChoYXNoSW5kZXggPT09IG51bGwpIHtcbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIHJldHVybiBzcmMuc2xpY2UoMCwgaGFzaEluZGV4KTtcbn07XG52YXIgdXNlUHJlbG9hZCA9IChzcmMpID0+IHtcbiAgY29uc3QgcHJlbG9hZHMyID0gdXNlQ29udGV4dDEzKFByZWxvYWRDb250ZXh0KTtcbiAgY29uc3QgaGFzaEZyYWdtZW50SW5kZXggPSByZW1vdmVBbmRHZXRIYXNoRnJhZ21lbnQoc3JjKTtcbiAgY29uc3Qgd2l0aG91dEhhc2hGcmFnbWVudCA9IGdldFNyY1dpdGhvdXRIYXNoKHNyYyk7XG4gIGlmICghcHJlbG9hZHMyW3dpdGhvdXRIYXNoRnJhZ21lbnRdKSB7XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICBpZiAoaGFzaEZyYWdtZW50SW5kZXggIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJlbG9hZHMyW3dpdGhvdXRIYXNoRnJhZ21lbnRdICsgc3JjLnNsaWNlKGhhc2hGcmFnbWVudEluZGV4KTtcbiAgfVxuICByZXR1cm4gcHJlbG9hZHMyW3dpdGhvdXRIYXNoRnJhZ21lbnRdO1xufTtcbnZhciBibG9iVG9CYXNlNjQgPSBmdW5jdGlvbihibG9iKSB7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGRhdGFVcmwgPSByZWFkZXIucmVzdWx0O1xuICAgICAgcmVzb2x2ZShkYXRhVXJsKTtcbiAgICB9O1xuICAgIHJlYWRlci5vbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gIH0pO1xufTtcbnZhciBnZXRCbG9iRnJvbVJlYWRlciA9IGFzeW5jICh7XG4gIHJlYWRlcixcbiAgY29udGVudFR5cGUsXG4gIGNvbnRlbnRMZW5ndGgsXG4gIG9uUHJvZ3Jlc3Ncbn0pID0+IHtcbiAgbGV0IHJlY2VpdmVkTGVuZ3RoID0gMDtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICByZWNlaXZlZExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgIG9uUHJvZ3Jlc3MoeyBsb2FkZWRCeXRlczogcmVjZWl2ZWRMZW5ndGgsIHRvdGFsQnl0ZXM6IGNvbnRlbnRMZW5ndGggfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNodW5rc0FsbCA9IG5ldyBVaW50OEFycmF5KHJlY2VpdmVkTGVuZ3RoKTtcbiAgbGV0IHBvc2l0aW9uID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjaHVua3NBbGwuc2V0KGNodW5rLCBwb3NpdGlvbik7XG4gICAgcG9zaXRpb24gKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIHJldHVybiBuZXcgQmxvYihbY2h1bmtzQWxsXSwge1xuICAgIHR5cGU6IGNvbnRlbnRUeXBlID8/IHVuZGVmaW5lZFxuICB9KTtcbn07XG52YXIgcHJlZmV0Y2ggPSAoc3JjLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnM/Lm1ldGhvZCA/PyBcImJsb2ItdXJsXCI7XG4gIGNvbnN0IGxvZ0xldmVsID0gb3B0aW9ucz8ubG9nTGV2ZWwgPz8gXCJpbmZvXCI7XG4gIGNvbnN0IHNyY1dpdGhvdXRIYXNoID0gZ2V0U3JjV2l0aG91dEhhc2goc3JjKTtcbiAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgIHJldHVybiB7XG4gICAgICBmcmVlOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0sXG4gICAgICB3YWl0VW50aWxEb25lOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3JjV2l0aG91dEhhc2gpXG4gICAgfTtcbiAgfVxuICBMb2cudmVyYm9zZSh7IGxvZ0xldmVsLCB0YWc6IFwicHJlZmV0Y2hcIiB9LCBgU3RhcnRpbmcgcHJlZmV0Y2ggJHtzcmNXaXRob3V0SGFzaH1gKTtcbiAgbGV0IGNhbmNlbGVkID0gZmFsc2U7XG4gIGxldCBvYmplY3RVcmwgPSBudWxsO1xuICBsZXQgcmVzb2x2ZSA9ICgpID0+IHtcbiAgICByZXR1cm47XG4gIH07XG4gIGxldCByZWplY3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBjb25zdCB3YWl0VW50aWxEb25lID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgbGV0IGNhbkJlQWJvcnRlZCA9IHRydWU7XG4gIGZldGNoKHNyY1dpdGhvdXRIYXNoLCB7XG4gICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICBjcmVkZW50aWFsczogb3B0aW9ucz8uY3JlZGVudGlhbHMgPz8gdW5kZWZpbmVkXG4gIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgIGNhbkJlQWJvcnRlZCA9IGZhbHNlO1xuICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IsIHN0YXR1cyA9ICR7cmVzLnN0YXR1c31gKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyQ29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIik7XG4gICAgY29uc3QgY29udGVudFR5cGUgPSBvcHRpb25zPy5jb250ZW50VHlwZSA/PyBoZWFkZXJDb250ZW50VHlwZTtcbiAgICBjb25zdCBoYXNQcm9wZXJDb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlICYmIChjb250ZW50VHlwZS5zdGFydHNXaXRoKFwidmlkZW8vXCIpIHx8IGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoXCJhdWRpby9cIikgfHwgY29udGVudFR5cGUuc3RhcnRzV2l0aChcImltYWdlL1wiKSk7XG4gICAgaWYgKCFoYXNQcm9wZXJDb250ZW50VHlwZSkge1xuICAgICAgY29uc29sZS53YXJuKGBDYWxsZWQgcHJlZmV0Y2goKSBvbiAke3NyY1dpdGhvdXRIYXNofSB3aGljaCByZXR1cm5lZCBhIFwiQ29udGVudC1UeXBlXCIgb2YgJHtoZWFkZXJDb250ZW50VHlwZX0uIFByZWZldGNoZWQgY29udGVudCBzaG91bGQgaGF2ZSBhIHByb3BlciBjb250ZW50IHR5cGUgKHZpZGVvLy4uLiBvciBhdWRpby8uLi4pIG9yIGEgY29udGVudFR5cGUgcGFzc2VkIHRoZSBvcHRpb25zIG9mIHByZWZldGNoKCkuIE90aGVyd2lzZSwgcHJlZmV0Y2hpbmcgd2lsbCBub3Qgd29yayBwcm9wZXJseSBpbiBhbGwgYnJvd3NlcnMuYCk7XG4gICAgfVxuICAgIGlmICghcmVzLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCByZXNwb25zZSBvZiAke3NyY1dpdGhvdXRIYXNofSBoYXMgbm8gYm9keWApO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICByZXR1cm4gZ2V0QmxvYkZyb21SZWFkZXIoe1xuICAgICAgcmVhZGVyLFxuICAgICAgY29udGVudFR5cGU6IG9wdGlvbnM/LmNvbnRlbnRUeXBlID8/IGhlYWRlckNvbnRlbnRUeXBlID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiByZXMuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSA/IHBhcnNlSW50KHJlcy5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCkgOiBudWxsLFxuICAgICAgb25Qcm9ncmVzczogb3B0aW9ucz8ub25Qcm9ncmVzc1xuICAgIH0pO1xuICB9KS50aGVuKChidWYpID0+IHtcbiAgICBpZiAoIWJ1Zikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhY3R1YWxCbG9iID0gb3B0aW9ucz8uY29udGVudFR5cGUgPyBuZXcgQmxvYihbYnVmXSwgeyB0eXBlOiBvcHRpb25zLmNvbnRlbnRUeXBlIH0pIDogYnVmO1xuICAgIGlmIChtZXRob2QgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgIHJldHVybiBibG9iVG9CYXNlNjQoYWN0dWFsQmxvYik7XG4gICAgfVxuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGFjdHVhbEJsb2IpO1xuICB9KS50aGVuKCh1cmwpID0+IHtcbiAgICBpZiAoY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgIGxvZ0xldmVsLFxuICAgICAgdGFnOiBcInByZWZldGNoXCIsXG4gICAgICBtZXNzYWdlOiBgRmluaXNoZWQgcHJlZmV0Y2ggJHtzcmNXaXRob3V0SGFzaH0gd2l0aCBtZXRob2QgJHttZXRob2R9YCxcbiAgICAgIG1vdW50VGltZTogbnVsbFxuICAgIH0pO1xuICAgIG9iamVjdFVybCA9IHVybDtcbiAgICBzZXRQcmVsb2FkcygocCkgPT4gKHtcbiAgICAgIC4uLnAsXG4gICAgICBbc3JjV2l0aG91dEhhc2hdOiBvYmplY3RVcmxcbiAgICB9KSk7XG4gICAgcmVzb2x2ZShvYmplY3RVcmwpO1xuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgaWYgKGVycj8ubWVzc2FnZS5pbmNsdWRlcyhcImZyZWUoKSBjYWxsZWRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVqZWN0KGVycik7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGZyZWU6ICgpID0+IHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB0YWc6IFwicHJlZmV0Y2hcIixcbiAgICAgICAgbWVzc2FnZTogYEZyZWVpbmcgJHtzcmNXaXRob3V0SGFzaH1gLFxuICAgICAgICBtb3VudFRpbWU6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcImJsb2ItdXJsXCIpIHtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVybCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJlbG9hZHMoKHApID0+IHtcbiAgICAgICAgICBjb25zdCBjb3B5ID0geyAuLi5wIH07XG4gICAgICAgICAgZGVsZXRlIGNvcHlbc3JjV2l0aG91dEhhc2hdO1xuICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNhbkJlQWJvcnRlZCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcihcImZyZWUoKSBjYWxsZWRcIikpO1xuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgd2FpdFVudGlsRG9uZTogKCkgPT4ge1xuICAgICAgcmV0dXJuIHdhaXRVbnRpbERvbmU7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL3ZhbGlkYXRlLW1lZGlhLXByb3BzLnRzXG52YXIgdmFsaWRhdGVNZWRpYVByb3BzID0gKHByb3BzLCBjb21wb25lbnQpID0+IHtcbiAgaWYgKHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwibnVtYmVyXCIgJiYgdHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBwcm9wcy52b2x1bWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSB2b2x1bWUgb2YgdHlwZSAke3R5cGVvZiBwcm9wcy52b2x1bWV9IHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFZvbHVtZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2lnbmF0dXJlICcoZnJhbWU6IG51bWJlcikgPT4gbnVtYmVyJyB1bmRlZmluZWQuYCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9wcy52b2x1bWUgPT09IFwibnVtYmVyXCIgJiYgcHJvcHMudm9sdW1lIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHZvbHVtZSBiZWxvdyAwIHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFZvbHVtZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMWApO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMucGxheWJhY2tSYXRlICE9PSBcIm51bWJlclwiICYmIHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSBwbGF5YmFja1JhdGUgb2YgdHlwZSAke3R5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGV9IHRvIHlvdXIgPCR7Y29tcG9uZW50fSAvPiBjb21wb25lbnQuIFBsYXliYWNrIHJhdGUgbXVzdCBhIHJlYWwgbnVtYmVyIG9yIHVuZGVmaW5lZC5gKTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSA9PT0gXCJudW1iZXJcIiAmJiAoaXNOYU4ocHJvcHMucGxheWJhY2tSYXRlKSB8fCAhTnVtYmVyLmlzRmluaXRlKHByb3BzLnBsYXliYWNrUmF0ZSkgfHwgcHJvcHMucGxheWJhY2tSYXRlIDw9IDApKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgcGxheWJhY2tSYXRlIG9mICR7cHJvcHMucGxheWJhY2tSYXRlfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBQbGF5YmFjayByYXRlIG11c3QgYmUgYSByZWFsIG51bWJlciBhYm92ZSAwLmApO1xuICB9XG59O1xuXG4vLyBzcmMvdmFsaWRhdGUtc3RhcnQtZnJvbS1wcm9wcy50c1xudmFyIHZhbGlkYXRlU3RhcnRGcm9tUHJvcHMgPSAoc3RhcnRGcm9tLCBlbmRBdCkgPT4ge1xuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIHN0YXJ0RnJvbSBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2Ygc3RhcnRGcm9tfS5gKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHN0YXJ0RnJvbSkgfHwgc3RhcnRGcm9tID09PSBJbmZpbml0eSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInN0YXJ0RnJvbSBwcm9wIGNhbiBub3QgYmUgTmFOIG9yIEluZmluaXR5LlwiKTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0RnJvbSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXJ0RnJvbSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBlcXVhbCB0byAwIGluc3RlYWQgZ290ICR7c3RhcnRGcm9tfS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBlbmRBdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2YgZW5kQXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHR5cGUgb2YgZW5kQXQgcHJvcCBtdXN0IGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCB0eXBlICR7dHlwZW9mIGVuZEF0fS5gKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGVuZEF0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuZEF0IHByb3AgY2FuIG5vdCBiZSBOYU4uXCIpO1xuICAgIH1cbiAgICBpZiAoZW5kQXQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZW5kQXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciwgaW5zdGVhZCBnb3QgJHtlbmRBdH0uYCk7XG4gICAgfVxuICB9XG4gIGlmIChlbmRBdCA8IHN0YXJ0RnJvbSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJlbmRBdCBwcm9wIG11c3QgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0RnJvbSBwcm9wLlwiKTtcbiAgfVxufTtcbnZhciB2YWxpZGF0ZVRyaW1Qcm9wcyA9ICh0cmltQmVmb3JlLCB0cmltQWZ0ZXIpID0+IHtcbiAgaWYgKHR5cGVvZiB0cmltQmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHR5cGVvZiB0cmltQmVmb3JlICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIHRyaW1CZWZvcmUgcHJvcCBtdXN0IGJlIGEgbnVtYmVyLCBpbnN0ZWFkIGdvdCB0eXBlICR7dHlwZW9mIHRyaW1CZWZvcmV9LmApO1xuICAgIH1cbiAgICBpZiAoaXNOYU4odHJpbUJlZm9yZSkgfHwgdHJpbUJlZm9yZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0cmltQmVmb3JlIHByb3AgY2FuIG5vdCBiZSBOYU4gb3IgSW5maW5pdHkuXCIpO1xuICAgIH1cbiAgICBpZiAodHJpbUJlZm9yZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRyaW1CZWZvcmUgbXVzdCBiZSBncmVhdGVyIHRoYW4gZXF1YWwgdG8gMCBpbnN0ZWFkIGdvdCAke3RyaW1CZWZvcmV9LmApO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHRyaW1BZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGlmICh0eXBlb2YgdHJpbUFmdGVyICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIHRyaW1BZnRlciBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2YgdHJpbUFmdGVyfS5gKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRyaW1BZnRlcikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ0cmltQWZ0ZXIgcHJvcCBjYW4gbm90IGJlIE5hTi5cIik7XG4gICAgfVxuICAgIGlmICh0cmltQWZ0ZXIgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdHJpbUFmdGVyIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIGluc3RlYWQgZ290ICR7dHJpbUFmdGVyfS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRyaW1BZnRlciA8PSB0cmltQmVmb3JlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRyaW1BZnRlciBwcm9wIG11c3QgYmUgZ3JlYXRlciB0aGFuIHRyaW1CZWZvcmUgcHJvcC5cIik7XG4gIH1cbn07XG52YXIgdmFsaWRhdGVNZWRpYVRyaW1Qcm9wcyA9ICh7XG4gIHN0YXJ0RnJvbSxcbiAgZW5kQXQsXG4gIHRyaW1CZWZvcmUsXG4gIHRyaW1BZnRlclxufSkgPT4ge1xuICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgdHJpbUJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlIGJvdGggc3RhcnRGcm9tIGFuZCB0cmltQmVmb3JlIHByb3BzLiBVc2UgdHJpbUJlZm9yZSBpbnN0ZWFkIGFzIHN0YXJ0RnJvbSBpcyBkZXByZWNhdGVkLlwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuZEF0ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB0cmltQWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSBib3RoIGVuZEF0IGFuZCB0cmltQWZ0ZXIgcHJvcHMuIFVzZSB0cmltQWZ0ZXIgaW5zdGVhZCBhcyBlbmRBdCBpcyBkZXByZWNhdGVkLlwiKTtcbiAgfVxuICBjb25zdCBoYXNOZXdQcm9wcyA9IHR5cGVvZiB0cmltQmVmb3JlICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmltQWZ0ZXIgIT09IFwidW5kZWZpbmVkXCI7XG4gIGNvbnN0IGhhc09sZFByb3BzID0gdHlwZW9mIHN0YXJ0RnJvbSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZW5kQXQgIT09IFwidW5kZWZpbmVkXCI7XG4gIGlmIChoYXNOZXdQcm9wcykge1xuICAgIHZhbGlkYXRlVHJpbVByb3BzKHRyaW1CZWZvcmUsIHRyaW1BZnRlcik7XG4gIH0gZWxzZSBpZiAoaGFzT2xkUHJvcHMpIHtcbiAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICB9XG59O1xudmFyIHJlc29sdmVUcmltUHJvcHMgPSAoe1xuICBzdGFydEZyb20sXG4gIGVuZEF0LFxuICB0cmltQmVmb3JlLFxuICB0cmltQWZ0ZXJcbn0pID0+IHtcbiAgY29uc3QgdHJpbUJlZm9yZVZhbHVlID0gdHJpbUJlZm9yZSA/PyBzdGFydEZyb20gPz8gdW5kZWZpbmVkO1xuICBjb25zdCB0cmltQWZ0ZXJWYWx1ZSA9IHRyaW1BZnRlciA/PyBlbmRBdCA/PyB1bmRlZmluZWQ7XG4gIHJldHVybiB7IHRyaW1CZWZvcmVWYWx1ZSwgdHJpbUFmdGVyVmFsdWUgfTtcbn07XG5cbi8vIHNyYy92aWRlby9kdXJhdGlvbi1zdGF0ZS50c3hcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDEzLCB1c2VNZW1vIGFzIHVzZU1lbW8xMiwgdXNlUmVkdWNlciB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDE0IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgZHVyYXRpb25SZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgXCJnb3QtZHVyYXRpb25cIjoge1xuICAgICAgY29uc3QgYWJzb2x1dGVTcmMgPSBnZXRBYnNvbHV0ZVNyYyhhY3Rpb24uc3JjKTtcbiAgICAgIGlmIChzdGF0ZVthYnNvbHV0ZVNyY10gPT09IGFjdGlvbi5kdXJhdGlvbkluU2Vjb25kcykge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2Fic29sdXRlU3JjXTogYWN0aW9uLmR1cmF0aW9uSW5TZWNvbmRzXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59O1xudmFyIER1cmF0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0MTMoe1xuICBkdXJhdGlvbnM6IHt9LFxuICBzZXREdXJhdGlvbnM6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZXh0IG1pc3NpbmdcIik7XG4gIH1cbn0pO1xudmFyIER1cmF0aW9uc0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgW2R1cmF0aW9ucywgc2V0RHVyYXRpb25zXSA9IHVzZVJlZHVjZXIoZHVyYXRpb25SZWR1Y2VyLCB7fSk7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzEyKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZHVyYXRpb25zLFxuICAgICAgc2V0RHVyYXRpb25zXG4gICAgfTtcbiAgfSwgW2R1cmF0aW9uc10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE0KER1cmF0aW9uc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY0LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyNCxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU1LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yMCxcbiAgdXNlUmVmIGFzIHVzZVJlZjExLFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE0XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvZ2V0LWNyb3NzLW9yaWdpbi12YWx1ZS50c1xudmFyIGdldENyb3NzT3JpZ2luVmFsdWUgPSAoe1xuICBjcm9zc09yaWdpbixcbiAgcmVxdWVzdHNWaWRlb0ZyYW1lXG59KSA9PiB7XG4gIGlmIChjcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICYmIGNyb3NzT3JpZ2luICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNyb3NzT3JpZ2luO1xuICB9XG4gIGlmIChyZXF1ZXN0c1ZpZGVvRnJhbWUpIHtcbiAgICByZXR1cm4gXCJhbm9ueW1vdXNcIjtcbiAgfVxuICByZXR1cm47XG59O1xuXG4vLyBzcmMvbG9nLWxldmVsLWNvbnRleHQudHN4XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QxMyBmcm9tIFwicmVhY3RcIjtcbnZhciBMb2dMZXZlbENvbnRleHQgPSBjcmVhdGVDb250ZXh0MTQoe1xuICBsb2dMZXZlbDogXCJpbmZvXCIsXG4gIG1vdW50VGltZTogMFxufSk7XG52YXIgdXNlTG9nTGV2ZWwgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbG9nTGV2ZWwgfSA9IFJlYWN0MTMudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICBpZiAobG9nTGV2ZWwgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VMb2dMZXZlbCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgTG9nTGV2ZWxQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gbG9nTGV2ZWw7XG59O1xudmFyIHVzZU1vdW50VGltZSA9ICgpID0+IHtcbiAgY29uc3QgeyBtb3VudFRpbWUgfSA9IFJlYWN0MTMudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICBpZiAobW91bnRUaW1lID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTW91bnRUaW1lIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBMb2dMZXZlbFByb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBtb3VudFRpbWU7XG59O1xuXG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcblxuLy8gc3JjL3VzZS1hbXBsaWZpY2F0aW9uLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNiwgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDMsIHVzZVJlZiBhcyB1c2VSZWY2IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9hdWRpby9zaGFyZWQtYXVkaW8tdGFncy50c3hcbmltcG9ydCBSZWFjdDE0LCB7XG4gIGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE1LFxuICBjcmVhdGVSZWYgYXMgY3JlYXRlUmVmMixcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2s3LFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQxNSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDcsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzE0LFxuICB1c2VSZWYgYXMgdXNlUmVmNCxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMFxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3BsYXktYW5kLWhhbmRsZS1ub3QtYWxsb3dlZC1lcnJvci50c1xudmFyIHBsYXlBbmRIYW5kbGVOb3RBbGxvd2VkRXJyb3IgPSAoe1xuICBtZWRpYVJlZixcbiAgbWVkaWFUeXBlLFxuICBvbkF1dG9QbGF5RXJyb3IsXG4gIGxvZ0xldmVsLFxuICBtb3VudFRpbWUsXG4gIHJlYXNvbixcbiAgaXNQbGF5ZXJcbn0pID0+IHtcbiAgY29uc3QgeyBjdXJyZW50IH0gPSBtZWRpYVJlZjtcbiAgaWYgKCFjdXJyZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgbG9nTGV2ZWwsXG4gICAgdGFnOiBcInBsYXlcIixcbiAgICBtZXNzYWdlOiBgQXR0ZW1wdGluZyB0byBwbGF5ICR7Y3VycmVudC5zcmN9LiBSZWFzb246ICR7cmVhc29ufWAsXG4gICAgbW91bnRUaW1lXG4gIH0pO1xuICBjb25zdCBwcm9tID0gY3VycmVudC5wbGF5KCk7XG4gIGlmICghcHJvbS5jYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICBwcm9tLmNhdGNoKChlcnIpID0+IHtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwicmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBjYWxsIHRvIHBhdXNlXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIlRoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuXCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcIlRoZSBmZXRjaGluZyBwcm9jZXNzIGZvciB0aGUgbWVkaWEgcmVzb3VyY2Ugd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIgYWdlbnRcIikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwicmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBuZXcgbG9hZCByZXF1ZXN0XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcImJlY2F1c2UgdGhlIG1lZGlhIHdhcyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcInVzZXIgZGlkbid0IGludGVyYWN0IHdpdGggdGhlIGRvY3VtZW50XCIpICYmIGN1cnJlbnQubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5sb2coYENvdWxkIG5vdCBwbGF5ICR7bWVkaWFUeXBlfSBkdWUgdG8gZm9sbG93aW5nIGVycm9yOiBgLCBlcnIpO1xuICAgIGlmICghY3VycmVudC5tdXRlZCkge1xuICAgICAgaWYgKG9uQXV0b1BsYXlFcnJvcikge1xuICAgICAgICBvbkF1dG9QbGF5RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFRoZSB2aWRlbyB3aWxsIGJlIG11dGVkIGFuZCB3ZSdsbCByZXRyeSBwbGF5aW5nIGl0LmApO1xuICAgICAgaWYgKG1lZGlhVHlwZSA9PT0gXCJ2aWRlb1wiICYmIGlzUGxheWVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVXNlIG9uQXV0b1BsYXlFcnJvcigpIHRvIGhhbmRsZSB0aGlzIGVycm9yIHlvdXJzZWxmLlwiKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgY3VycmVudC5wbGF5KCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIHNyYy9hdWRpby9zaGFyZWQtZWxlbWVudC1zb3VyY2Utbm9kZS50c1xudmFyIG1ha2VTaGFyZWRFbGVtZW50U291cmNlTm9kZSA9ICh7XG4gIGF1ZGlvQ29udGV4dCxcbiAgcmVmXG59KSA9PiB7XG4gIGxldCBjb25uZWN0ZWQgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIGF0dGVtcHRUb0Nvbm5lY3Q6ICgpID0+IHtcbiAgICAgIGlmICghY29ubmVjdGVkICYmIHJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhRWxlbWVudFNvdXJjZU5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKHJlZi5jdXJyZW50KTtcbiAgICAgICAgY29ubmVjdGVkID0gbWVkaWFFbGVtZW50U291cmNlTm9kZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogKCkgPT4ge1xuICAgICAgaWYgKCFjb25uZWN0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXVkaW8gZWxlbWVudCBub3QgY29ubmVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbm5lY3RlZDtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvYXVkaW8vdXNlLWF1ZGlvLWNvbnRleHQudHNcbmltcG9ydCB7IHVzZU1lbW8gYXMgdXNlTWVtbzEzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgd2FybmVkID0gZmFsc2U7XG52YXIgd2Fybk9uY2UgPSAobG9nTGV2ZWwpID0+IHtcbiAgaWYgKHdhcm5lZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuZWQgPSB0cnVlO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIExvZy53YXJuKHsgbG9nTGV2ZWwsIHRhZzogbnVsbCB9LCBcIkF1ZGlvQ29udGV4dCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbiAgfVxufTtcbnZhciB1c2VTaW5nbGV0b25BdWRpb0NvbnRleHQgPSAobG9nTGV2ZWwsIGxhdGVuY3lIaW50KSA9PiB7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZU1lbW8xMygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBBdWRpb0NvbnRleHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHdhcm5PbmNlKGxvZ0xldmVsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEF1ZGlvQ29udGV4dCh7XG4gICAgICBsYXRlbmN5SGludFxuICAgIH0pO1xuICB9LCBbbG9nTGV2ZWwsIGxhdGVuY3lIaW50XSk7XG4gIHJldHVybiBhdWRpb0NvbnRleHQ7XG59O1xuXG4vLyBzcmMvYXVkaW8vc2hhcmVkLWF1ZGlvLXRhZ3MudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTUsIGpzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBFTVBUWV9BVURJTyA9IFwiZGF0YTphdWRpby9tcDM7YmFzZTY0LC8rTVl4QUFKY0FWOEFBZ0FBQm4vLy8vLy8rL2dRNUJBTUErRDRQZytCQVFCQUVBd0Q0UGcrRDRFQkFFQVFEQVBnKytoWUJILy8vaFVGUVZCVUZSRURRTkhtZi8vLy8vLy8rTVl4QlVHa0FHSU1BQUFBUC8yOVh0NmxVeEJUVVV6TGpFd01GVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVi8rTVl4RFVBQUFOSUFBQUFBRlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlwiO1xudmFyIGNvbXBhcmVQcm9wcyA9IChvYmoxLCBvYmoyKSA9PiB7XG4gIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMob2JqMSkuc29ydCgpO1xuICBjb25zdCBrZXlzQiA9IE9iamVjdC5rZXlzKG9iajIpLnNvcnQoKTtcbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwO2kgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChrZXlzQVtpXSAhPT0ga2V5c0JbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9iajFba2V5c0FbaV1dICE9PSBvYmoyW2tleXNCW2ldXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZGlkUHJvcENoYW5nZSA9IChrZXksIG5ld1Byb3AsIHByZXZQcm9wKSA9PiB7XG4gIGlmIChrZXkgPT09IFwic3JjXCIgJiYgIXByZXZQcm9wLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSAmJiAhbmV3UHJvcC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICByZXR1cm4gbmV3IFVSTChwcmV2UHJvcCwgd2luZG93Lm9yaWdpbikudG9TdHJpbmcoKSAhPT0gbmV3IFVSTChuZXdQcm9wLCB3aW5kb3cub3JpZ2luKS50b1N0cmluZygpO1xuICB9XG4gIGlmIChwcmV2UHJvcCA9PT0gbmV3UHJvcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgU2hhcmVkQXVkaW9Db250ZXh0ID0gY3JlYXRlQ29udGV4dDE1KG51bGwpO1xudmFyIFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIG51bWJlck9mQXVkaW9UYWdzLCBjb21wb25lbnQsIGF1ZGlvTGF0ZW5jeUhpbnQgfSkgPT4ge1xuICBjb25zdCBhdWRpb3MgPSB1c2VSZWY0KFtdKTtcbiAgY29uc3QgW2luaXRpYWxOdW1iZXJPZkF1ZGlvVGFnc10gPSB1c2VTdGF0ZTEwKG51bWJlck9mQXVkaW9UYWdzKTtcbiAgaWYgKG51bWJlck9mQXVkaW9UYWdzICE9PSBpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbnVtYmVyIG9mIHNoYXJlZCBhdWRpbyB0YWdzIGhhcyBjaGFuZ2VkIGR5bmFtaWNhbGx5LiBPbmNlIHlvdSBoYXZlIHNldCB0aGlzIHByb3BlcnR5LCB5b3UgY2Fubm90IGNoYW5nZSBpdCBhZnRlcndhcmRzLlwiKTtcbiAgfVxuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZVNpbmdsZXRvbkF1ZGlvQ29udGV4dChsb2dMZXZlbCwgYXVkaW9MYXRlbmN5SGludCk7XG4gIGNvbnN0IHJlZnMgPSB1c2VNZW1vMTQoKCkgPT4ge1xuICAgIHJldHVybiBuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwodHJ1ZSkubWFwKCgpID0+IHtcbiAgICAgIGNvbnN0IHJlZiA9IGNyZWF0ZVJlZjIoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICByZWYsXG4gICAgICAgIG1lZGlhRWxlbWVudFNvdXJjZU5vZGU6IGF1ZGlvQ29udGV4dCA/IG1ha2VTaGFyZWRFbGVtZW50U291cmNlTm9kZSh7XG4gICAgICAgICAgYXVkaW9Db250ZXh0LFxuICAgICAgICAgIHJlZlxuICAgICAgICB9KSA6IG51bGxcbiAgICAgIH07XG4gICAgfSk7XG4gIH0sIFthdWRpb0NvbnRleHQsIG51bWJlck9mQXVkaW9UYWdzXSk7XG4gIGNvbnN0IHRha2VuQXVkaW9zID0gdXNlUmVmNChuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwoZmFsc2UpKTtcbiAgY29uc3QgcmVyZW5kZXJBdWRpb3MgPSB1c2VDYWxsYmFjazcoKCkgPT4ge1xuICAgIHJlZnMuZm9yRWFjaCgoeyByZWYsIGlkIH0pID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBhdWRpb3MuY3VycmVudD8uZmluZCgoYSkgPT4gYS5pZCA9PT0gaWQpO1xuICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSByZWY7XG4gICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdXJyZW50LnNyYyA9IEVNUFRZX0FVRElPO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGF1ZGlvIGRhdGEgdG8gYmUgdGhlcmVcIik7XG4gICAgICB9XG4gICAgICBPYmplY3Qua2V5cyhkYXRhLnByb3BzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGRpZFByb3BDaGFuZ2Uoa2V5LCBkYXRhLnByb3BzW2tleV0sIGN1cnJlbnRba2V5XSkpIHtcbiAgICAgICAgICBjdXJyZW50W2tleV0gPSBkYXRhLnByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBbcmVmc10pO1xuICBjb25zdCByZWdpc3RlckF1ZGlvID0gdXNlQ2FsbGJhY2s3KChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBhdWQsIGF1ZGlvSWQsIHByZW1vdW50aW5nIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGZvdW5kID0gYXVkaW9zLmN1cnJlbnQ/LmZpbmQoKGEpID0+IGEuYXVkaW9JZCA9PT0gYXVkaW9JZCk7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0RnJlZUF1ZGlvID0gdGFrZW5BdWRpb3MuY3VycmVudC5maW5kSW5kZXgoKGEpID0+IGEgPT09IGZhbHNlKTtcbiAgICBpZiAoZmlyc3RGcmVlQXVkaW8gPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIHNpbXVsdGFuZW91c2x5IG1vdW50ICR7bnVtYmVyT2ZBdWRpb1RhZ3MgKyAxfSA8SHRtbDVBdWRpbyAvPiB0YWdzIGF0IHRoZSBzYW1lIHRpbWUuIFdpdGggdGhlIGN1cnJlbnQgc2V0dGluZ3MsIHRoZSBtYXhpbXVtIGFtb3VudCBvZiA8SHRtbDVBdWRpbyAvPiB0YWdzIGlzIGxpbWl0ZWQgdG8gJHtudW1iZXJPZkF1ZGlvVGFnc30gYXQgdGhlIHNhbWUgdGltZS4gUmVtb3Rpb24gcHJlLW1vdW50cyBzaWxlbnQgYXVkaW8gdGFncyB0byBoZWxwIGF2b2lkIGJyb3dzZXIgYXV0b3BsYXkgcmVzdHJpY3Rpb25zLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvYXV0b3BsYXkjdXNpbmctdGhlLW51bWJlcm9mc2hhcmVkYXVkaW90YWdzLXByb3AgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaG93IHRvIGluY3JlYXNlIHRoaXMgbGltaXQuYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgaWQsIHJlZiwgbWVkaWFFbGVtZW50U291cmNlTm9kZSB9ID0gcmVmc1tmaXJzdEZyZWVBdWRpb107XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNsb25lZFtmaXJzdEZyZWVBdWRpb10gPSBpZDtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGNvbnN0IG5ld0VsZW0gPSB7XG4gICAgICBwcm9wczogYXVkLFxuICAgICAgaWQsXG4gICAgICBlbDogcmVmLFxuICAgICAgYXVkaW9JZCxcbiAgICAgIG1lZGlhRWxlbWVudFNvdXJjZU5vZGUsXG4gICAgICBwcmVtb3VudGluZ1xuICAgIH07XG4gICAgYXVkaW9zLmN1cnJlbnQ/LnB1c2gobmV3RWxlbSk7XG4gICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICByZXR1cm4gbmV3RWxlbTtcbiAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1bnJlZ2lzdGVyQXVkaW8gPSB1c2VDYWxsYmFjazcoKGlkKSA9PiB7XG4gICAgY29uc3QgY2xvbmVkID0gWy4uLnRha2VuQXVkaW9zLmN1cnJlbnRdO1xuICAgIGNvbnN0IGluZGV4ID0gcmVmcy5maW5kSW5kZXgoKHIpID0+IHIuaWQgPT09IGlkKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXJyb3Igb2NjdXJlZCBpbiBcIik7XG4gICAgfVxuICAgIGNsb25lZFtpbmRleF0gPSBmYWxzZTtcbiAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/LmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gIH0sIFtyZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCB1cGRhdGVBdWRpbyA9IHVzZUNhbGxiYWNrNygoe1xuICAgIGF1ZCxcbiAgICBhdWRpb0lkLFxuICAgIGlkLFxuICAgIHByZW1vdW50aW5nXG4gIH0pID0+IHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGF1ZGlvcy5jdXJyZW50ID0gYXVkaW9zLmN1cnJlbnQ/Lm1hcCgocHJldkEpID0+IHtcbiAgICAgIGlmIChwcmV2QS5pZCA9PT0gaWQpIHtcbiAgICAgICAgY29uc3QgaXNUaGVTYW1lID0gY29tcGFyZVByb3BzKGF1ZCwgcHJldkEucHJvcHMpICYmIHByZXZBLnByZW1vdW50aW5nID09PSBwcmVtb3VudGluZztcbiAgICAgICAgaWYgKGlzVGhlU2FtZSkge1xuICAgICAgICAgIHJldHVybiBwcmV2QTtcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5wcmV2QSxcbiAgICAgICAgICBwcm9wczogYXVkLFxuICAgICAgICAgIHByZW1vdW50aW5nLFxuICAgICAgICAgIGF1ZGlvSWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmV2QTtcbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICB9XG4gIH0sIFtyZXJlbmRlckF1ZGlvc10pO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBwbGF5QWxsQXVkaW9zID0gdXNlQ2FsbGJhY2s3KCgpID0+IHtcbiAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgY29uc3QgYXVkaW8gPSBhdWRpb3MuY3VycmVudC5maW5kKChhKSA9PiBhLmVsID09PSByZWYucmVmKTtcbiAgICAgIGlmIChhdWRpbz8ucHJlbW91bnRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgIG1lZGlhUmVmOiByZWYucmVmLFxuICAgICAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICAgICAgb25BdXRvUGxheUVycm9yOiBudWxsLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICByZWFzb246IFwicGxheWluZyBhbGwgYXVkaW9zXCIsXG4gICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF1ZGlvQ29udGV4dD8ucmVzdW1lKCk7XG4gIH0sIFthdWRpb0NvbnRleHQsIGxvZ0xldmVsLCBtb3VudFRpbWUsIHJlZnMsIGVudi5pc1BsYXllcl0pO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8xNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVyQXVkaW8sXG4gICAgICB1bnJlZ2lzdGVyQXVkaW8sXG4gICAgICB1cGRhdGVBdWRpbyxcbiAgICAgIHBsYXlBbGxBdWRpb3MsXG4gICAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICAgIGF1ZGlvQ29udGV4dFxuICAgIH07XG4gIH0sIFtcbiAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICBwbGF5QWxsQXVkaW9zLFxuICAgIHJlZ2lzdGVyQXVkaW8sXG4gICAgdW5yZWdpc3RlckF1ZGlvLFxuICAgIHVwZGF0ZUF1ZGlvLFxuICAgIGF1ZGlvQ29udGV4dFxuICBdKTtcbiAgY29uc3QgcmVzZXRBdWRpbyA9IHVzZUNhbGxiYWNrNygoKSA9PiB7XG4gICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IG5ldyBBcnJheShudW1iZXJPZkF1ZGlvVGFncykuZmlsbChmYWxzZSk7XG4gICAgYXVkaW9zLmN1cnJlbnQgPSBbXTtcbiAgICByZXJlbmRlckF1ZGlvcygpO1xuICB9LCBbbnVtYmVyT2ZBdWRpb1RhZ3MsIHJlcmVuZGVyQXVkaW9zXSk7XG4gIHVzZUVmZmVjdDcoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXNldEF1ZGlvKCk7XG4gICAgfTtcbiAgfSwgW2NvbXBvbmVudCwgcmVzZXRBdWRpb10pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoU2hhcmVkQXVkaW9Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIHJlZnMubWFwKCh7IGlkLCByZWYgfSkgPT4ge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE1KFwiYXVkaW9cIiwge1xuICAgICAgICAgIHJlZixcbiAgICAgICAgICBwcmVsb2FkOiBcIm1ldGFkYXRhXCIsXG4gICAgICAgICAgc3JjOiBFTVBUWV9BVURJT1xuICAgICAgICB9LCBpZCk7XG4gICAgICB9KSxcbiAgICAgIGNoaWxkcmVuXG4gICAgXVxuICB9KTtcbn07XG52YXIgdXNlU2hhcmVkQXVkaW8gPSAoe1xuICBhdWQsXG4gIGF1ZGlvSWQsXG4gIHByZW1vdW50aW5nXG59KSA9PiB7XG4gIGNvbnN0IGN0eCA9IHVzZUNvbnRleHQxNShTaGFyZWRBdWRpb0NvbnRleHQpO1xuICBjb25zdCBbZWxlbV0gPSB1c2VTdGF0ZTEwKCgpID0+IHtcbiAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgIHJldHVybiBjdHgucmVnaXN0ZXJBdWRpbyh7IGF1ZCwgYXVkaW9JZCwgcHJlbW91bnRpbmcgfSk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gUmVhY3QxNC5jcmVhdGVSZWYoKTtcbiAgICBjb25zdCBtZWRpYUVsZW1lbnRTb3VyY2VOb2RlID0gY3R4Py5hdWRpb0NvbnRleHQgPyBtYWtlU2hhcmVkRWxlbWVudFNvdXJjZU5vZGUoe1xuICAgICAgYXVkaW9Db250ZXh0OiBjdHguYXVkaW9Db250ZXh0LFxuICAgICAgcmVmOiBlbFxuICAgIH0pIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgZWwsXG4gICAgICBpZDogTWF0aC5yYW5kb20oKSxcbiAgICAgIHByb3BzOiBhdWQsXG4gICAgICBhdWRpb0lkLFxuICAgICAgbWVkaWFFbGVtZW50U291cmNlTm9kZSxcbiAgICAgIHByZW1vdW50aW5nXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGVmZmVjdFRvVXNlID0gUmVhY3QxNC51c2VJbnNlcnRpb25FZmZlY3QgPz8gUmVhY3QxNC51c2VMYXlvdXRFZmZlY3Q7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBlZmZlY3RUb1VzZSgoKSA9PiB7XG4gICAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgICAgY3R4LnVwZGF0ZUF1ZGlvKHsgaWQ6IGVsZW0uaWQsIGF1ZCwgYXVkaW9JZCwgcHJlbW91bnRpbmcgfSk7XG4gICAgICB9XG4gICAgfSwgW2F1ZCwgY3R4LCBlbGVtLmlkLCBhdWRpb0lkLCBwcmVtb3VudGluZ10pO1xuICAgIGVmZmVjdFRvVXNlKCgpID0+IHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm51bWJlck9mQXVkaW9UYWdzID4gMCkge1xuICAgICAgICAgIGN0eC51bnJlZ2lzdGVyQXVkaW8oZWxlbS5pZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSwgW2N0eCwgZWxlbS5pZF0pO1xuICB9XG4gIHJldHVybiBlbGVtO1xufTtcblxuLy8gc3JjL2lzLWFwcHJveGltYXRlbHktdGhlLXNhbWUudHNcbnZhciBGTE9BVElOR19QT0lOVF9FUlJPUl9USFJFU0hPTEQgPSAwLjAwMDAxO1xudmFyIGlzQXBwcm94aW1hdGVseVRoZVNhbWUgPSAobnVtMSwgbnVtMikgPT4ge1xuICByZXR1cm4gTWF0aC5hYnMobnVtMSAtIG51bTIpIDwgRkxPQVRJTkdfUE9JTlRfRVJST1JfVEhSRVNIT0xEO1xufTtcblxuLy8gc3JjL3ZpZGVvL3ZpZGVvLWZyYWdtZW50LnRzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmNSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHRvU2Vjb25kcyA9ICh0aW1lLCBmcHMpID0+IHtcbiAgcmV0dXJuIE1hdGgucm91bmQodGltZSAvIGZwcyAqIDEwMCkgLyAxMDA7XG59O1xudmFyIGlzU2FmYXJpID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBpc0FwcGxlV2ViS2l0ID0gL0FwcGxlV2ViS2l0Ly50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgaWYgKCFpc0FwcGxlV2ViS2l0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGlzTm90Q2hyb21lID0gIXdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiQ2hyb21lL1wiKTtcbiAgcmV0dXJuIGlzTm90Q2hyb21lO1xufTtcbnZhciBpc0lvc1NhZmFyaSA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaXNJcGFkSVBvZElQaG9uZSA9IC9pUChhZHxvZHxob25lKS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXR1cm4gaXNJcGFkSVBvZElQaG9uZSAmJiBpc1NhZmFyaSgpO1xufTtcbnZhciBpc0lPU1NhZmFyaUFuZEJsb2IgPSAoYWN0dWFsU3JjKSA9PiB7XG4gIHJldHVybiBpc0lvc1NhZmFyaSgpICYmIGFjdHVhbFNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIik7XG59O1xudmFyIGdldFZpZGVvRnJhZ21lbnRTdGFydCA9ICh7XG4gIGFjdHVhbEZyb20sXG4gIGZwc1xufSkgPT4ge1xuICByZXR1cm4gdG9TZWNvbmRzKE1hdGgubWF4KDAsIC1hY3R1YWxGcm9tKSwgZnBzKTtcbn07XG52YXIgZ2V0VmlkZW9GcmFnbWVudEVuZCA9ICh7XG4gIGR1cmF0aW9uLFxuICBmcHNcbn0pID0+IHtcbiAgcmV0dXJuIHRvU2Vjb25kcyhkdXJhdGlvbiwgZnBzKTtcbn07XG52YXIgYXBwZW5kVmlkZW9GcmFnbWVudCA9ICh7XG4gIGFjdHVhbFNyYyxcbiAgYWN0dWFsRnJvbSxcbiAgZHVyYXRpb24sXG4gIGZwc1xufSkgPT4ge1xuICBpZiAoaXNJT1NTYWZhcmlBbmRCbG9iKGFjdHVhbFNyYykpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGlmIChhY3R1YWxTcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgfVxuICBjb25zdCBleGlzdGluZ0hhc2ggPSBCb29sZWFuKG5ldyBVUkwoYWN0dWFsU3JjLCAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiB3aW5kb3cubG9jYXRpb24uaHJlZikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjMwMDBcIikuaGFzaCk7XG4gIGlmIChleGlzdGluZ0hhc2gpIHtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGFjdHVhbEZyb20pKSB7XG4gICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgfVxuICBjb25zdCB3aXRoU3RhcnRIYXNoID0gYCR7YWN0dWFsU3JjfSN0PSR7Z2V0VmlkZW9GcmFnbWVudFN0YXJ0KHsgYWN0dWFsRnJvbSwgZnBzIH0pfWA7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSkge1xuICAgIHJldHVybiB3aXRoU3RhcnRIYXNoO1xuICB9XG4gIHJldHVybiBgJHt3aXRoU3RhcnRIYXNofSwke2dldFZpZGVvRnJhZ21lbnRFbmQoeyBkdXJhdGlvbiwgZnBzIH0pfWA7XG59O1xudmFyIGlzU3Vic2V0T2ZEdXJhdGlvbiA9ICh7XG4gIHByZXZTdGFydEZyb20sXG4gIG5ld1N0YXJ0RnJvbSxcbiAgcHJldkR1cmF0aW9uLFxuICBuZXdEdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGNvbnN0IHByZXZpb3VzRnJvbSA9IGdldFZpZGVvRnJhZ21lbnRTdGFydCh7IGFjdHVhbEZyb206IHByZXZTdGFydEZyb20sIGZwcyB9KTtcbiAgY29uc3QgbmV3RnJvbSA9IGdldFZpZGVvRnJhZ21lbnRTdGFydCh7IGFjdHVhbEZyb206IG5ld1N0YXJ0RnJvbSwgZnBzIH0pO1xuICBjb25zdCBwcmV2aW91c0VuZCA9IGdldFZpZGVvRnJhZ21lbnRFbmQoeyBkdXJhdGlvbjogcHJldkR1cmF0aW9uLCBmcHMgfSk7XG4gIGNvbnN0IG5ld0VuZCA9IGdldFZpZGVvRnJhZ21lbnRFbmQoeyBkdXJhdGlvbjogbmV3RHVyYXRpb24sIGZwcyB9KTtcbiAgaWYgKG5ld0Zyb20gPCBwcmV2aW91c0Zyb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5ld0VuZCA+IHByZXZpb3VzRW5kKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciB1c2VBcHBlbmRWaWRlb0ZyYWdtZW50ID0gKHtcbiAgYWN0dWFsU3JjOiBpbml0aWFsQWN0dWFsU3JjLFxuICBhY3R1YWxGcm9tOiBpbml0aWFsQWN0dWFsRnJvbSxcbiAgZHVyYXRpb246IGluaXRpYWxEdXJhdGlvbixcbiAgZnBzXG59KSA9PiB7XG4gIGNvbnN0IGFjdHVhbEZyb21SZWYgPSB1c2VSZWY1KGluaXRpYWxBY3R1YWxGcm9tKTtcbiAgY29uc3QgYWN0dWFsRHVyYXRpb24gPSB1c2VSZWY1KGluaXRpYWxEdXJhdGlvbik7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVJlZjUoaW5pdGlhbEFjdHVhbFNyYyk7XG4gIGlmICghaXNTdWJzZXRPZkR1cmF0aW9uKHtcbiAgICBwcmV2U3RhcnRGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgbmV3U3RhcnRGcm9tOiBpbml0aWFsQWN0dWFsRnJvbSxcbiAgICBwcmV2RHVyYXRpb246IGFjdHVhbER1cmF0aW9uLmN1cnJlbnQsXG4gICAgbmV3RHVyYXRpb246IGluaXRpYWxEdXJhdGlvbixcbiAgICBmcHNcbiAgfSkgfHwgaW5pdGlhbEFjdHVhbFNyYyAhPT0gYWN0dWFsU3JjLmN1cnJlbnQpIHtcbiAgICBhY3R1YWxGcm9tUmVmLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsRnJvbTtcbiAgICBhY3R1YWxEdXJhdGlvbi5jdXJyZW50ID0gaW5pdGlhbER1cmF0aW9uO1xuICAgIGFjdHVhbFNyYy5jdXJyZW50ID0gaW5pdGlhbEFjdHVhbFNyYztcbiAgfVxuICBjb25zdCBhcHBlbmRlZCA9IGFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgIGFjdHVhbFNyYzogYWN0dWFsU3JjLmN1cnJlbnQsXG4gICAgYWN0dWFsRnJvbTogYWN0dWFsRnJvbVJlZi5jdXJyZW50LFxuICAgIGR1cmF0aW9uOiBhY3R1YWxEdXJhdGlvbi5jdXJyZW50LFxuICAgIGZwc1xuICB9KTtcbiAgcmV0dXJuIGFwcGVuZGVkO1xufTtcblxuLy8gc3JjL3VzZS1hbXBsaWZpY2F0aW9uLnRzXG52YXIgd2FybmVkMiA9IGZhbHNlO1xudmFyIHdhcm5TYWZhcmlPbmNlID0gKGxvZ0xldmVsKSA9PiB7XG4gIGlmICh3YXJuZWQyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5lZDIgPSB0cnVlO1xuICBMb2cud2Fybih7IGxvZ0xldmVsLCB0YWc6IG51bGwgfSwgXCJJbiBTYWZhcmksIHNldHRpbmcgYSB2b2x1bWUgYW5kIGEgcGxheWJhY2sgcmF0ZSBhdCB0aGUgc2FtZSB0aW1lIGlzIGJ1Z2d5LlwiKTtcbiAgTG9nLndhcm4oeyBsb2dMZXZlbCwgdGFnOiBudWxsIH0sIFwiSW4gRGVza3RvcCBTYWZhcmksIG9ubHkgdm9sdW1lcyA8PSAxIHdpbGwgYmUgYXBwbGllZC5cIik7XG4gIExvZy53YXJuKHsgbG9nTGV2ZWwsIHRhZzogbnVsbCB9LCBsb2dMZXZlbCwgXCJJbiBNb2JpbGUgU2FmYXJpLCB0aGUgdm9sdW1lIHdpbGwgYmUgaWdub3JlZCBhbmQgc2V0IHRvIDEgaWYgYSBwbGF5YmFja1JhdGUgaXMgc2V0LlwiKTtcbn07XG52YXIgdXNlVm9sdW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIHZvbHVtZSxcbiAgbG9nTGV2ZWwsXG4gIHNvdXJjZSxcbiAgc2hvdWxkVXNlV2ViQXVkaW9BcGlcbn0pID0+IHtcbiAgY29uc3QgYXVkaW9TdHVmZlJlZiA9IHVzZVJlZjYobnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRWb2x1bWVSZWYgPSB1c2VSZWY2KHZvbHVtZSk7XG4gIGN1cnJlbnRWb2x1bWVSZWYuY3VycmVudCA9IHZvbHVtZTtcbiAgY29uc3Qgc2hhcmVkQXVkaW9Db250ZXh0ID0gdXNlQ29udGV4dDE2KFNoYXJlZEF1ZGlvQ29udGV4dCk7XG4gIGlmICghc2hhcmVkQXVkaW9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlQW1wbGlmaWNhdGlvbiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgU2hhcmVkQXVkaW9Db250ZXh0XCIpO1xuICB9XG4gIGNvbnN0IHsgYXVkaW9Db250ZXh0IH0gPSBzaGFyZWRBdWRpb0NvbnRleHQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0MygoKSA9PiB7XG4gICAgICBpZiAoIWF1ZGlvQ29udGV4dCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFzaG91bGRVc2VXZWJBdWRpb0FwaSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWVkaWFSZWYuY3VycmVudC5wbGF5YmFja1JhdGUgIT09IDEgJiYgaXNTYWZhcmkoKSkge1xuICAgICAgICB3YXJuU2FmYXJpT25jZShsb2dMZXZlbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGdhaW5Ob2RlID0gbmV3IEdhaW5Ob2RlKGF1ZGlvQ29udGV4dCwge1xuICAgICAgICBnYWluOiBjdXJyZW50Vm9sdW1lUmVmLmN1cnJlbnRcbiAgICAgIH0pO1xuICAgICAgc291cmNlLmF0dGVtcHRUb0Nvbm5lY3QoKTtcbiAgICAgIHNvdXJjZS5nZXQoKS5jb25uZWN0KGdhaW5Ob2RlKTtcbiAgICAgIGdhaW5Ob2RlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICAgIGF1ZGlvU3R1ZmZSZWYuY3VycmVudCA9IHtcbiAgICAgICAgZ2Fpbk5vZGVcbiAgICAgIH07XG4gICAgICBMb2cudHJhY2UoeyBsb2dMZXZlbCwgdGFnOiBudWxsIH0sIGBTdGFydGluZyB0byBhbXBsaWZ5ICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfS4gR2FpbiA9ICR7Y3VycmVudFZvbHVtZVJlZi5jdXJyZW50fSwgcGxheWJhY2tSYXRlID0gJHttZWRpYVJlZi5jdXJyZW50Py5wbGF5YmFja1JhdGV9YCk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBhdWRpb1N0dWZmUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBnYWluTm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvdXJjZS5nZXQoKS5kaXNjb25uZWN0KCk7XG4gICAgICB9O1xuICAgIH0sIFtsb2dMZXZlbCwgbWVkaWFSZWYsIGF1ZGlvQ29udGV4dCwgc291cmNlLCBzaG91bGRVc2VXZWJBdWRpb0FwaV0pO1xuICB9XG4gIGlmIChhdWRpb1N0dWZmUmVmLmN1cnJlbnQpIHtcbiAgICBjb25zdCB2YWx1ZVRvU2V0ID0gdm9sdW1lO1xuICAgIGlmICghaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShhdWRpb1N0dWZmUmVmLmN1cnJlbnQuZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSwgdmFsdWVUb1NldCkpIHtcbiAgICAgIGF1ZGlvU3R1ZmZSZWYuY3VycmVudC5nYWluTm9kZS5nYWluLnZhbHVlID0gdmFsdWVUb1NldDtcbiAgICAgIExvZy50cmFjZSh7IGxvZ0xldmVsLCB0YWc6IG51bGwgfSwgYFNldHRpbmcgZ2FpbiB0byAke3ZhbHVlVG9TZXR9IGZvciAke21lZGlhUmVmLmN1cnJlbnQ/LnNyY31gKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc2FmYXJpQ2FzZSA9IGlzU2FmYXJpKCkgJiYgbWVkaWFSZWYuY3VycmVudCAmJiBtZWRpYVJlZi5jdXJyZW50Py5wbGF5YmFja1JhdGUgIT09IDE7XG4gIGNvbnN0IHNob3VsZFVzZVRyYWRpdGlvbmFsVm9sdW1lID0gc2FmYXJpQ2FzZSB8fCAhc2hvdWxkVXNlV2ViQXVkaW9BcGk7XG4gIGlmIChzaG91bGRVc2VUcmFkaXRpb25hbFZvbHVtZSAmJiBtZWRpYVJlZi5jdXJyZW50ICYmICFpc0FwcHJveGltYXRlbHlUaGVTYW1lKHZvbHVtZSwgbWVkaWFSZWYuY3VycmVudD8udm9sdW1lKSkge1xuICAgIG1lZGlhUmVmLmN1cnJlbnQudm9sdW1lID0gTWF0aC5taW4odm9sdW1lLCAxKTtcbiAgfVxuICByZXR1cm4gYXVkaW9TdHVmZlJlZjtcbn07XG5cbi8vIHNyYy91c2UtbWVkaWEtaW4tdGltZWxpbmUudHNcbmltcG9ydCB7IHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE4LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OCwgdXNlTWVtbyBhcyB1c2VNZW1vMTUsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMTEgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL2F1ZGlvL3VzZS1hdWRpby1mcmFtZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MTcgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VNZWRpYVN0YXJ0c0F0ID0gKCkgPT4ge1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxNyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBzdGFydHNBdCA9IE1hdGgubWluKDAsIHBhcmVudFNlcXVlbmNlPy5yZWxhdGl2ZUZyb20gPz8gMCk7XG4gIHJldHVybiBzdGFydHNBdDtcbn07XG52YXIgdXNlRnJhbWVGb3JWb2x1bWVQcm9wID0gKGJlaGF2aW9yKSA9PiB7XG4gIGNvbnN0IGxvb3AgPSBMb29wLnVzZUxvb3AoKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGlmIChiZWhhdmlvciA9PT0gXCJyZXBlYXRcIiB8fCBsb29wID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQ7XG4gIH1cbiAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQgKyBsb29wLmR1cmF0aW9uSW5GcmFtZXMgKiBsb29wLml0ZXJhdGlvbjtcbn07XG5cbi8vIHNyYy9nZXQtYXNzZXQtZmlsZS1uYW1lLnRzXG52YXIgZ2V0QXNzZXREaXNwbGF5TmFtZSA9IChmaWxlbmFtZSkgPT4ge1xuICBpZiAoL2RhdGE6fGJsb2I6Ly50ZXN0KGZpbGVuYW1lLnN1YnN0cmluZygwLCA1KSkpIHtcbiAgICByZXR1cm4gXCJEYXRhIFVSTFwiO1xuICB9XG4gIGNvbnN0IHNwbGl0dGVkID0gZmlsZW5hbWUuc3BsaXQoXCIvXCIpLm1hcCgocykgPT4gcy5zcGxpdChcIlxcXFxcIikpLmZsYXQoMSk7XG4gIHJldHVybiBzcGxpdHRlZFtzcGxpdHRlZC5sZW5ndGggLSAxXTtcbn07XG5cbi8vIHNyYy92b2x1bWUtcHJvcC50c1xudmFyIGV2YWx1YXRlVm9sdW1lID0gKHtcbiAgZnJhbWUsXG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUgPSAxXG59KSA9PiB7XG4gIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZvbHVtZSAqIG1lZGlhVm9sdW1lO1xuICB9XG4gIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIE51bWJlcihtZWRpYVZvbHVtZSk7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGVkID0gdm9sdW1lKGZyYW1lKSAqIG1lZGlhVm9sdW1lO1xuICBpZiAodHlwZW9mIGV2YWx1YXRlZCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBhIGZ1bmN0aW9uIHRvIHRoZSB2b2x1bWUgcHJvcCBidXQgaXQgZGlkIG5vdCByZXR1cm4gYSBudW1iZXIgYnV0IGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBldmFsdWF0ZWR9IGZvciBmcmFtZSAke2ZyYW1lfWApO1xuICB9XG4gIGlmIChOdW1iZXIuaXNOYU4oZXZhbHVhdGVkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBmdW5jdGlvbiB0byB0aGUgdm9sdW1lIHByb3AgYnV0IGl0IHJldHVybmVkIE5hTiBmb3IgZnJhbWUgJHtmcmFtZX0uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZXZhbHVhdGVkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBmdW5jdGlvbiB0byB0aGUgdm9sdW1lIHByb3AgYnV0IGl0IHJldHVybmVkIGEgbm9uLWZpbml0ZSBudW1iZXIgZm9yIGZyYW1lICR7ZnJhbWV9LmApO1xuICB9XG4gIHJldHVybiBNYXRoLm1heCgwLCBldmFsdWF0ZWQpO1xufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1pbi10aW1lbGluZS50c1xudmFyIGRpZFdhcm4gPSB7fTtcbnZhciB3YXJuT25jZTIgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoZGlkV2FyblttZXNzYWdlXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gIGRpZFdhcm5bbWVzc2FnZV0gPSB0cnVlO1xufTtcbnZhciB1c2VCYXNpY01lZGlhSW5UaW1lbGluZSA9ICh7XG4gIHZvbHVtZSxcbiAgbWVkaWFWb2x1bWUsXG4gIG1lZGlhVHlwZSxcbiAgc3JjLFxuICBkaXNwbGF5TmFtZSxcbiAgdHJpbUJlZm9yZSxcbiAgdHJpbUFmdGVyLFxuICBwbGF5YmFja1JhdGVcbn0pID0+IHtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICB9XG4gIGNvbnN0IHN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQxOChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IFtpbml0aWFsVm9sdW1lXSA9IHVzZVN0YXRlMTEoKCkgPT4gdm9sdW1lKTtcbiAgY29uc3QgbWVkaWFEdXJhdGlvbiA9IGNhbGN1bGF0ZU1lZGlhRHVyYXRpb24oe1xuICAgIG1lZGlhRHVyYXRpb25JbkZyYW1lczogdmlkZW9Db25maWcuZHVyYXRpb25JbkZyYW1lcyxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXJcbiAgfSk7XG4gIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2UgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCBtZWRpYUR1cmF0aW9uKSA6IG1lZGlhRHVyYXRpb247XG4gIGNvbnN0IHZvbHVtZXMgPSB1c2VNZW1vMTUoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygdm9sdW1lID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gdm9sdW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5KE1hdGguZmxvb3IoTWF0aC5tYXgoMCwgZHVyYXRpb24gKyBzdGFydHNBdCkpKS5maWxsKHRydWUpLm1hcCgoXywgaSkgPT4ge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlVm9sdW1lKHtcbiAgICAgICAgZnJhbWU6IGkgKyBzdGFydHNBdCxcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZVxuICAgICAgfSk7XG4gICAgfSkuam9pbihcIixcIik7XG4gIH0sIFtkdXJhdGlvbiwgc3RhcnRzQXQsIHZvbHVtZSwgbWVkaWFWb2x1bWVdKTtcbiAgdXNlRWZmZWN0OCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2b2x1bWUgPT09IFwibnVtYmVyXCIgJiYgdm9sdW1lICE9PSBpbml0aWFsVm9sdW1lKSB7XG4gICAgICB3YXJuT25jZTIoYFJlbW90aW9uOiBUaGUgJHttZWRpYVR5cGV9IHdpdGggc3JjICR7c3JjfSBoYXMgY2hhbmdlZCBpdCdzIHZvbHVtZS4gUHJlZmVyIHRoZSBjYWxsYmFjayBzeW50YXggZm9yIHNldHRpbmcgdm9sdW1lIHRvIGdldCBiZXR0ZXIgdGltZWxpbmUgZGlzcGxheTogaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvYXVkaW8vdm9sdW1lYCk7XG4gICAgfVxuICB9LCBbaW5pdGlhbFZvbHVtZSwgbWVkaWFUeXBlLCBzcmMsIHZvbHVtZV0pO1xuICBjb25zdCBkb2VzVm9sdW1lQ2hhbmdlID0gdHlwZW9mIHZvbHVtZSA9PT0gXCJmdW5jdGlvblwiO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGNvbnN0IHsgcm9vdElkIH0gPSB1c2VDb250ZXh0MTgoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3QgZW52ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICByZXR1cm4ge1xuICAgIHZvbHVtZXMsXG4gICAgZHVyYXRpb24sXG4gICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICBub25jZSxcbiAgICByb290SWQsXG4gICAgaXNTdHVkaW86IGVudi5pc1N0dWRpbyxcbiAgICBmaW5hbERpc3BsYXlOYW1lOiBkaXNwbGF5TmFtZSA/PyBnZXRBc3NldERpc3BsYXlOYW1lKHNyYylcbiAgfTtcbn07XG52YXIgdXNlTWVkaWFJblRpbWVsaW5lID0gKHtcbiAgdm9sdW1lLFxuICBtZWRpYVZvbHVtZSxcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgZGlzcGxheU5hbWUsXG4gIGlkLFxuICBzdGFjayxcbiAgc2hvd0luVGltZWxpbmUsXG4gIHByZW1vdW50RGlzcGxheSxcbiAgcG9zdG1vdW50RGlzcGxheSxcbiAgbG9vcERpc3BsYXlcbn0pID0+IHtcbiAgY29uc3QgcGFyZW50U2VxdWVuY2UgPSB1c2VDb250ZXh0MTgoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3Qgc3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJTZXF1ZW5jZSwgdW5yZWdpc3RlclNlcXVlbmNlIH0gPSB1c2VDb250ZXh0MTgoU2VxdWVuY2VNYW5hZ2VyKTtcbiAgY29uc3Qge1xuICAgIHZvbHVtZXMsXG4gICAgZHVyYXRpb24sXG4gICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICBub25jZSxcbiAgICByb290SWQsXG4gICAgaXNTdHVkaW8sXG4gICAgZmluYWxEaXNwbGF5TmFtZVxuICB9ID0gdXNlQmFzaWNNZWRpYUluVGltZWxpbmUoe1xuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZSxcbiAgICBtZWRpYVR5cGUsXG4gICAgc3JjLFxuICAgIGRpc3BsYXlOYW1lLFxuICAgIHRyaW1BZnRlcjogdW5kZWZpbmVkLFxuICAgIHRyaW1CZWZvcmU6IHVuZGVmaW5lZCxcbiAgICBwbGF5YmFja1JhdGVcbiAgfSk7XG4gIHVzZUVmZmVjdDgoKCkgPT4ge1xuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzU3R1ZGlvICYmIHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WICE9PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNob3dJblRpbWVsaW5lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlZ2lzdGVyU2VxdWVuY2Uoe1xuICAgICAgdHlwZTogbWVkaWFUeXBlLFxuICAgICAgc3JjLFxuICAgICAgaWQsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIGZyb206IDAsXG4gICAgICBwYXJlbnQ6IHBhcmVudFNlcXVlbmNlPy5pZCA/PyBudWxsLFxuICAgICAgZGlzcGxheU5hbWU6IGZpbmFsRGlzcGxheU5hbWUsXG4gICAgICByb290SWQsXG4gICAgICB2b2x1bWU6IHZvbHVtZXMsXG4gICAgICBzaG93SW5UaW1lbGluZTogdHJ1ZSxcbiAgICAgIG5vbmNlLFxuICAgICAgc3RhcnRNZWRpYUZyb206IDAgLSBzdGFydHNBdCxcbiAgICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgICBsb29wRGlzcGxheSxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHN0YWNrLFxuICAgICAgcHJlbW91bnREaXNwbGF5LFxuICAgICAgcG9zdG1vdW50RGlzcGxheVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyU2VxdWVuY2UoaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBkdXJhdGlvbixcbiAgICBpZCxcbiAgICBwYXJlbnRTZXF1ZW5jZSxcbiAgICBzcmMsXG4gICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICB1bnJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgdm9sdW1lcyxcbiAgICBkb2VzVm9sdW1lQ2hhbmdlLFxuICAgIG5vbmNlLFxuICAgIG1lZGlhVHlwZSxcbiAgICBzdGFydHNBdCxcbiAgICBwbGF5YmFja1JhdGUsXG4gICAgc3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5LFxuICAgIHBvc3Rtb3VudERpc3BsYXksXG4gICAgaXNTdHVkaW8sXG4gICAgbG9vcERpc3BsYXksXG4gICAgcm9vdElkLFxuICAgIGZpbmFsRGlzcGxheU5hbWVcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXBsYXliYWNrLnRzXG5pbXBvcnQge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEwLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyMSxcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEyLFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0NSxcbiAgdXNlUmVmIGFzIHVzZVJlZjEwXG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvYnVmZmVyLXVudGlsLWZpcnN0LWZyYW1lLnRzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazksIHVzZU1lbW8gYXMgdXNlTWVtbzE4LCB1c2VSZWYgYXMgdXNlUmVmOCB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdXNlLWJ1ZmZlci1zdGF0ZS50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjAsIHVzZU1lbW8gYXMgdXNlTWVtbzE3IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9idWZmZXJpbmcudHN4XG5pbXBvcnQgUmVhY3QxNSwge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazgsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDE5LFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0OSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDQsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzE2LFxuICB1c2VSZWYgYXMgdXNlUmVmNyxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxMlxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gxNiB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIHVzZUJ1ZmZlck1hbmFnZXIgPSAobG9nTGV2ZWwsIG1vdW50VGltZSkgPT4ge1xuICBjb25zdCBbYmxvY2tzLCBzZXRCbG9ja3NdID0gdXNlU3RhdGUxMihbXSk7XG4gIGNvbnN0IFtvbkJ1ZmZlcmluZ0NhbGxiYWNrcywgc2V0T25CdWZmZXJpbmdDYWxsYmFja3NdID0gdXNlU3RhdGUxMihbXSk7XG4gIGNvbnN0IFtvblJlc3VtZUNhbGxiYWNrcywgc2V0T25SZXN1bWVDYWxsYmFja3NdID0gdXNlU3RhdGUxMihbXSk7XG4gIGNvbnN0IGJ1ZmZlcmluZyA9IHVzZVJlZjcoZmFsc2UpO1xuICBjb25zdCBhZGRCbG9jayA9IHVzZUNhbGxiYWNrOCgoYmxvY2spID0+IHtcbiAgICBzZXRCbG9ja3MoKGIpID0+IFsuLi5iLCBibG9ja10pO1xuICAgIHJldHVybiB7XG4gICAgICB1bmJsb2NrOiAoKSA9PiB7XG4gICAgICAgIHNldEJsb2NrcygoYikgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld0FyciA9IGIuZmlsdGVyKChieCkgPT4gYnggIT09IGJsb2NrKTtcbiAgICAgICAgICBpZiAobmV3QXJyLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3QXJyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IGxpc3RlbkZvckJ1ZmZlcmluZyA9IHVzZUNhbGxiYWNrOCgoY2FsbGJhY2spID0+IHtcbiAgICBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrcygoYykgPT4gWy4uLmMsIGNhbGxiYWNrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICBzZXRPbkJ1ZmZlcmluZ0NhbGxiYWNrcygoYykgPT4gYy5maWx0ZXIoKGNiKSA9PiBjYiAhPT0gY2FsbGJhY2spKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IGxpc3RlbkZvclJlc3VtZSA9IHVzZUNhbGxiYWNrOCgoY2FsbGJhY2spID0+IHtcbiAgICBzZXRPblJlc3VtZUNhbGxiYWNrcygoYykgPT4gWy4uLmMsIGNhbGxiYWNrXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICBzZXRPblJlc3VtZUNhbGxiYWNrcygoYykgPT4gYy5maWx0ZXIoKGNiKSA9PiBjYiAhPT0gY2FsbGJhY2spKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDkoKCkgPT4ge1xuICAgIGlmIChibG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgb25CdWZmZXJpbmdDYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBcIlBsYXllciBpcyBlbnRlcmluZyBidWZmZXIgc3RhdGVcIixcbiAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICB0YWc6IFwicGxheWVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Jsb2Nrc10pO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHVzZUxheW91dEVmZmVjdDQoKCkgPT4ge1xuICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgb25SZXN1bWVDYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gYygpKTtcbiAgICAgICAgcGxheWJhY2tMb2dnaW5nKHtcbiAgICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgICBtZXNzYWdlOiBcIlBsYXllciBpcyBleGl0aW5nIGJ1ZmZlciBzdGF0ZVwiLFxuICAgICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgICB0YWc6IFwicGxheWVyXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgW2Jsb2Nrc10pO1xuICB9XG4gIHJldHVybiB1c2VNZW1vMTYoKCkgPT4ge1xuICAgIHJldHVybiB7IGFkZEJsb2NrLCBsaXN0ZW5Gb3JCdWZmZXJpbmcsIGxpc3RlbkZvclJlc3VtZSwgYnVmZmVyaW5nIH07XG4gIH0sIFthZGRCbG9jaywgYnVmZmVyaW5nLCBsaXN0ZW5Gb3JCdWZmZXJpbmcsIGxpc3RlbkZvclJlc3VtZV0pO1xufTtcbnZhciBCdWZmZXJpbmdDb250ZXh0UmVhY3QgPSBSZWFjdDE1LmNyZWF0ZUNvbnRleHQobnVsbCk7XG52YXIgQnVmZmVyaW5nUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgbG9nTGV2ZWwsIG1vdW50VGltZSB9ID0gdXNlQ29udGV4dDE5KExvZ0xldmVsQ29udGV4dCk7XG4gIGNvbnN0IGJ1ZmZlck1hbmFnZXIgPSB1c2VCdWZmZXJNYW5hZ2VyKGxvZ0xldmVsID8/IFwiaW5mb1wiLCBtb3VudFRpbWUpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE2KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBidWZmZXJNYW5hZ2VyLFxuICAgIGNoaWxkcmVuXG4gIH0pO1xufTtcbnZhciB1c2VJc1BsYXllckJ1ZmZlcmluZyA9IChidWZmZXJNYW5hZ2VyKSA9PiB7XG4gIGNvbnN0IFtpc0J1ZmZlcmluZywgc2V0SXNCdWZmZXJpbmddID0gdXNlU3RhdGUxMihidWZmZXJNYW5hZ2VyLmJ1ZmZlcmluZy5jdXJyZW50KTtcbiAgdXNlRWZmZWN0OSgoKSA9PiB7XG4gICAgY29uc3Qgb25CdWZmZXIgPSAoKSA9PiB7XG4gICAgICBzZXRJc0J1ZmZlcmluZyh0cnVlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUmVzdW1lID0gKCkgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcoZmFsc2UpO1xuICAgIH07XG4gICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JCdWZmZXJpbmcob25CdWZmZXIpO1xuICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yUmVzdW1lKG9uUmVzdW1lKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgYnVmZmVyTWFuYWdlci5saXN0ZW5Gb3JCdWZmZXJpbmcoKCkgPT4ge1xuICAgICAgICByZXR1cm47XG4gICAgICB9KTtcbiAgICAgIGJ1ZmZlck1hbmFnZXIubGlzdGVuRm9yUmVzdW1lKCgpID0+IHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSwgW2J1ZmZlck1hbmFnZXJdKTtcbiAgcmV0dXJuIGlzQnVmZmVyaW5nO1xufTtcblxuLy8gc3JjL3VzZS1idWZmZXItc3RhdGUudHNcbnZhciB1c2VCdWZmZXJTdGF0ZSA9ICgpID0+IHtcbiAgY29uc3QgYnVmZmVyID0gdXNlQ29udGV4dDIwKEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCk7XG4gIGNvbnN0IGFkZEJsb2NrID0gYnVmZmVyID8gYnVmZmVyLmFkZEJsb2NrIDogbnVsbDtcbiAgcmV0dXJuIHVzZU1lbW8xNygoKSA9PiAoe1xuICAgIGRlbGF5UGxheWJhY2s6ICgpID0+IHtcbiAgICAgIGlmICghYWRkQmxvY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZW5hYmxlIHRoZSBidWZmZXJpbmcgc3RhdGUsIGJ1dCBhIFJlbW90aW9uIGNvbnRleHQgd2FzIG5vdCBmb3VuZC4gVGhpcyBBUEkgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGEgY29tcG9uZW50IHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgUmVtb3Rpb24gUGxheWVyIG9yIGEgPENvbXBvc2l0aW9uPi4gT3IgeW91IG1pZ2h0IGhhdmUgZXhwZXJpZW5jZWQgYSB2ZXJzaW9uIG1pc21hdGNoIC0gcnVuIGBucHggcmVtb3Rpb24gdmVyc2lvbnNgIGFuZCBlbnN1cmUgYWxsIHBhY2thZ2VzIGhhdmUgdGhlIHNhbWUgdmVyc2lvbi4gVGhpcyBlcnJvciBpcyB0aHJvd24gYnkgdGhlIGJ1ZmZlciBzdGF0ZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3BsYXllci9idWZmZXItc3RhdGVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGFkZEJsb2NrKHtcbiAgICAgICAgaWQ6IFN0cmluZyhNYXRoLnJhbmRvbSgpKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyB1bmJsb2NrIH07XG4gICAgfVxuICB9KSwgW2FkZEJsb2NrXSk7XG59O1xuXG4vLyBzcmMvYnVmZmVyLXVudGlsLWZpcnN0LWZyYW1lLnRzXG52YXIgaXNTYWZhcmlXZWJraXQgPSAoKSA9PiB7XG4gIGNvbnN0IGlzU2FmYXJpMiA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICByZXR1cm4gaXNTYWZhcmkyO1xufTtcbnZhciB1c2VCdWZmZXJVbnRpbEZpcnN0RnJhbWUgPSAoe1xuICBtZWRpYVJlZixcbiAgbWVkaWFUeXBlLFxuICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCxcbiAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICBsb2dMZXZlbCxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlcmluZ1JlZiA9IHVzZVJlZjgoZmFsc2UpO1xuICBjb25zdCB7IGRlbGF5UGxheWJhY2sgfSA9IHVzZUJ1ZmZlclN0YXRlKCk7XG4gIGNvbnN0IGJ1ZmZlclVudGlsRmlyc3RGcmFtZSA9IHVzZUNhbGxiYWNrOSgocmVxdWVzdGVkVGltZSkgPT4ge1xuICAgIGlmIChtZWRpYVR5cGUgIT09IFwidmlkZW9cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXBhdXNlV2hlbkJ1ZmZlcmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA+PSBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEgJiYgIWlzU2FmYXJpV2Via2l0KCkpIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBgTm90IHVzaW5nIGJ1ZmZlciB1bnRpbCBmaXJzdCBmcmFtZSwgYmVjYXVzZSByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSBhbmQgaXMgbm90IFNhZmFyaSBvciBEZXNrdG9wIENocm9tZWAsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgdGFnOiBcImJ1ZmZlclwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2spIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICBtZXNzYWdlOiBgTm90IHVzaW5nIGJ1ZmZlciB1bnRpbCBmaXJzdCBmcmFtZSwgYmVjYXVzZSByZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrIGlzIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgICBtb3VudFRpbWUsXG4gICAgICAgIHRhZzogXCJidWZmZXJcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGJ1ZmZlcmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtZXNzYWdlOiBgQnVmZmVyaW5nICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfSB1bnRpbCB0aGUgZmlyc3QgZnJhbWUgaXMgcmVjZWl2ZWRgLFxuICAgICAgbW91bnRUaW1lLFxuICAgICAgdGFnOiBcImJ1ZmZlclwiXG4gICAgfSk7XG4gICAgY29uc3QgcGxheWJhY2sgPSBkZWxheVBsYXliYWNrKCk7XG4gICAgY29uc3QgdW5ibG9jayA9ICgpID0+IHtcbiAgICAgIHBsYXliYWNrLnVuYmxvY2soKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHVuYmxvY2ssIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXVzZVwiLCB1bmJsb2NrLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5ID0gKCkgPT4ge1xuICAgICAgdW5ibG9jaygpO1xuICAgIH07XG4gICAgY3VycmVudC5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvMikgPT4ge1xuICAgICAgY29uc3QgZGlmZmVyZW5jZUZyb21SZXF1ZXN0ZWQgPSBNYXRoLmFicyhpbmZvMi5tZWRpYVRpbWUgLSByZXF1ZXN0ZWRUaW1lKTtcbiAgICAgIGlmIChkaWZmZXJlbmNlRnJvbVJlcXVlc3RlZCA+IDAuNSkge1xuICAgICAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCgpO1xuICAgICAgfVxuICAgICAgdW5ibG9jaygpO1xuICAgIH0pO1xuICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwicGF1c2VcIiwgb25FbmRlZE9yUGF1c2VPckNhblBsYXksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uRW5kZWRPclBhdXNlT3JDYW5QbGF5LCB7XG4gICAgICBvbmNlOiB0cnVlXG4gICAgfSk7XG4gIH0sIFtcbiAgICBkZWxheVBsYXliYWNrLFxuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmLFxuICAgIG1lZGlhVHlwZSxcbiAgICBtb3VudFRpbWUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nXG4gIF0pO1xuICByZXR1cm4gdXNlTWVtbzE4KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNCdWZmZXJpbmc6ICgpID0+IGJ1ZmZlcmluZ1JlZi5jdXJyZW50LFxuICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lXG4gICAgfTtcbiAgfSwgW2J1ZmZlclVudGlsRmlyc3RGcmFtZV0pO1xufTtcblxuLy8gc3JjL21lZGlhLXRhZy1jdXJyZW50LXRpbWUtdGltZXN0YW1wLnRzXG5pbXBvcnQgUmVhY3QxNiBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VDdXJyZW50VGltZU9mTWVkaWFUYWdXaXRoVXBkYXRlVGltZVN0YW1wID0gKG1lZGlhUmVmKSA9PiB7XG4gIGNvbnN0IGxhc3RVcGRhdGUgPSBSZWFjdDE2LnVzZVJlZih7XG4gICAgdGltZTogbWVkaWFSZWYuY3VycmVudD8uY3VycmVudFRpbWUgPz8gMCxcbiAgICBsYXN0VXBkYXRlOiBwZXJmb3JtYW5jZS5ub3coKVxuICB9KTtcbiAgY29uc3Qgbm93Q3VycmVudFRpbWUgPSBtZWRpYVJlZi5jdXJyZW50Py5jdXJyZW50VGltZSA/PyBudWxsO1xuICBpZiAobm93Q3VycmVudFRpbWUgIT09IG51bGwpIHtcbiAgICBpZiAobGFzdFVwZGF0ZS5jdXJyZW50LnRpbWUgIT09IG5vd0N1cnJlbnRUaW1lKSB7XG4gICAgICBsYXN0VXBkYXRlLmN1cnJlbnQudGltZSA9IG5vd0N1cnJlbnRUaW1lO1xuICAgICAgbGFzdFVwZGF0ZS5jdXJyZW50Lmxhc3RVcGRhdGUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxhc3RVcGRhdGU7XG59O1xuXG4vLyBzcmMvc2Vlay50c1xudmFyIHNlZWsgPSAoe1xuICBtZWRpYVJlZixcbiAgdGltZSxcbiAgbG9nTGV2ZWwsXG4gIHdoeSxcbiAgbW91bnRUaW1lXG59KSA9PiB7XG4gIGNvbnN0IHRpbWVUb1NldCA9IGlzSW9zU2FmYXJpKCkgPyBOdW1iZXIodGltZS50b0ZpeGVkKDEpKSA6IHRpbWU7XG4gIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgbG9nTGV2ZWwsXG4gICAgdGFnOiBcInNlZWtcIixcbiAgICBtZXNzYWdlOiBgU2Vla2luZyBmcm9tICR7bWVkaWFSZWYuY3VycmVudFRpbWV9IHRvICR7dGltZVRvU2V0fS4gc3JjPSAke21lZGlhUmVmLnNyY30gUmVhc29uOiAke3doeX1gLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgbWVkaWFSZWYuY3VycmVudFRpbWUgPSB0aW1lVG9TZXQ7XG4gIHJldHVybiB0aW1lVG9TZXQ7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLWJ1ZmZlcmluZy50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDEwLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTEzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTWVkaWFCdWZmZXJpbmcgPSAoe1xuICBlbGVtZW50LFxuICBzaG91bGRCdWZmZXIsXG4gIGlzUHJlbW91bnRpbmcsXG4gIGlzUG9zdG1vdW50aW5nLFxuICBsb2dMZXZlbCxcbiAgbW91bnRUaW1lLFxuICBzcmNcbn0pID0+IHtcbiAgY29uc3QgYnVmZmVyID0gdXNlQnVmZmVyU3RhdGUoKTtcbiAgY29uc3QgW2lzQnVmZmVyaW5nLCBzZXRJc0J1ZmZlcmluZ10gPSB1c2VTdGF0ZTEzKGZhbHNlKTtcbiAgdXNlRWZmZWN0MTAoKCkgPT4ge1xuICAgIGxldCBjbGVhbnVwRm5zID0gW107XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBlbGVtZW50O1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNob3VsZEJ1ZmZlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNQcmVtb3VudGluZyB8fCBpc1Bvc3Rtb3VudGluZykge1xuICAgICAgaWYgKChpc1ByZW1vdW50aW5nIHx8IGlzUG9zdG1vdW50aW5nKSAmJiBjdXJyZW50LnJlYWR5U3RhdGUgPCBjdXJyZW50LkhBVkVfRlVUVVJFX0RBVEEpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7Y3VycmVudC5zcmN9IGJlY2F1c2UgcmVhZHlTdGF0ZSBpcyAke2N1cnJlbnQucmVhZHlTdGF0ZX0gYW5kIGl0IGlzIG5vdCBGaXJlZm94LiBFbGVtZW50IGlzIHByZW1vdW50ZWQgJHtjdXJyZW50LnBsYXliYWNrUmF0ZX1gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWJhY2tSYXRlID0gY3VycmVudC5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgICAgY3VycmVudC5wbGF5YmFja1JhdGUgPSBwcmV2aW91c1BsYXliYWNrUmF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbnVwID0gKHJlYXNvbikgPT4ge1xuICAgICAgbGV0IGRpZERvU29tZXRoaW5nID0gZmFsc2U7XG4gICAgICBjbGVhbnVwRm5zLmZvckVhY2goKGZuKSA9PiB7XG4gICAgICAgIGZuKHJlYXNvbik7XG4gICAgICAgIGRpZERvU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucyA9IFtdO1xuICAgICAgc2V0SXNCdWZmZXJpbmcoKHByZXZpb3VzKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICAgIGRpZERvU29tZXRoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIGlmIChkaWREb1NvbWV0aGluZykge1xuICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IGBVbm1hcmtpbmcgYXMgYnVmZmVyaW5nOiAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICAgIHRhZzogXCJidWZmZXJcIixcbiAgICAgICAgICBtb3VudFRpbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBibG9ja01lZGlhID0gKHJlYXNvbikgPT4ge1xuICAgICAgc2V0SXNCdWZmZXJpbmcodHJ1ZSk7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbWVzc2FnZTogYE1hcmtpbmcgYXMgYnVmZmVyaW5nOiAke2N1cnJlbnQuc3JjfS4gUmVhc29uOiAke3JlYXNvbn1gLFxuICAgICAgICB0YWc6IFwiYnVmZmVyXCIsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IHVuYmxvY2sgfSA9IGJ1ZmZlci5kZWxheVBsYXliYWNrKCk7XG4gICAgICBjb25zdCBvbkNhblBsYXkgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFudXAoJ1wiY2FucGxheVwiIHdhcyBmaXJlZCcpO1xuICAgICAgICBpbml0KCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25FcnJvciA9ICgpID0+IHtcbiAgICAgICAgY2xlYW51cCgnXCJlcnJvclwiIGV2ZW50IHdhcyBvY2N1cnJlZCcpO1xuICAgICAgICBpbml0KCk7XG4gICAgICB9O1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBvbkNhblBsYXksIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIG9uQ2FuUGxheSk7XG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IsIHtcbiAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBjbGVhbnVwRm5zLnB1c2goKCkgPT4ge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgY2xlYW51cEZucy5wdXNoKChjbGVhbnVwUmVhc29uKSA9PiB7XG4gICAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbWVzc2FnZTogYFVuYmxvY2tpbmcgJHtjdXJyZW50LnNyY30gZnJvbSBidWZmZXIuIFJlYXNvbjogJHtjbGVhbnVwUmVhc29ufWAsXG4gICAgICAgICAgdGFnOiBcImJ1ZmZlclwiLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbml0ID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQucmVhZHlTdGF0ZSA8IGN1cnJlbnQuSEFWRV9GVVRVUkVfREFUQSkge1xuICAgICAgICBibG9ja01lZGlhKGByZWFkeVN0YXRlIGlzICR7Y3VycmVudC5yZWFkeVN0YXRlfSwgd2hpY2ggaXMgbGVzcyB0aGFuIEhBVkVfRlVUVVJFX0RBVEFgKTtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKFwiRmlyZWZveC9cIikpIHtcbiAgICAgICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgICBtZXNzYWdlOiBgQ2FsbGluZyAubG9hZCgpIG9uICR7c3JjfSBiZWNhdXNlIHJlYWR5U3RhdGUgaXMgJHtjdXJyZW50LnJlYWR5U3RhdGV9IGFuZCBpdCBpcyBub3QgRmlyZWZveC4gJHtjdXJyZW50LnBsYXliYWNrUmF0ZX1gLFxuICAgICAgICAgICAgdGFnOiBcImxvYWRcIixcbiAgICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGxheWJhY2tSYXRlID0gY3VycmVudC5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgY3VycmVudC5sb2FkKCk7XG4gICAgICAgICAgY3VycmVudC5wbGF5YmFja1JhdGUgPSBwcmV2aW91c1BsYXliYWNrUmF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgICAgIGJsb2NrTWVkaWEoJ1wid2FpdGluZ1wiIGV2ZW50IHdhcyBmaXJlZCcpO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ3YWl0aW5nXCIsIG9uV2FpdGluZyk7XG4gICAgICAgIGNsZWFudXBGbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLCBvbldhaXRpbmcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGluaXQoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cChcImVsZW1lbnQgd2FzIHVubW91bnRlZCBvciBwcm9wIGNoYW5nZWRcIik7XG4gICAgfTtcbiAgfSwgW1xuICAgIGJ1ZmZlcixcbiAgICBzcmMsXG4gICAgZWxlbWVudCxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIHNob3VsZEJ1ZmZlcixcbiAgICBtb3VudFRpbWVcbiAgXSk7XG4gIHJldHVybiBpc0J1ZmZlcmluZztcbn07XG5cbi8vIHNyYy91c2UtcmVxdWVzdC12aWRlby1jYWxsYmFjay10aW1lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTEsIHVzZVJlZiBhcyB1c2VSZWY5IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVxdWVzdFZpZGVvQ2FsbGJhY2tUaW1lID0gKHtcbiAgbWVkaWFSZWYsXG4gIG1lZGlhVHlwZSxcbiAgbGFzdFNlZWssXG4gIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG59KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlUmVmOShudWxsKTtcbiAgdXNlRWZmZWN0MTEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gbWVkaWFSZWY7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRUaW1lLmN1cnJlbnQgPSB7XG4gICAgICAgIHRpbWU6IGN1cnJlbnQuY3VycmVudFRpbWUsXG4gICAgICAgIGxhc3RVcGRhdGU6IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJ2aWRlb1wiKSB7XG4gICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmlkZW9UYWcgPSBjdXJyZW50O1xuICAgIGlmICghdmlkZW9UYWcucmVxdWVzdFZpZGVvRnJhbWVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgcmVxdWVzdCA9ICgpID0+IHtcbiAgICAgIGlmICghdmlkZW9UYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2IgPSB2aWRlb1RhZy5yZXF1ZXN0VmlkZW9GcmFtZUNhbGxiYWNrKChfLCBpbmZvMikgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFRpbWUuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSBNYXRoLmFicyhjdXJyZW50VGltZS5jdXJyZW50LnRpbWUgLSBpbmZvMi5tZWRpYVRpbWUpO1xuICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2VUb0xhc3RTZWVrID0gTWF0aC5hYnMobGFzdFNlZWsuY3VycmVudCA9PT0gbnVsbCA/IEluZmluaXR5IDogaW5mbzIubWVkaWFUaW1lIC0gbGFzdFNlZWsuY3VycmVudCk7XG4gICAgICAgICAgaWYgKGRpZmZlcmVuY2UgPiAwLjUgJiYgZGlmZmVyZW5jZVRvTGFzdFNlZWsgPiAwLjUgJiYgaW5mbzIubWVkaWFUaW1lID4gY3VycmVudFRpbWUuY3VycmVudC50aW1lKSB7XG4gICAgICAgICAgICBvblZhcmlhYmxlRnBzVmlkZW9EZXRlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VGltZS5jdXJyZW50ID0ge1xuICAgICAgICAgIHRpbWU6IGluZm8yLm1lZGlhVGltZSxcbiAgICAgICAgICBsYXN0VXBkYXRlOiBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0KCk7XG4gICAgICB9KTtcbiAgICAgIGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgdmlkZW9UYWcuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNiKTtcbiAgICAgICAgY2FuY2VsID0gKCkgPT4ge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgICByZXF1ZXN0KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbmNlbCgpO1xuICAgIH07XG4gIH0sIFtsYXN0U2VlaywgbWVkaWFSZWYsIG1lZGlhVHlwZSwgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWRdKTtcbiAgcmV0dXJuIGN1cnJlbnRUaW1lO1xufTtcblxuLy8gc3JjL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICBsZXQgcmVzdWx0ID0gaW5wdXQ7XG4gIGNvbnN0IFtpbnB1dE1pbiwgaW5wdXRNYXhdID0gaW5wdXRSYW5nZTtcbiAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICBpZiAocmVzdWx0IDwgaW5wdXRNaW4pIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiY2xhbXBcIikge1xuICAgICAgcmVzdWx0ID0gaW5wdXRNaW47XG4gICAgfSBlbHNlIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwid3JhcFwiKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGlucHV0TWF4IC0gaW5wdXRNaW47XG4gICAgICByZXN1bHQgPSAoKHJlc3VsdCAtIGlucHV0TWluKSAlIHJhbmdlICsgcmFuZ2UpICUgcmFuZ2UgKyBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlUmlnaHQgPT09IFwiZXh0ZW5kXCIpIHt9XG4gIH1cbiAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgfVxuICByZXN1bHQgPSAocmVzdWx0IC0gaW5wdXRNaW4pIC8gKGlucHV0TWF4IC0gaW5wdXRNaW4pO1xuICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgcmVzdWx0ID0gcmVzdWx0ICogKG91dHB1dE1heCAtIG91dHB1dE1pbikgKyBvdXRwdXRNaW47XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpIHtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7aSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgaWYgKGlucHV0UmFuZ2VbaV0gPj0gaW5wdXQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgZm9yIChsZXQgaSA9IDE7aSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmICghKGFycltpXSA+IGFycltpIC0gMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0UmFuZ2UgbXVzdCBiZSBzdHJpY3RseSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICBpZiAoYXJyLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIG11c3QgaGF2ZSBhdCBsZWFzdCAyIGVsZW1lbnRzXCIpO1xuICB9XG4gIGZvciAoY29uc3QgZWxlbWVudCBvZiBhcnIpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oXCIsXCIpfV1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIG91dHB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIpIGFuZCBvdXRwdXRSYW5nZSAoXCIgKyBvdXRwdXRSYW5nZS5sZW5ndGggKyBcIikgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgfVxuICBjaGVja0luZmluaXRlUmFuZ2UoXCJpbnB1dFJhbmdlXCIsIGlucHV0UmFuZ2UpO1xuICBjaGVja0luZmluaXRlUmFuZ2UoXCJvdXRwdXRSYW5nZVwiLCBvdXRwdXRSYW5nZSk7XG4gIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGlucHV0UmFuZ2UpO1xuICBjb25zdCBlYXNpbmcgPSBvcHRpb25zPy5lYXNpbmcgPz8gKChudW0pID0+IG51bSk7XG4gIGxldCBleHRyYXBvbGF0ZUxlZnQgPSBcImV4dGVuZFwiO1xuICBpZiAob3B0aW9ucz8uZXh0cmFwb2xhdGVMZWZ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgfVxuICBsZXQgZXh0cmFwb2xhdGVSaWdodCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZVJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHRyYXBvbGF0ZVJpZ2h0ID0gb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0O1xuICB9XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGludGVycG9sYXRlIGFuIGlucHV0IHdoaWNoIGlzIG5vdCBhIG51bWJlclwiKTtcbiAgfVxuICBjb25zdCByYW5nZSA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgZWFzaW5nLFxuICAgIGV4dHJhcG9sYXRlTGVmdCxcbiAgICBleHRyYXBvbGF0ZVJpZ2h0XG4gIH0pO1xufVxuXG4vLyBzcmMvdmlkZW8vZ2V0LWN1cnJlbnQtdGltZS50c1xudmFyIGdldEV4cGVjdGVkTWVkaWFGcmFtZVVuY29ycmVjdGVkID0gKHtcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIHJldHVybiBpbnRlcnBvbGF0ZShmcmFtZSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIDFdLCBbLTEsIHN0YXJ0RnJvbSwgc3RhcnRGcm9tICsgcGxheWJhY2tSYXRlXSk7XG59O1xudmFyIGdldE1lZGlhVGltZSA9ICh7XG4gIGZwcyxcbiAgZnJhbWUsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3RhcnRGcm9tXG59KSA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkRnJhbWUgPSBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgZnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbVxuICB9KTtcbiAgY29uc3QgbXNQZXJGcmFtZSA9IDEwMDAgLyBmcHM7XG4gIHJldHVybiBleHBlY3RlZEZyYW1lICogbXNQZXJGcmFtZSAvIDEwMDA7XG59O1xuXG4vLyBzcmMvd2Fybi1hYm91dC1ub24tc2Vla2FibGUtbWVkaWEudHNcbnZhciBhbHJlYWR5V2FybmVkID0ge307XG52YXIgd2FybkFib3V0Tm9uU2Vla2FibGVNZWRpYSA9IChyZWYsIHR5cGUpID0+IHtcbiAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGFscmVhZHlXYXJuZWRbcmVmLnNyY10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiByZWYuc2Vla2FibGUuc3RhcnQoMCksIGVuZDogcmVmLnNlZWthYmxlLmVuZCgwKSB9O1xuICBpZiAocmFuZ2Uuc3RhcnQgPT09IDAgJiYgcmFuZ2UuZW5kID09PSAwKSB7XG4gICAgY29uc3QgbXNnID0gW1xuICAgICAgYFRoZSBtZWRpYSAke3JlZi5zcmN9IGNhbm5vdCBiZSBzZWVrZWQuIFRoaXMgY291bGQgYmUgb25lIG9mIGZldyByZWFzb25zOmAsXG4gICAgICBcIjEpIFRoZSBtZWRpYSByZXNvdXJjZSB3YXMgcmVwbGFjZWQgd2hpbGUgdGhlIHZpZGVvIGlzIHBsYXlpbmcgYnV0IGl0IHdhcyBub3QgbG9hZGVkIHlldC5cIixcbiAgICAgIFwiMikgVGhlIG1lZGlhIGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy5cIixcbiAgICAgIFwiMykgVGhlIG1lZGlhIHdhcyBsb2FkZWQgd2l0aCBzZWN1cml0eSBoZWFkZXJzIHBydmVudGluZyBpdCBmcm9tIGJlaW5nIGluY2x1ZGVkLlwiLFxuICAgICAgXCJQbGVhc2Ugc2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhc3Npc3RhbmNlLlwiXG4gICAgXS5qb2luKGBcbmApO1xuICAgIGlmICh0eXBlID09PSBcImNvbnNvbGUtZXJyb3JcIikge1xuICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb25zb2xlLXdhcm5pbmdcIikge1xuICAgICAgY29uc29sZS53YXJuKGBUaGUgbWVkaWEgJHtyZWYuc3JjfSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuIFRoZSB2aWRlbyB3aWxsIHJlbmRlciBmaW5lLCBidXQgbWF5IG5vdCBwbGF5IGNvcnJlY3RseSBpbiB0aGUgUmVtb3Rpb24gU3R1ZGlvIGFuZCBpbiB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL25vbi1zZWVrYWJsZS1tZWRpYSBmb3IgYW4gZXhwbGFuYXRpb24uYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICBhbHJlYWR5V2FybmVkW3JlZi5zcmNdID0gdHJ1ZTtcbiAgfVxufTtcblxuLy8gc3JjL3VzZS1tZWRpYS1wbGF5YmFjay50c1xudmFyIHVzZU1lZGlhUGxheWJhY2sgPSAoe1xuICBtZWRpYVJlZixcbiAgc3JjLFxuICBtZWRpYVR5cGUsXG4gIHBsYXliYWNrUmF0ZTogbG9jYWxQbGF5YmFja1JhdGUsXG4gIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gIGFjY2VwdGFibGVUaW1lc2hpZnQsXG4gIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgaXNQcmVtb3VudGluZyxcbiAgaXNQb3N0bW91bnRpbmcsXG4gIG9uQXV0b1BsYXlFcnJvclxufSkgPT4ge1xuICBjb25zdCB7IHBsYXliYWNrUmF0ZTogZ2xvYmFsUGxheWJhY2tSYXRlIH0gPSB1c2VDb250ZXh0MjEoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3QgYWJzb2x1dGVGcmFtZSA9IHVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgY29uc3QgW3BsYXlpbmddID0gdXNlUGxheWluZ1N0YXRlKCk7XG4gIGNvbnN0IGJ1ZmZlcmluZyA9IHVzZUNvbnRleHQyMShCdWZmZXJpbmdDb250ZXh0UmVhY3QpO1xuICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgbGFzdFNlZWtEdWVUb1NoaWZ0ID0gdXNlUmVmMTAobnVsbCk7XG4gIGNvbnN0IGxhc3RTZWVrID0gdXNlUmVmMTAobnVsbCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGlmICghYnVmZmVyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlTWVkaWFQbGF5YmFjayBtdXN0IGJlIHVzZWQgaW5zaWRlIGEgPEJ1ZmZlcmluZ0NvbnRleHQ+XCIpO1xuICB9XG4gIGNvbnN0IGlzVmFyaWFibGVGcHNWaWRlb01hcCA9IHVzZVJlZjEwKHt9KTtcbiAgY29uc3Qgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQgPSB1c2VDYWxsYmFjazEwKCgpID0+IHtcbiAgICBpZiAoIXNyYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNWYXJpYWJsZUZwc1ZpZGVvTWFwLmN1cnJlbnRbc3JjXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBMb2cudmVyYm9zZSh7IGxvZ0xldmVsLCB0YWc6IG51bGwgfSwgYERldGVjdGVkICR7c3JjfSBhcyBhIHZhcmlhYmxlIEZQUyB2aWRlby4gRGlzYWJsaW5nIGJ1ZmZlcmluZyB3aGlsZSBzZWVraW5nLmApO1xuICAgIGlzVmFyaWFibGVGcHNWaWRlb01hcC5jdXJyZW50W3NyY10gPSB0cnVlO1xuICB9LCBbbG9nTGV2ZWwsIHNyY10pO1xuICBjb25zdCBydmNDdXJyZW50VGltZSA9IHVzZVJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSh7XG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIGxhc3RTZWVrLFxuICAgIG9uVmFyaWFibGVGcHNWaWRlb0RldGVjdGVkXG4gIH0pO1xuICBjb25zdCBtZWRpYVRhZ0N1cnJlbnRUaW1lID0gdXNlQ3VycmVudFRpbWVPZk1lZGlhVGFnV2l0aFVwZGF0ZVRpbWVTdGFtcChtZWRpYVJlZik7XG4gIGNvbnN0IGRlc2lyZWRVbmNsYW1wZWRUaW1lID0gZ2V0TWVkaWFUaW1lKHtcbiAgICBmcmFtZSxcbiAgICBwbGF5YmFja1JhdGU6IGxvY2FsUGxheWJhY2tSYXRlLFxuICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXQsXG4gICAgZnBzXG4gIH0pO1xuICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nID0gdXNlTWVkaWFCdWZmZXJpbmcoe1xuICAgIGVsZW1lbnQ6IG1lZGlhUmVmLFxuICAgIHNob3VsZEJ1ZmZlcjogcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgaXNQb3N0bW91bnRpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbW91bnRUaW1lLFxuICAgIHNyYzogc3JjID8/IG51bGxcbiAgfSk7XG4gIGNvbnN0IHsgYnVmZmVyVW50aWxGaXJzdEZyYW1lLCBpc0J1ZmZlcmluZyB9ID0gdXNlQnVmZmVyVW50aWxGaXJzdEZyYW1lKHtcbiAgICBtZWRpYVJlZixcbiAgICBtZWRpYVR5cGUsXG4gICAgb25WYXJpYWJsZUZwc1ZpZGVvRGV0ZWN0ZWQsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZVxuICB9KTtcbiAgY29uc3QgcGxheWJhY2tSYXRlID0gbG9jYWxQbGF5YmFja1JhdGUgKiBnbG9iYWxQbGF5YmFja1JhdGU7XG4gIGNvbnN0IGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uID0gKCgpID0+IHtcbiAgICBjb25zdCBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfTk9STUFMX1BMQVlCQUNLID0gMC40NTtcbiAgICBjb25zdCBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTiA9IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlRfV0lUSF9OT1JNQUxfUExBWUJBQ0sgKyAwLjI7XG4gICAgY29uc3QgZGVmYXVsdEFjY2VwdGFibGVUaW1lc2hpZnQgPSBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZUX1dJVEhfQU1QTElGSUNBVElPTjtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihtZWRpYVJlZi5jdXJyZW50LmR1cmF0aW9uLCBhY2NlcHRhYmxlVGltZXNoaWZ0ID8/IGRlZmF1bHRBY2NlcHRhYmxlVGltZXNoaWZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2VwdGFibGVUaW1lc2hpZnQgPz8gZGVmYXVsdEFjY2VwdGFibGVUaW1lc2hpZnQ7XG4gIH0pKCk7XG4gIGNvbnN0IGlzUGxheWVyQnVmZmVyaW5nID0gdXNlSXNQbGF5ZXJCdWZmZXJpbmcoYnVmZmVyaW5nKTtcbiAgdXNlRWZmZWN0MTIoKCkgPT4ge1xuICAgIGlmIChtZWRpYVJlZi5jdXJyZW50Py5wYXVzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwbGF5aW5nKSB7XG4gICAgICBwbGF5YmFja0xvZ2dpbmcoe1xuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgdGFnOiBcInBhdXNlXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBQYXVzaW5nICR7bWVkaWFSZWYuY3VycmVudD8uc3JjfSBiZWNhdXNlICR7aXNQcmVtb3VudGluZyA/IFwibWVkaWEgaXMgcHJlbW91bnRpbmdcIiA6IGlzUG9zdG1vdW50aW5nID8gXCJtZWRpYSBpcyBwb3N0bW91bnRpbmdcIiA6IFwiUGxheWVyIGlzIG5vdCBwbGF5aW5nXCJ9YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQ/LnBhdXNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQgPSBpc01lZGlhVGFnQnVmZmVyaW5nIHx8IGlzQnVmZmVyaW5nKCk7XG4gICAgY29uc3QgcGxheWVyQnVmZmVyaW5nTm90U3RhdGVCdXRMaXZlID0gYnVmZmVyaW5nLmJ1ZmZlcmluZy5jdXJyZW50O1xuICAgIGlmIChwbGF5ZXJCdWZmZXJpbmdOb3RTdGF0ZUJ1dExpdmUgJiYgIWlzTWVkaWFUYWdCdWZmZXJpbmdPclN0YWxsZWQpIHtcbiAgICAgIHBsYXliYWNrTG9nZ2luZyh7XG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB0YWc6IFwicGF1c2VcIixcbiAgICAgICAgbWVzc2FnZTogYFBhdXNpbmcgJHttZWRpYVJlZi5jdXJyZW50Py5zcmN9IGJlY2F1c2UgcGxheWVyIGlzIGJ1ZmZlcmluZyBidXQgbWVkaWEgdGFnIGlzIG5vdGAsXG4gICAgICAgIG1vdW50VGltZVxuICAgICAgfSk7XG4gICAgICBtZWRpYVJlZi5jdXJyZW50Py5wYXVzZSgpO1xuICAgIH1cbiAgfSwgW1xuICAgIGlzQnVmZmVyaW5nLFxuICAgIGlzTWVkaWFUYWdCdWZmZXJpbmcsXG4gICAgYnVmZmVyaW5nLFxuICAgIGlzUGxheWVyQnVmZmVyaW5nLFxuICAgIGlzUHJlbW91bnRpbmcsXG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG1vdW50VGltZSxcbiAgICBwbGF5aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nXG4gIF0pO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIHVzZUxheW91dEVmZmVjdDUoKCkgPT4ge1xuICAgIGNvbnN0IHBsYXliYWNrUmF0ZVRvU2V0ID0gTWF0aC5tYXgoMCwgcGxheWJhY2tSYXRlKTtcbiAgICBpZiAobWVkaWFSZWYuY3VycmVudCAmJiBtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSAhPT0gcGxheWJhY2tSYXRlVG9TZXQpIHtcbiAgICAgIG1lZGlhUmVmLmN1cnJlbnQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlVG9TZXQ7XG4gICAgfVxuICB9LCBbbWVkaWFSZWYsIHBsYXliYWNrUmF0ZV0pO1xuICB1c2VFZmZlY3QxMigoKSA9PiB7XG4gICAgY29uc3QgdGFnTmFtZSA9IG1lZGlhVHlwZSA9PT0gXCJhdWRpb1wiID8gXCI8SHRtbDVBdWRpbz5cIiA6IFwiPEh0bWw1VmlkZW8+XCI7XG4gICAgaWYgKCFtZWRpYVJlZi5jdXJyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vICR7bWVkaWFUeXBlfSByZWYgZm91bmRgKTtcbiAgICB9XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJ3NyYycgYXR0cmlidXRlIHdhcyBwYXNzZWQgdG8gdGhlICR7dGFnTmFtZX0gZWxlbWVudC5gKTtcbiAgICB9XG4gICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gbWVkaWFSZWYuY3VycmVudDtcbiAgICBjb25zdCBzaG91bGRCZVRpbWUgPSAhTnVtYmVyLmlzTmFOKGR1cmF0aW9uKSAmJiBOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb24pID8gTWF0aC5taW4oZHVyYXRpb24sIGRlc2lyZWRVbmNsYW1wZWRUaW1lKSA6IGRlc2lyZWRVbmNsYW1wZWRUaW1lO1xuICAgIGNvbnN0IG1lZGlhVGFnVGltZSA9IG1lZGlhVGFnQ3VycmVudFRpbWUuY3VycmVudC50aW1lO1xuICAgIGNvbnN0IHJ2Y1RpbWUgPSBydmNDdXJyZW50VGltZS5jdXJyZW50Py50aW1lID8/IG51bGw7XG4gICAgY29uc3QgaXNWYXJpYWJsZUZwc1ZpZGVvID0gaXNWYXJpYWJsZUZwc1ZpZGVvTWFwLmN1cnJlbnRbc3JjXTtcbiAgICBjb25zdCB0aW1lU2hpZnRNZWRpYVRhZyA9IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIG1lZGlhVGFnVGltZSk7XG4gICAgY29uc3QgdGltZVNoaWZ0UnZjVGFnID0gcnZjVGltZSA/IE1hdGguYWJzKHNob3VsZEJlVGltZSAtIHJ2Y1RpbWUpIDogbnVsbDtcbiAgICBjb25zdCBtb3N0UmVjZW50VGltZXNoaWZ0ID0gcnZjQ3VycmVudFRpbWUuY3VycmVudD8ubGFzdFVwZGF0ZSAmJiBydmNDdXJyZW50VGltZS5jdXJyZW50LnRpbWUgPiBtZWRpYVRhZ0N1cnJlbnRUaW1lLmN1cnJlbnQubGFzdFVwZGF0ZSA/IHRpbWVTaGlmdFJ2Y1RhZyA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGNvbnN0IHRpbWVTaGlmdCA9IHRpbWVTaGlmdFJ2Y1RhZyAmJiAhaXNWYXJpYWJsZUZwc1ZpZGVvID8gbW9zdFJlY2VudFRpbWVzaGlmdCA6IHRpbWVTaGlmdE1lZGlhVGFnO1xuICAgIGlmICh0aW1lU2hpZnQgPiBhY2NlcHRhYmxlVGltZVNoaWZ0QnV0TGVzc1RoYW5EdXJhdGlvbiAmJiBsYXN0U2Vla0R1ZVRvU2hpZnQuY3VycmVudCAhPT0gc2hvdWxkQmVUaW1lKSB7XG4gICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgIG1lZGlhUmVmOiBtZWRpYVJlZi5jdXJyZW50LFxuICAgICAgICB0aW1lOiBzaG91bGRCZVRpbWUsXG4gICAgICAgIGxvZ0xldmVsLFxuICAgICAgICB3aHk6IGBiZWNhdXNlIHRpbWUgc2hpZnQgaXMgdG9vIGJpZy4gc2hvdWxkQmVUaW1lID0gJHtzaG91bGRCZVRpbWV9LCBpc1RpbWUgPSAke21lZGlhVGFnVGltZX0sIHJlcXVlc3RWaWRlb0NhbGxiYWNrVGltZSA9ICR7cnZjVGltZX0sIHRpbWVTaGlmdCA9ICR7dGltZVNoaWZ0fSR7aXNWYXJpYWJsZUZwc1ZpZGVvID8gXCIsIGlzVmFyaWFibGVGcHNWaWRlbyA9IHRydWVcIiA6IFwiXCJ9LCBpc1ByZW1vdW50aW5nID0gJHtpc1ByZW1vdW50aW5nfSwgaXNQb3N0bW91bnRpbmcgPSAke2lzUG9zdG1vdW50aW5nfSwgcGF1c2VXaGVuQnVmZmVyaW5nID0gJHtwYXVzZVdoZW5CdWZmZXJpbmd9YCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGxhc3RTZWVrRHVlVG9TaGlmdC5jdXJyZW50ID0gbGFzdFNlZWsuY3VycmVudDtcbiAgICAgIGlmIChwbGF5aW5nKSB7XG4gICAgICAgIGlmIChwbGF5YmFja1JhdGUgPiAwKSB7XG4gICAgICAgICAgYnVmZmVyVW50aWxGaXJzdEZyYW1lKHNob3VsZEJlVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lZGlhUmVmLmN1cnJlbnQucGF1c2VkKSB7XG4gICAgICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgICAgbW91bnRUaW1lLFxuICAgICAgICAgICAgcmVhc29uOiBcInBsYXllciBpcyBwbGF5aW5nIGJ1dCBtZWRpYSB0YWcgaXMgcGF1c2VkLCBhbmQganVzdCBzZWVrZWRcIixcbiAgICAgICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yKSB7XG4gICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/IFwiY29uc29sZS13YXJuaW5nXCIgOiBcImNvbnNvbGUtZXJyb3JcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlZWtUaHJlc2hvbGQgPSBwbGF5aW5nID8gMC4xNSA6IDAuMDE7XG4gICAgY29uc3QgbWFrZXNTZW5zZVRvU2VlayA9IE1hdGguYWJzKG1lZGlhUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgLSBzaG91bGRCZVRpbWUpID4gc2Vla1RocmVzaG9sZDtcbiAgICBjb25zdCBpc01lZGlhVGFnQnVmZmVyaW5nT3JTdGFsbGVkID0gaXNNZWRpYVRhZ0J1ZmZlcmluZyB8fCBpc0J1ZmZlcmluZygpO1xuICAgIGNvbnN0IGlzU29tZXRoaW5nRWxzZUJ1ZmZlcmluZyA9IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCAmJiAhaXNNZWRpYVRhZ0J1ZmZlcmluZ09yU3RhbGxlZDtcbiAgICBpZiAoIXBsYXlpbmcgfHwgaXNTb21ldGhpbmdFbHNlQnVmZmVyaW5nKSB7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYG5vdCBwbGF5aW5nIG9yIHNvbWV0aGluZyBlbHNlIGlzIGJ1ZmZlcmluZy4gdGltZSBvZmZzZXQgaXMgb3ZlciBzZWVrIHRocmVzaG9sZCAoJHtzZWVrVGhyZXNob2xkfSlgLFxuICAgICAgICAgIG1vdW50VGltZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwbGF5aW5nIHx8IGJ1ZmZlcmluZy5idWZmZXJpbmcuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXVzZWRDb25kaXRpb24gPSBtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCAmJiAhbWVkaWFSZWYuY3VycmVudC5lbmRlZDtcbiAgICBjb25zdCBmaXJzdEZyYW1lQ29uZGl0aW9uID0gYWJzb2x1dGVGcmFtZSA9PT0gMDtcbiAgICBpZiAocGF1c2VkQ29uZGl0aW9uIHx8IGZpcnN0RnJhbWVDb25kaXRpb24pIHtcbiAgICAgIGNvbnN0IHJlYXNvbiA9IHBhdXNlZENvbmRpdGlvbiA/IFwibWVkaWEgdGFnIGlzIHBhdXNlZFwiIDogXCJhYnNvbHV0ZSBmcmFtZSBpcyAwXCI7XG4gICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICBsYXN0U2Vlay5jdXJyZW50ID0gc2Vlayh7XG4gICAgICAgICAgbWVkaWFSZWY6IG1lZGlhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgdGltZTogc2hvdWxkQmVUaW1lLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIHdoeTogYGlzIG92ZXIgdGltZXNoaWZ0IHRocmVzaG9sZCAodGhyZXNob2xkID0gJHtzZWVrVGhyZXNob2xkfSkgYW5kICR7cmVhc29ufWAsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcih7XG4gICAgICAgIG1lZGlhUmVmLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgcmVhc29uOiBgcGxheWVyIGlzIHBsYXlpbmcgYW5kICR7cmVhc29ufWAsXG4gICAgICAgIGlzUGxheWVyOiBlbnYuaXNQbGF5ZXJcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc1ZhcmlhYmxlRnBzVmlkZW8gJiYgcGxheWJhY2tSYXRlID4gMCkge1xuICAgICAgICBidWZmZXJVbnRpbEZpcnN0RnJhbWUoc2hvdWxkQmVUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRCdXRMZXNzVGhhbkR1cmF0aW9uLFxuICAgIGJ1ZmZlclVudGlsRmlyc3RGcmFtZSxcbiAgICBidWZmZXJpbmcuYnVmZmVyaW5nLFxuICAgIHJ2Y0N1cnJlbnRUaW1lLFxuICAgIGxvZ0xldmVsLFxuICAgIGRlc2lyZWRVbmNsYW1wZWRUaW1lLFxuICAgIGlzQnVmZmVyaW5nLFxuICAgIGlzTWVkaWFUYWdCdWZmZXJpbmcsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHBsYXlpbmcsXG4gICAgc3JjLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBtb3VudFRpbWUsXG4gICAgbWVkaWFUYWdDdXJyZW50VGltZSxcbiAgICBlbnYuaXNQbGF5ZXJcbiAgXSk7XG59O1xuXG4vLyBzcmMvdXNlLW1lZGlhLXRhZy50c1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjIsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxMyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZU1lZGlhVGFnID0gKHtcbiAgbWVkaWFSZWYsXG4gIGlkLFxuICBtZWRpYVR5cGUsXG4gIG9uQXV0b1BsYXlFcnJvcixcbiAgaXNQcmVtb3VudGluZyxcbiAgaXNQb3N0bW91bnRpbmdcbn0pID0+IHtcbiAgY29uc3QgeyBhdWRpb0FuZFZpZGVvVGFncywgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQyMihUaW1lbGluZUNvbnRleHQpO1xuICBjb25zdCBsb2dMZXZlbCA9IHVzZUxvZ0xldmVsKCk7XG4gIGNvbnN0IG1vdW50VGltZSA9IHVzZU1vdW50VGltZSgpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIHVzZUVmZmVjdDEzKCgpID0+IHtcbiAgICBjb25zdCB0YWcgPSB7XG4gICAgICBpZCxcbiAgICAgIHBsYXk6IChyZWFzb24pID0+IHtcbiAgICAgICAgaWYgKCFpbXBlcmF0aXZlUGxheWluZy5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZW1vdW50aW5nIHx8IGlzUG9zdG1vdW50aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKHtcbiAgICAgICAgICBtZWRpYVJlZixcbiAgICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgICAgb25BdXRvUGxheUVycm9yLFxuICAgICAgICAgIGxvZ0xldmVsLFxuICAgICAgICAgIG1vdW50VGltZSxcbiAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgaXNQbGF5ZXI6IGVudi5pc1BsYXllclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQucHVzaCh0YWcpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBhdWRpb0FuZFZpZGVvVGFncy5jdXJyZW50ID0gYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5maWx0ZXIoKGEpID0+IGEuaWQgIT09IGlkKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYXVkaW9BbmRWaWRlb1RhZ3MsXG4gICAgaWQsXG4gICAgbWVkaWFSZWYsXG4gICAgbWVkaWFUeXBlLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICBpbXBlcmF0aXZlUGxheWluZyxcbiAgICBpc1ByZW1vdW50aW5nLFxuICAgIGlzUG9zdG1vdW50aW5nLFxuICAgIGxvZ0xldmVsLFxuICAgIG1vdW50VGltZSxcbiAgICBlbnYuaXNQbGF5ZXJcbiAgXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXBvc2l0aW9uLXN0YXRlLnRzXG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQxNiwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjMsIHVzZU1lbW8gYXMgdXNlTWVtbzE5IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgTWVkaWFWb2x1bWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDE2KHtcbiAgbWVkaWFNdXRlZDogZmFsc2UsXG4gIG1lZGlhVm9sdW1lOiAxXG59KTtcbnZhciBTZXRNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTYoe1xuICBzZXRNZWRpYU11dGVkOiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdFwiKTtcbiAgfSxcbiAgc2V0TWVkaWFWb2x1bWU6ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0XCIpO1xuICB9XG59KTtcbnZhciB1c2VNZWRpYVZvbHVtZVN0YXRlID0gKCkgPT4ge1xuICBjb25zdCB7IG1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0MjMoTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgY29uc3QgeyBzZXRNZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dDIzKFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTkoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFWb2x1bWUsIHNldE1lZGlhVm9sdW1lXTtcbiAgfSwgW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV0pO1xufTtcbnZhciB1c2VNZWRpYU11dGVkU3RhdGUgPSAoKSA9PiB7XG4gIGNvbnN0IHsgbWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDIzKE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIGNvbnN0IHsgc2V0TWVkaWFNdXRlZCB9ID0gdXNlQ29udGV4dDIzKFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gIHJldHVybiB1c2VNZW1vMTkoKCkgPT4ge1xuICAgIHJldHVybiBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF07XG4gIH0sIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXSk7XG59O1xuXG4vLyBzcmMvdm9sdW1lLXNhZmVndWFyZC50c1xudmFyIHdhcm5BYm91dFRvb0hpZ2hWb2x1bWUgPSAodm9sdW1lKSA9PiB7XG4gIGlmICh2b2x1bWUgPj0gMTAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBWb2x1bWUgd2FzIHNldCB0byAke3ZvbHVtZX0sIGJ1dCByZWd1bGFyIHZvbHVtZSBpcyAxLCBub3QgMTAwLiBEaWQgeW91IGZvcmdldCB0byBkaXZpZGUgYnkgMTAwPyBTZXQgYSB2b2x1bWUgb2YgbGVzcyB0aGFuIDEwMCB0byBkaXNtaXNzIHRoaXMgZXJyb3IuYCk7XG4gIH1cbn07XG5cbi8vIHNyYy9hdWRpby9BdWRpb0ZvclByZXZpZXcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MTcgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW2luaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHNdID0gdXNlU3RhdGUxNChwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyk7XG4gIGlmIChwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyAhPT0gaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIGZvciBwcmUtbW91bnRpbmcgYXVkaW8gdGFncyBkeW5hbWljYWxseS5cIik7XG4gIH1cbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBzaG91bGRQcmVNb3VudEF1ZGlvVGFncyxcbiAgICBzcmMsXG4gICAgb25EdXJhdGlvbixcbiAgICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBzdGFjayxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICB1c2VXZWJBdWRpb0FwaSxcbiAgICBvbkVycm9yLFxuICAgIG9uTmF0aXZlRXJyb3IsXG4gICAgYXVkaW9TdHJlYW1JbmRleCxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IF9wcm9wc1ZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFfcHJvcHNWYWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGVjaGVjayBlcnJvclwiKTtcbiAgfVxuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3Qgdm9sdW1lUHJvcEZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB7IGhpZGRlbiB9ID0gdXNlQ29udGV4dDI0KFNlcXVlbmNlVmlzaWJpbGl0eVRvZ2dsZUNvbnRleHQpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyAnc3JjJyB3YXMgcGFzc2VkIHRvIDxIdG1sNUF1ZGlvPi5cIik7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjQoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgW3RpbWVsaW5lSWRdID0gdXNlU3RhdGUxNCgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICBjb25zdCBpc1NlcXVlbmNlSGlkZGVuID0gaGlkZGVuW3RpbWVsaW5lSWRdID8/IGZhbHNlO1xuICBjb25zdCB1c2VyUHJlZmVycmVkVm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lXG4gIH0pO1xuICB3YXJuQWJvdXRUb29IaWdoVm9sdW1lKHVzZXJQcmVmZXJyZWRWb2x1bWUpO1xuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSh7XG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVxdWVzdHNWaWRlb0ZyYW1lOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgcHJvcHNUb1Bhc3MgPSB1c2VNZW1vMjAoKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBtdXRlZDogbXV0ZWQgfHwgbWVkaWFNdXRlZCB8fCBpc1NlcXVlbmNlSGlkZGVuIHx8IHVzZXJQcmVmZXJyZWRWb2x1bWUgPD0gMCxcbiAgICAgIHNyYzogcHJlbG9hZGVkU3JjLFxuICAgICAgbG9vcDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luVmFsdWUsXG4gICAgICAuLi5uYXRpdmVQcm9wc1xuICAgIH07XG4gIH0sIFtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gICAgaXNTZXF1ZW5jZUhpZGRlbixcbiAgICBtZWRpYU11dGVkLFxuICAgIG11dGVkLFxuICAgIG5hdGl2ZVByb3BzLFxuICAgIHByZWxvYWRlZFNyYyxcbiAgICB1c2VyUHJlZmVycmVkVm9sdW1lLFxuICAgIGNyb3NzT3JpZ2luVmFsdWVcbiAgXSk7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzIwKCgpID0+IGBhdWRpby0ke3JhbmRvbShzcmMgPz8gXCJcIil9LSR7c2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc30tbXV0ZWQ6JHtwcm9wcy5tdXRlZH0tbG9vcDoke3Byb3BzLmxvb3B9YCwgW1xuICAgIHNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzLFxuICAgIHByb3BzLm11dGVkLFxuICAgIHByb3BzLmxvb3BcbiAgXSk7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MjQoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmVkQXVkaW9Db250ZXh0IG5vdCBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB7IGVsOiBhdWRpb1JlZiwgbWVkaWFFbGVtZW50U291cmNlTm9kZSB9ID0gdXNlU2hhcmVkQXVkaW8oe1xuICAgIGF1ZDogcHJvcHNUb1Bhc3MsXG4gICAgYXVkaW9JZDogaWQsXG4gICAgcHJlbW91bnRpbmc6IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZylcbiAgfSk7XG4gIHVzZU1lZGlhSW5UaW1lbGluZSh7XG4gICAgdm9sdW1lLFxuICAgIG1lZGlhVm9sdW1lLFxuICAgIHNyYyxcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50RGlzcGxheSA/PyBudWxsLFxuICAgIHBvc3Rtb3VudERpc3BsYXk6IHNlcXVlbmNlQ29udGV4dD8ucG9zdG1vdW50RGlzcGxheSA/PyBudWxsLFxuICAgIGxvb3BEaXNwbGF5OiB1bmRlZmluZWRcbiAgfSk7XG4gIHVzZU1lZGlhUGxheWJhY2soe1xuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICBzcmMsXG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvXCIsXG4gICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgPz8gMSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSxcbiAgICBhY2NlcHRhYmxlVGltZXNoaWZ0OiBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzID8/IG51bGwsXG4gICAgaXNQcmVtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnByZW1vdW50aW5nKSxcbiAgICBpc1Bvc3Rtb3VudGluZzogQm9vbGVhbihzZXF1ZW5jZUNvbnRleHQ/LnBvc3Rtb3VudGluZyksXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogbnVsbFxuICB9KTtcbiAgdXNlTWVkaWFUYWcoe1xuICAgIGlkOiB0aW1lbGluZUlkLFxuICAgIGlzUG9zdG1vdW50aW5nOiBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucG9zdG1vdW50aW5nKSxcbiAgICBpc1ByZW1vdW50aW5nOiBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucHJlbW91bnRpbmcpLFxuICAgIG1lZGlhUmVmOiBhdWRpb1JlZixcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW9cIixcbiAgICBvbkF1dG9QbGF5RXJyb3I6IG51bGxcbiAgfSk7XG4gIHVzZVZvbHVtZSh7XG4gICAgbG9nTGV2ZWwsXG4gICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgIHNvdXJjZTogbWVkaWFFbGVtZW50U291cmNlTm9kZSxcbiAgICB2b2x1bWU6IHVzZXJQcmVmZXJyZWRWb2x1bWUsXG4gICAgc2hvdWxkVXNlV2ViQXVkaW9BcGk6IHVzZVdlYkF1ZGlvQXBpID8/IGZhbHNlXG4gIH0pO1xuICB1c2VJbXBlcmF0aXZlSGFuZGxlNShyZWYsICgpID0+IHtcbiAgICByZXR1cm4gYXVkaW9SZWYuY3VycmVudDtcbiAgfSwgW2F1ZGlvUmVmXSk7XG4gIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYxMShvbkR1cmF0aW9uKTtcbiAgY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50ID0gb25EdXJhdGlvbjtcbiAgdXNlRWZmZWN0MTQoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXVkaW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgfTtcbiAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBvbkxvYWRlZE1ldGFkYXRhKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgfTtcbiAgfSwgW2F1ZGlvUmVmLCBzcmNdKTtcbiAgaWYgKGluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE3KFwiYXVkaW9cIiwge1xuICAgIHJlZjogYXVkaW9SZWYsXG4gICAgcHJlbG9hZDogXCJtZXRhZGF0YVwiLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIC4uLnByb3BzVG9QYXNzXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclByZXZpZXcgPSBmb3J3YXJkUmVmNChBdWRpb0ZvckRldmVsb3BtZW50Rm9yd2FyZFJlZkZ1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjUsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNSxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNixcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDYsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzIxLFxuICB1c2VSZWYgYXMgdXNlUmVmMTJcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MTggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBBdWRpb0ZvclJlbmRlcmluZ1JlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gIGNvbnN0IGF1ZGlvUmVmID0gdXNlUmVmMTIobnVsbCk7XG4gIGNvbnN0IHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gICAgbmFtZSxcbiAgICBvbk5hdGl2ZUVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgYXVkaW9TdHJlYW1JbmRleCxcbiAgICAuLi5uYXRpdmVQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dDI1KFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0MjUoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBjb25zdCBpZCA9IHVzZU1lbW8yMSgoKSA9PiBgYXVkaW8tJHtyYW5kb20ocHJvcHMuc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHByb3BzLnNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHdhcm5BYm91dFRvb0hpZ2hWb2x1bWUodm9sdW1lKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTYocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIGF1ZGlvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MTUoKCkgPT4ge1xuICAgIGlmICghcHJvcHMuc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLm11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2b2x1bWUgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ID8/IDEsXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpLFxuICAgICAgYXVkaW9TdHJlYW1JbmRleDogYXVkaW9TdHJlYW1JbmRleCA/PyAwXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gIH0sIFtcbiAgICBwcm9wcy5tdXRlZCxcbiAgICBwcm9wcy5zcmMsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIGlkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICB2b2x1bWUsXG4gICAgdm9sdW1lUHJvcEZyYW1lLFxuICAgIGZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBwcm9wcy5wbGF5YmFja1JhdGUsXG4gICAgdG9uZUZyZXF1ZW5jeSxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbSxcbiAgICBhdWRpb1N0cmVhbUluZGV4XG4gIF0pO1xuICBjb25zdCB7IHNyYyB9ID0gcHJvcHM7XG4gIGNvbnN0IG5lZWRzVG9SZW5kZXJBdWRpb1RhZyA9IHJlZiB8fCBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjtcbiAgdXNlTGF5b3V0RWZmZWN0NigoKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcjIoXCJMb2FkaW5nIDxIdG1sNUF1ZGlvPiBkdXJhdGlvbiB3aXRoIHNyYz1cIiArIHNyYywge1xuICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICBjb25zdCBkaWRMb2FkID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgfTtcbiAgICBpZiAoY3VycmVudD8uZHVyYXRpb24pIHtcbiAgICAgIG9uRHVyYXRpb24oY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjdXJyZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgZGlkTG9hZCk7XG4gICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgc3JjLFxuICAgIG9uRHVyYXRpb24sXG4gICAgbmVlZHNUb1JlbmRlckF1ZGlvVGFnLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgZGVsYXlSZW5kZXIyXG4gIF0pO1xuICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTgoXCJhdWRpb1wiLCB7XG4gICAgcmVmOiBhdWRpb1JlZixcbiAgICAuLi5uYXRpdmVQcm9wcyxcbiAgICBvbkVycm9yOiBvbk5hdGl2ZUVycm9yXG4gIH0pO1xufTtcbnZhciBBdWRpb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWY1KEF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLy8gc3JjL2F1ZGlvL0F1ZGlvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDE5IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0MjYoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICB0cmltQmVmb3JlLFxuICAgIHRyaW1BZnRlcixcbiAgICBuYW1lLFxuICAgIHN0YWNrLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICBvbkVycm9yOiBvblJlbW90aW9uRXJyb3IsXG4gICAgLi4ub3RoZXJQcm9wc1xuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0MjYoRHVyYXRpb25zQ29udGV4dCk7XG4gIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYDxIdG1sNUF1ZGlvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChwcm9wcy5zcmMpO1xuICBjb25zdCBvbkVycm9yID0gdXNlQ2FsbGJhY2sxMSgoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUuY3VycmVudFRhcmdldC5lcnJvcik7XG4gICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDb3VsZCBub3QgcGxheSBhdWRpbyB3aXRoIHNyYyAke3ByZWxvYWRlZFNyY306ICR7ZS5jdXJyZW50VGFyZ2V0LmVycm9yfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuYDtcbiAgICBpZiAobG9vcCkge1xuICAgICAgaWYgKG9uUmVtb3Rpb25FcnJvcikge1xuICAgICAgICBvblJlbW90aW9uRXJyb3IobmV3IEVycm9yKGVyck1lc3NhZ2UpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FuY2VsUmVuZGVyKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uUmVtb3Rpb25FcnJvcj8uKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgICBjb25zb2xlLndhcm4oZXJyTWVzc2FnZSk7XG4gICAgfVxuICB9LCBbbG9vcCwgb25SZW1vdGlvbkVycm9yLCBwcmVsb2FkZWRTcmNdKTtcbiAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrMTEoKHNyYywgZHVyYXRpb25JblNlY29uZHMpID0+IHtcbiAgICBzZXREdXJhdGlvbnMoeyB0eXBlOiBcImdvdC1kdXJhdGlvblwiLCBkdXJhdGlvbkluU2Vjb25kcywgc3JjIH0pO1xuICB9LCBbc2V0RHVyYXRpb25zXSk7XG4gIGNvbnN0IGR1cmF0aW9uRmV0Y2hlZCA9IGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcmVsb2FkZWRTcmMpXSA/PyBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKV07XG4gIHZhbGlkYXRlTWVkaWFUcmltUHJvcHMoeyBzdGFydEZyb20sIGVuZEF0LCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIgfSk7XG4gIGNvbnN0IHsgdHJpbUJlZm9yZVZhbHVlLCB0cmltQWZ0ZXJWYWx1ZSB9ID0gcmVzb2x2ZVRyaW1Qcm9wcyh7XG4gICAgc3RhcnRGcm9tLFxuICAgIGVuZEF0LFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdHJpbUFmdGVyXG4gIH0pO1xuICBpZiAobG9vcCAmJiBkdXJhdGlvbkZldGNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uRmV0Y2hlZCkpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MTkoSHRtbDVBdWRpbywge1xuICAgICAgICAuLi5wcm9wc090aGVyVGhhbkxvb3AsXG4gICAgICAgIHJlZixcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSBkdXJhdGlvbkZldGNoZWQgKiBmcHM7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOShMb29wLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTWVkaWFEdXJhdGlvbih7XG4gICAgICAgIHRyaW1BZnRlcjogdHJpbUFmdGVyVmFsdWUsXG4gICAgICAgIG1lZGlhRHVyYXRpb25JbkZyYW1lczogZHVyYXRpb24sXG4gICAgICAgIHBsYXliYWNrUmF0ZTogcHJvcHMucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHRyaW1CZWZvcmU6IHRyaW1CZWZvcmVWYWx1ZVxuICAgICAgfSksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDE5KEh0bWw1QXVkaW8sIHtcbiAgICAgICAgLi4ucHJvcHNPdGhlclRoYW5Mb29wLFxuICAgICAgICByZWYsXG4gICAgICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogdHJ1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHRyaW1CZWZvcmVWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgdHJpbUFmdGVyVmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDE5KFNlcXVlbmNlLCB7XG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgZnJvbTogMCAtICh0cmltQmVmb3JlVmFsdWUgPz8gMCksXG4gICAgICBzaG93SW5UaW1lbGluZTogZmFsc2UsXG4gICAgICBkdXJhdGlvbkluRnJhbWVzOiB0cmltQWZ0ZXJWYWx1ZSxcbiAgICAgIG5hbWUsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDE5KEh0bWw1QXVkaW8sIHtcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCksXG4gICAgICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgICByZWZcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHsgcGxheWJhY2tSYXRlOiBwcm9wcy5wbGF5YmFja1JhdGUsIHZvbHVtZTogcHJvcHMudm9sdW1lIH0sIFwiSHRtbDVBdWRpb1wiKTtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOShBdWRpb0ZvclJlbmRlcmluZywge1xuICAgICAgb25EdXJhdGlvbixcbiAgICAgIC4uLnByb3BzLFxuICAgICAgcmVmLFxuICAgICAgb25OYXRpdmVFcnJvcjogb25FcnJvcixcbiAgICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uOiBCb29sZWFuKGxvb3ApXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gxOShBdWRpb0ZvclByZXZpZXcsIHtcbiAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHByb3BzLl9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCA/PyBmYWxzZSxcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgIHNob3VsZFByZU1vdW50QXVkaW9UYWdzOiBhdWRpb0NvbnRleHQgIT09IG51bGwgJiYgYXVkaW9Db250ZXh0Lm51bWJlck9mQXVkaW9UYWdzID4gMCxcbiAgICAuLi5wcm9wcyxcbiAgICByZWYsXG4gICAgb25OYXRpdmVFcnJvcjogb25FcnJvcixcbiAgICBvbkR1cmF0aW9uLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZzogcGF1c2VXaGVuQnVmZmVyaW5nID8/IGZhbHNlLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uOiBCb29sZWFuKGxvb3ApLFxuICAgIHNob3dJblRpbWVsaW5lOiBzaG93SW5UaW1lbGluZSA/PyB0cnVlXG4gIH0pO1xufTtcbnZhciBIdG1sNUF1ZGlvID0gZm9yd2FyZFJlZjYoQXVkaW9SZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhIdG1sNUF1ZGlvKTtcbnZhciBBdWRpbyA9IEh0bWw1QXVkaW87XG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBTdXNwZW5zZSwgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MjgsIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxNyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuXG4vLyBzcmMvRm9sZGVyLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTcsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDI3LCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MTYsIHVzZU1lbW8gYXMgdXNlTWVtbzIyIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWZvbGRlci1uYW1lLnRzXG52YXIgZ2V0UmVnZXggPSAoKSA9PiAvXihbYS16QS1aMC05LVxcdTRFMDAtXFx1OUZGRl0pKyQvZztcbnZhciBpc0ZvbGRlck5hbWVWYWxpZCA9IChuYW1lKSA9PiBuYW1lLm1hdGNoKGdldFJlZ2V4KCkpO1xudmFyIHZhbGlkYXRlRm9sZGVyTmFtZSA9IChuYW1lKSA9PiB7XG4gIGlmIChuYW1lID09PSB1bmRlZmluZWQgfHwgbmFtZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgbmFtZSB0byBhIDxGb2xkZXIgLz4uXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm5hbWVcIiB5b3UgcGFzcyBpbnRvIDxGb2xkZXIgLz4gbXVzdCBiZSBhIHN0cmluZy4gR290OiAke3R5cGVvZiBuYW1lfWApO1xuICB9XG4gIGlmICghaXNGb2xkZXJOYW1lVmFsaWQobmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZvbGRlciBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gYS16LCBBLVosIDAtOSBhbmQgLS4gWW91IHBhc3NlZCAke25hbWV9YCk7XG4gIH1cbn07XG52YXIgaW52YWxpZEZvbGRlck5hbWVFcnJvck1lc3NhZ2UgPSBgRm9sZGVyIG5hbWUgbXVzdCBtYXRjaCAke1N0cmluZyhnZXRSZWdleCgpKX1gO1xuXG4vLyBzcmMvRm9sZGVyLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDIwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgRm9sZGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxNyh7XG4gIGZvbGRlck5hbWU6IG51bGwsXG4gIHBhcmVudE5hbWU6IG51bGxcbn0pO1xudmFyIEZvbGRlciA9ICh7IG5hbWUsIGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgcGFyZW50ID0gdXNlQ29udGV4dDI3KEZvbGRlckNvbnRleHQpO1xuICBjb25zdCB7IHJlZ2lzdGVyRm9sZGVyLCB1bnJlZ2lzdGVyRm9sZGVyIH0gPSB1c2VDb250ZXh0MjcoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgdmFsaWRhdGVGb2xkZXJOYW1lKG5hbWUpO1xuICBjb25zdCBwYXJlbnROYW1lQXJyID0gW3BhcmVudC5wYXJlbnROYW1lLCBwYXJlbnQuZm9sZGVyTmFtZV0uZmlsdGVyKHRydXRoeSk7XG4gIGNvbnN0IHBhcmVudE5hbWUgPSBwYXJlbnROYW1lQXJyLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBwYXJlbnROYW1lQXJyLmpvaW4oXCIvXCIpO1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8yMigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvbGRlck5hbWU6IG5hbWUsXG4gICAgICBwYXJlbnROYW1lXG4gICAgfTtcbiAgfSwgW25hbWUsIHBhcmVudE5hbWVdKTtcbiAgdXNlRWZmZWN0MTYoKCkgPT4ge1xuICAgIHJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgIH07XG4gIH0sIFtuYW1lLCBwYXJlbnQuZm9sZGVyTmFtZSwgcGFyZW50TmFtZSwgcmVnaXN0ZXJGb2xkZXIsIHVucmVnaXN0ZXJGb2xkZXJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyMChGb2xkZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvbG9hZGluZy1pbmRpY2F0b3IudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjEsIGpzeHMgYXMganN4czIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciByb3RhdGUgPSB7XG4gIHRyYW5zZm9ybTogYHJvdGF0ZSg5MGRlZylgXG59O1xudmFyIElDT05fU0laRSA9IDQwO1xudmFyIGxhYmVsID0ge1xuICBjb2xvcjogXCJ3aGl0ZVwiLFxuICBmb250U2l6ZTogMTQsXG4gIGZvbnRGYW1pbHk6IFwic2Fucy1zZXJpZlwiXG59O1xudmFyIGNvbnRhaW5lciA9IHtcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbn07XG52YXIgTG9hZGluZyA9ICgpID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzMihBYnNvbHV0ZUZpbGwsIHtcbiAgICBzdHlsZTogY29udGFpbmVyLFxuICAgIGlkOiBcInJlbW90aW9uLWNvbXAtbG9hZGluZ1wiLFxuICAgIGNoaWxkcmVuOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4MjEoXCJzdHlsZVwiLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9jc3NcIixcbiAgICAgICAgY2hpbGRyZW46IGBcblx0XHRcdFx0QGtleWZyYW1lcyBhbmltIHtcblx0XHRcdFx0XHRmcm9tIHtcblx0XHRcdFx0XHRcdG9wYWNpdHk6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dG8ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQjcmVtb3Rpb24tY29tcC1sb2FkaW5nIHtcblx0XHRcdFx0XHRhbmltYXRpb246IGFuaW0gMnM7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLWZpbGwtbW9kZTogZm9yd2FyZHM7XG5cdFx0XHRcdH1cblx0XHRcdGBcbiAgICAgIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeDIxKFwic3ZnXCIsIHtcbiAgICAgICAgd2lkdGg6IElDT05fU0laRSxcbiAgICAgICAgaGVpZ2h0OiBJQ09OX1NJWkUsXG4gICAgICAgIHZpZXdCb3g6IFwiLTEwMCAtMTAwIDQwMCA0MDBcIixcbiAgICAgICAgc3R5bGU6IHJvdGF0ZSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMShcInBhdGhcIiwge1xuICAgICAgICAgIGZpbGw6IFwiIzU1NVwiLFxuICAgICAgICAgIHN0cm9rZTogXCIjNTU1XCIsXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IFwiMTAwXCIsXG4gICAgICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgICAgICBkOiBcIk0gMiAxNzIgYSAxOTYgMTAwIDAgMCAwIDE5NSA1IEEgMTk2IDI0MCAwIDAgMCAxMDAgMi4yNTkgQSAxOTYgMjQwIDAgMCAwIDIgMTcyIHpcIlxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4czIoXCJwXCIsIHtcbiAgICAgICAgc3R5bGU6IGxhYmVsLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIFwiUmVzb2x2aW5nIFwiLFxuICAgICAgICAgIFwiPFN1c3BlbnNlPlwiLFxuICAgICAgICAgIFwiLi4uXCJcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xufTtcblxuLy8gc3JjL3BvcnRhbC1ub2RlLnRzXG52YXIgX3BvcnRhbE5vZGUgPSBudWxsO1xudmFyIHBvcnRhbE5vZGUgPSAoKSA9PiB7XG4gIGlmICghX3BvcnRhbE5vZGUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBjYWxsIGFuIEFQSSB0aGF0IG9ubHkgd29ya3MgaW4gdGhlIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHRoZSBicm93c2VyXCIpO1xuICAgIH1cbiAgICBfcG9ydGFsTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XG4gICAgX3BvcnRhbE5vZGUuc3R5bGUuYm90dG9tID0gXCIwcHhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgIF9wb3J0YWxOb2RlLnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICBfcG9ydGFsTm9kZS5zdHlsZS5mbGV4RGlyZWN0aW9uID0gXCJjb2x1bW5cIjtcbiAgICBjb25zdCBjb250YWluZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb250YWluZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgIGNvbnRhaW5lck5vZGUuc3R5bGUudG9wID0gLTk5OTk5OSArIFwicHhcIjtcbiAgICBjb250YWluZXJOb2RlLmFwcGVuZENoaWxkKF9wb3J0YWxOb2RlKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lck5vZGUpO1xuICB9XG4gIHJldHVybiBfcG9ydGFsTm9kZTtcbn07XG5cbi8vIHNyYy91c2UtbGF6eS1jb21wb25lbnQudHNcbmltcG9ydCBSZWFjdDIwLCB7IHVzZU1lbW8gYXMgdXNlTWVtbzIzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlTGF6eUNvbXBvbmVudCA9ICh7XG4gIGNvbXBQcm9wcyxcbiAgY29tcG9uZW50TmFtZSxcbiAgbm9TdXNwZW5zZVxufSkgPT4ge1xuICBjb25zdCBsYXp5ID0gdXNlTWVtbzIzKCgpID0+IHtcbiAgICBpZiAoXCJjb21wb25lbnRcIiBpbiBjb21wUHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgbm9TdXNwZW5zZSkge1xuICAgICAgICByZXR1cm4gY29tcFByb3BzLmNvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29tcFByb3BzLmNvbXBvbmVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgdmFsdWUgb2YgXFxgdW5kZWZpbmVkXFxgIHdhcyBwYXNzZWQgdG8gdGhlIFxcYGNvbXBvbmVudFxcYCBwcm9wLiBDaGVjayB0aGUgdmFsdWUgeW91IGFyZSBwYXNzaW5nIHRvIHRoZSA8JHtjb21wb25lbnROYW1lfS8+IGNvbXBvbmVudC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wUHJvcHMuY29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoXCJsYXp5Q29tcG9uZW50XCIgaW4gY29tcFByb3BzICYmIHR5cGVvZiBjb21wUHJvcHMubGF6eUNvbXBvbmVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBjb21wUHJvcHMubGF6eUNvbXBvbmVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgdmFsdWUgb2YgXFxgdW5kZWZpbmVkXFxgIHdhcyBwYXNzZWQgdG8gdGhlIFxcYGxhenlDb21wb25lbnRcXGAgcHJvcC4gQ2hlY2sgdGhlIHZhbHVlIHlvdSBhcmUgcGFzc2luZyB0byB0aGUgPCR7Y29tcG9uZW50TmFtZX0vPiBjb21wb25lbnQuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3QyMC5sYXp5KGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBlaXRoZXIgJ2NvbXBvbmVudCcgb3IgJ2xhenlDb21wb25lbnQnXCIpO1xuICB9LCBbY29tcFByb3BzLmNvbXBvbmVudCwgY29tcFByb3BzLmxhenlDb21wb25lbnRdKTtcbiAgcmV0dXJuIGxhenk7XG59O1xuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1jb21wb3NpdGlvbi1pZC50c1xudmFyIGdldFJlZ2V4MiA9ICgpID0+IC9eKFthLXpBLVowLTktXFx1NEUwMC1cXHU5RkZGXSkrJC9nO1xudmFyIGlzQ29tcG9zaXRpb25JZFZhbGlkID0gKGlkKSA9PiBpZC5tYXRjaChnZXRSZWdleDIoKSk7XG52YXIgdmFsaWRhdGVDb21wb3NpdGlvbklkID0gKGlkKSA9PiB7XG4gIGlmICghaXNDb21wb3NpdGlvbklkVmFsaWQoaWQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb3NpdGlvbiBpZCBjYW4gb25seSBjb250YWluIGEteiwgQS1aLCAwLTksIENKSyBjaGFyYWN0ZXJzIGFuZCAtLiBZb3UgcGFzc2VkICR7aWR9YCk7XG4gIH1cbn07XG52YXIgaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlID0gYENvbXBvc2l0aW9uIElEIG11c3QgbWF0Y2ggJHtTdHJpbmcoZ2V0UmVnZXgyKCkpfWA7XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtcHJvcHMudHNcbnZhciB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzID0gKGRlZmF1bHRQcm9wcywgbmFtZSwgY29tcG9zaXRpb25JZCkgPT4ge1xuICBpZiAoIWRlZmF1bHRQcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRQcm9wcyAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0UHJvcHN9YCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdFByb3BzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGFuIGFycmF5IHdhcyBwYXNzZWQgJHtjb21wb3NpdGlvbklkID8gYGZvciBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImAgOiBcIlwifWApO1xuICB9XG59O1xuXG4vLyBzcmMvQ29tcG9zaXRpb24udHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBGYWxsYmFjayA9ICgpID0+IHtcbiAgY29uc3QgeyBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyLCBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICB1c2VFZmZlY3QxNygoKSA9PiB7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBkZWxheVJlbmRlcjIoXCJXYWl0aW5nIGZvciBSb290IGNvbXBvbmVudCB0byB1bnN1c3BlbmRcIik7XG4gICAgcmV0dXJuICgpID0+IGNvbnRpbnVlUmVuZGVyMihmYWxsYmFjayk7XG4gIH0sIFtjb250aW51ZVJlbmRlcjIsIGRlbGF5UmVuZGVyMl0pO1xuICByZXR1cm4gbnVsbDtcbn07XG52YXIgSW5uZXJDb21wb3NpdGlvbiA9ICh7XG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGZwcyxcbiAgZHVyYXRpb25JbkZyYW1lcyxcbiAgaWQsXG4gIGRlZmF1bHRQcm9wcyxcbiAgc2NoZW1hLFxuICAuLi5jb21wUHJvcHNcbn0pID0+IHtcbiAgY29uc3QgY29tcE1hbmFnZXIgPSB1c2VDb250ZXh0MjgoQ29tcG9zaXRpb25TZXR0ZXJzKTtcbiAgY29uc3QgeyByZWdpc3RlckNvbXBvc2l0aW9uLCB1bnJlZ2lzdGVyQ29tcG9zaXRpb24gfSA9IGNvbXBNYW5hZ2VyO1xuICBjb25zdCB2aWRlbyA9IHVzZVZpZGVvKCk7XG4gIGNvbnN0IGxhenkgPSB1c2VMYXp5Q29tcG9uZW50KHtcbiAgICBjb21wUHJvcHMsXG4gICAgY29tcG9uZW50TmFtZTogXCJDb21wb3NpdGlvblwiLFxuICAgIG5vU3VzcGVuc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gIGNvbnN0IGlzUGxheWVyID0gdXNlSXNQbGF5ZXIoKTtcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGNvbnN0IGNhblVzZUNvbXBvc2l0aW9uID0gdXNlQ29udGV4dDI4KENhblVzZVJlbW90aW9uSG9va3MpO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9zZWVuQ29tcG9zaXRpb25JZHMgPSBBcnJheS5mcm9tKG5ldyBTZXQoWy4uLndpbmRvdy5yZW1vdGlvbl9zZWVuQ29tcG9zaXRpb25JZHMgPz8gW10sIGlkXSkpO1xuICB9XG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbikge1xuICAgIGlmIChpc1BsYXllcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPENvbXBvc2l0aW9uPiB3YXMgbW91bnRlZCBpbnNpZGUgdGhlIGBjb21wb25lbnRgIHRoYXQgd2FzIHBhc3NlZCB0byB0aGUgPFBsYXllcj4uIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3dyb25nLWNvbXBvc2l0aW9uLW1vdW50IGZvciBoZWxwLlwiKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiPENvbXBvc2l0aW9uPiBtb3VudGVkIGluc2lkZSBhbm90aGVyIGNvbXBvc2l0aW9uLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy93cm9uZy1jb21wb3NpdGlvbi1tb3VudCBmb3IgaGVscC5cIik7XG4gIH1cbiAgY29uc3QgeyBmb2xkZXJOYW1lLCBwYXJlbnROYW1lIH0gPSB1c2VDb250ZXh0MjgoRm9sZGVyQ29udGV4dCk7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpZCBmb3IgY29tcG9zaXRpb24gcGFzc2VkLlwiKTtcbiAgICB9XG4gICAgdmFsaWRhdGVDb21wb3NpdGlvbklkKGlkKTtcbiAgICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzKGRlZmF1bHRQcm9wcywgXCJkZWZhdWx0UHJvcHNcIiwgaWQpO1xuICAgIHJlZ2lzdGVyQ29tcG9zaXRpb24oe1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogZHVyYXRpb25JbkZyYW1lcyA/PyB1bmRlZmluZWQsXG4gICAgICBmcHM6IGZwcyA/PyB1bmRlZmluZWQsXG4gICAgICBoZWlnaHQ6IGhlaWdodCA/PyB1bmRlZmluZWQsXG4gICAgICB3aWR0aDogd2lkdGggPz8gdW5kZWZpbmVkLFxuICAgICAgaWQsXG4gICAgICBmb2xkZXJOYW1lLFxuICAgICAgY29tcG9uZW50OiBsYXp5LFxuICAgICAgZGVmYXVsdFByb3BzOiBzZXJpYWxpemVUaGVuRGVzZXJpYWxpemVJblN0dWRpbyhkZWZhdWx0UHJvcHMgPz8ge30pLFxuICAgICAgbm9uY2UsXG4gICAgICBwYXJlbnRGb2xkZXJOYW1lOiBwYXJlbnROYW1lLFxuICAgICAgc2NoZW1hOiBzY2hlbWEgPz8gbnVsbCxcbiAgICAgIGNhbGN1bGF0ZU1ldGFkYXRhOiBjb21wUHJvcHMuY2FsY3VsYXRlTWV0YWRhdGEgPz8gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb24oaWQpO1xuICAgIH07XG4gIH0sIFtcbiAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgIGZwcyxcbiAgICBoZWlnaHQsXG4gICAgbGF6eSxcbiAgICBpZCxcbiAgICBmb2xkZXJOYW1lLFxuICAgIGRlZmF1bHRQcm9wcyxcbiAgICB3aWR0aCxcbiAgICBub25jZSxcbiAgICBwYXJlbnROYW1lLFxuICAgIHNjaGVtYSxcbiAgICBjb21wUHJvcHMuY2FsY3VsYXRlTWV0YWRhdGEsXG4gICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyQ29tcG9zaXRpb25cbiAgXSk7XG4gIHVzZUVmZmVjdDE3KCgpID0+IHtcbiAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZLCB7XG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgcmVzZXRVbnNhdmVkOiBpZFxuICAgICAgfVxuICAgIH0pKTtcbiAgfSwgW2RlZmF1bHRQcm9wcywgaWRdKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKGlkKTtcbiAgaWYgKGVudmlyb25tZW50LmlzU3R1ZGlvICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgIGNvbnN0IENvbXAgPSBsYXp5O1xuICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3NcIiAmJiByZXNvbHZlZC50eXBlICE9PSBcInN1Y2Nlc3MtYW5kLXJlZnJlc2hpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoLyogQF9fUFVSRV9fICovIGpzeDIyKENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihTdXNwZW5zZSwge1xuICAgICAgICBmYWxsYmFjazogLyogQF9fUFVSRV9fICovIGpzeDIyKExvYWRpbmcsIHt9KSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihDb21wLCB7XG4gICAgICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LnByb3BzID8/IHt9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLCBwb3J0YWxOb2RlKCkpO1xuICB9XG4gIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZyAmJiB2aWRlbyAmJiB2aWRlby5jb21wb25lbnQgPT09IGxhenkpIHtcbiAgICBjb25zdCBDb21wID0gbGF6eTtcbiAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwgfHwgcmVzb2x2ZWQudHlwZSAhPT0gXCJzdWNjZXNzXCIgJiYgcmVzb2x2ZWQudHlwZSAhPT0gXCJzdWNjZXNzLWFuZC1yZWZyZXNoaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUG9ydGFsKC8qIEBfX1BVUkVfXyAqLyBqc3gyMihDYW5Vc2VSZW1vdGlvbkhvb2tzUHJvdmlkZXIsIHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjIoU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qIEBfX1BVUkVfXyAqLyBqc3gyMihGYWxsYmFjaywge30pLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIyKENvbXAsIHtcbiAgICAgICAgICAuLi5yZXNvbHZlZC5yZXN1bHQucHJvcHMgPz8ge31cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSksIHBvcnRhbE5vZGUoKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xudmFyIENvbXBvc2l0aW9uID0gKHByb3BzMikgPT4ge1xuICBjb25zdCB7IG9ubHlSZW5kZXJDb21wb3NpdGlvbiB9ID0gdXNlQ29udGV4dDI4KENvbXBvc2l0aW9uU2V0dGVycyk7XG4gIGlmIChvbmx5UmVuZGVyQ29tcG9zaXRpb24gJiYgb25seVJlbmRlckNvbXBvc2l0aW9uICE9PSBwcm9wczIuaWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDIyKElubmVyQ29tcG9zaXRpb24sIHtcbiAgICAuLi5wcm9wczJcbiAgfSk7XG59O1xuLy8gc3JjL2Jlemllci50c1xudmFyIE5FV1RPTl9JVEVSQVRJT05TID0gNDtcbnZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG52YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xudmFyIFNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TID0gMTA7XG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xudmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEpO1xudmFyIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09IFwiZnVuY3Rpb25cIjtcbmZ1bmN0aW9uIGEoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDEgLSAzICogYUEyICsgMyAqIGFBMTtcbn1cbmZ1bmN0aW9uIGIoYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhQTIgLSA2ICogYUExO1xufVxuZnVuY3Rpb24gYyhhQTEpIHtcbiAgcmV0dXJuIDMgKiBhQTE7XG59XG5mdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICByZXR1cm4gKChhKGFBMSwgYUEyKSAqIGFUICsgYihhQTEsIGFBMikpICogYVQgKyBjKGFBMSkpICogYVQ7XG59XG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgcmV0dXJuIDMgKiBhKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyICogYihhQTEsIGFBMikgKiBhVCArIGMoYUExKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSh7XG4gIGFYLFxuICBfYUEsXG4gIF9hQixcbiAgbVgxLFxuICBtWDJcbn0pIHtcbiAgbGV0IGN1cnJlbnRYO1xuICBsZXQgY3VycmVudFQ7XG4gIGxldCBpID0gMDtcbiAgbGV0IGFBID0gX2FBO1xuICBsZXQgYUIgPSBfYUI7XG4gIGRvIHtcbiAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMjtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDApIHtcbiAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgfVxuICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xuICByZXR1cm4gY3VycmVudFQ7XG59XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgX2FHdWVzc1QsIG1YMSwgbVgyKSB7XG4gIGxldCBhR3Vlc3NUID0gX2FHdWVzc1Q7XG4gIGZvciAobGV0IGkgPSAwO2kgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgY29uc3QgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDApIHtcbiAgICAgIHJldHVybiBhR3Vlc3NUO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgfVxuICByZXR1cm4gYUd1ZXNzVDtcbn1cbmZ1bmN0aW9uIGJlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgaWYgKCEobVgxID49IDAgJiYgbVgxIDw9IDEgJiYgbVgyID49IDAgJiYgbVgyIDw9IDEpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXCIpO1xuICB9XG4gIGNvbnN0IHNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgIGZvciAobGV0IGkgPSAwO2kgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMDtcbiAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgIGZvciAoO2N1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgIH1cbiAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAoc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwKSB7XG4gICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgIH1cbiAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKHtcbiAgICAgIGFYLFxuICAgICAgX2FBOiBpbnRlcnZhbFN0YXJ0LFxuICAgICAgX2FCOiBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLFxuICAgICAgbVgxLFxuICAgICAgbVgyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICh4ID09PSAxKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGNCZXppZXIoZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgfTtcbn1cblxuLy8gc3JjL2Vhc2luZy50c1xuY2xhc3MgRWFzaW5nIHtcbiAgc3RhdGljIHN0ZXAwKG4pIHtcbiAgICByZXR1cm4gbiA+IDAgPyAxIDogMDtcbiAgfVxuICBzdGF0aWMgc3RlcDEobikge1xuICAgIHJldHVybiBuID49IDEgPyAxIDogMDtcbiAgfVxuICBzdGF0aWMgbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBzdGF0aWMgZWFzZSh0KSB7XG4gICAgcmV0dXJuIEVhc2luZy5iZXppZXIoMC40MiwgMCwgMSwgMSkodCk7XG4gIH1cbiAgc3RhdGljIHF1YWQodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuICBzdGF0aWMgY3ViaWModCkge1xuICAgIHJldHVybiB0ICogdCAqIHQ7XG4gIH1cbiAgc3RhdGljIHBvbHkobikge1xuICAgIHJldHVybiAodCkgPT4gdCAqKiBuO1xuICB9XG4gIHN0YXRpYyBzaW4odCkge1xuICAgIHJldHVybiAxIC0gTWF0aC5jb3ModCAqIE1hdGguUEkgLyAyKTtcbiAgfVxuICBzdGF0aWMgY2lyY2xlKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xuICB9XG4gIHN0YXRpYyBleHAodCkge1xuICAgIHJldHVybiAyICoqICgxMCAqICh0IC0gMSkpO1xuICB9XG4gIHN0YXRpYyBlbGFzdGljKGJvdW5jaW5lc3MgPSAxKSB7XG4gICAgY29uc3QgcCA9IGJvdW5jaW5lc3MgKiBNYXRoLlBJO1xuICAgIHJldHVybiAodCkgPT4gMSAtIE1hdGguY29zKHQgKiBNYXRoLlBJIC8gMikgKiogMyAqIE1hdGguY29zKHQgKiBwKTtcbiAgfVxuICBzdGF0aWMgYmFjayhzID0gMS43MDE1OCkge1xuICAgIHJldHVybiAodCkgPT4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfVxuICBzdGF0aWMgYm91bmNlKHQpIHtcbiAgICBpZiAodCA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDIuNzUpIHtcbiAgICAgIGNvbnN0IHQyXyA9IHQgLSAxLjUgLyAyLjc1O1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQyXyAqIHQyXyArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgMi41IC8gMi43NSkge1xuICAgICAgY29uc3QgdDJfID0gdCAtIDIuMjUgLyAyLjc1O1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIHQyXyAqIHQyXyArIDAuOTM3NTtcbiAgICB9XG4gICAgY29uc3QgdDIgPSB0IC0gMi42MjUgLyAyLjc1O1xuICAgIHJldHVybiA3LjU2MjUgKiB0MiAqIHQyICsgMC45ODQzNzU7XG4gIH1cbiAgc3RhdGljIGJlemllcih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBiZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICB9XG4gIHN0YXRpYyBpbihlYXNpbmcpIHtcbiAgICByZXR1cm4gZWFzaW5nO1xuICB9XG4gIHN0YXRpYyBvdXQoZWFzaW5nKSB7XG4gICAgcmV0dXJuICh0KSA9PiAxIC0gZWFzaW5nKDEgLSB0KTtcbiAgfVxuICBzdGF0aWMgaW5PdXQoZWFzaW5nKSB7XG4gICAgcmV0dXJuICh0KSA9PiB7XG4gICAgICBpZiAodCA8IDAuNSkge1xuICAgICAgICByZXR1cm4gZWFzaW5nKHQgKiAyKSAvIDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gMSAtIGVhc2luZygoMSAtIHQpICogMikgLyAyO1xuICAgIH07XG4gIH1cbn1cbi8vIHNyYy92NS1mbGFnLnRzXG52YXIgRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPSBmYWxzZTtcblxuLy8gc3JjL2dldC1zdGF0aWMtZmlsZXMudHNcbnZhciB3YXJuZWRTZXJ2ZXIgPSBmYWxzZTtcbnZhciB3YXJuZWRQbGF5ZXIgPSBmYWxzZTtcbnZhciB3YXJuU2VydmVyT25jZSA9ICgpID0+IHtcbiAgaWYgKHdhcm5lZFNlcnZlcikge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuZWRTZXJ2ZXIgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgZ2V0U3RhdGljRmlsZXMoKSBvbiB0aGUgc2VydmVyLiBUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyLiBBbiBlbXB0eSBhcnJheSB3YXMgcmV0dXJuZWQuXCIpO1xufTtcbnZhciB3YXJuUGxheWVyT25jZSA9ICgpID0+IHtcbiAgaWYgKHdhcm5lZFBsYXllcikge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuZWRQbGF5ZXIgPSB0cnVlO1xuICBjb25zb2xlLndhcm4oXCJDYWxsZWQgZ2V0U3RhdGljRmlsZXMoKSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gUGxheWVyLiBUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uIEFuIGVtcHR5IGFycmF5IHdhcyByZXR1cm5lZC5cIik7XG59O1xudmFyIGdldFN0YXRpY0ZpbGVzID0gKCkgPT4ge1xuICBpZiAoRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRTdGF0aWNGaWxlcygpIGhhcyBtb3ZlZCBpbnRvIHRoZSBgQHJlbW90aW9uL3N0dWRpb2AgcGFja2FnZS4gVXBkYXRlIHlvdXIgaW1wb3J0cy5cIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHdhcm5TZXJ2ZXJPbmNlKCk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICh3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIpIHtcbiAgICB3YXJuUGxheWVyT25jZSgpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlbW90aW9uX3N0YXRpY0ZpbGVzO1xufTtcbi8vIHNyYy9JRnJhbWUudHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY3LCB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEyLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE1IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MjMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBJRnJhbWVSZWZGb3J3YXJkaW5nID0gKHtcbiAgb25Mb2FkLFxuICBvbkVycm9yLFxuICBkZWxheVJlbmRlclJldHJpZXMsXG4gIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAuLi5wcm9wczJcbn0sIHJlZikgPT4ge1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIGNvbnN0IFtoYW5kbGVdID0gdXNlU3RhdGUxNSgoKSA9PiBkZWxheVJlbmRlcjIoYExvYWRpbmcgPElGcmFtZT4gd2l0aCBzb3VyY2UgJHtwcm9wczIuc3JjfWAsIHtcbiAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgIHRpbWVvdXRJbk1pbGxpc2Vjb25kczogZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMgPz8gdW5kZWZpbmVkXG4gIH0pKTtcbiAgY29uc3QgZGlkTG9hZCA9IHVzZUNhbGxiYWNrMTIoKGUpID0+IHtcbiAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICBvbkxvYWQ/LihlKTtcbiAgfSwgW2hhbmRsZSwgb25Mb2FkLCBjb250aW51ZVJlbmRlcjJdKTtcbiAgY29uc3QgZGlkR2V0RXJyb3IgPSB1c2VDYWxsYmFjazEyKChlKSA9PiB7XG4gICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3IoZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBsb2FkaW5nIGlmcmFtZTpcIiwgZSwgXCJIYW5kbGUgdGhlIGV2ZW50IHVzaW5nIHRoZSBvbkVycm9yKCkgcHJvcCB0byBtYWtlIHRoaXMgbWVzc2FnZSBkaXNhcHBlYXIuXCIpO1xuICAgIH1cbiAgfSwgW2hhbmRsZSwgb25FcnJvciwgY29udGludWVSZW5kZXIyXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MjMoXCJpZnJhbWVcIiwge1xuICAgIC4uLnByb3BzMixcbiAgICByZWYsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3IsXG4gICAgb25Mb2FkOiBkaWRMb2FkXG4gIH0pO1xufTtcbnZhciBJRnJhbWUgPSBmb3J3YXJkUmVmNyhJRnJhbWVSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9JbWcudHN4XG5pbXBvcnQge1xuICBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWY4LFxuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazEzLFxuICB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyOSxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlNyxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDcsXG4gIHVzZVJlZiBhcyB1c2VSZWYxM1xufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGpzeCBhcyBqc3gyNCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuZnVuY3Rpb24gZXhwb25lbnRpYWxCYWNrb2ZmKGVycm9yQ291bnQpIHtcbiAgcmV0dXJuIDEwMDAgKiAyICoqIChlcnJvckNvdW50IC0gMSk7XG59XG52YXIgSW1nUmVmRm9yd2FyZGluZyA9ICh7XG4gIG9uRXJyb3IsXG4gIG1heFJldHJpZXMgPSAyLFxuICBzcmMsXG4gIHBhdXNlV2hlbkxvYWRpbmcsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIG9uSW1hZ2VGcmFtZSxcbiAgY3Jvc3NPcmlnaW4sXG4gIC4uLnByb3BzMlxufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmMTMobnVsbCk7XG4gIGNvbnN0IGVycm9ycyA9IHVzZVJlZjEzKHt9KTtcbiAgY29uc3QgeyBkZWxheVBsYXliYWNrIH0gPSB1c2VCdWZmZXJTdGF0ZSgpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MjkoU2VxdWVuY2VDb250ZXh0KTtcbiAgaWYgKCFzcmMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwic3JjXCIgcHJvcCB3YXMgcGFzc2VkIHRvIDxJbWc+LicpO1xuICB9XG4gIGNvbnN0IF9wcm9wc1ZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFfcHJvcHNWYWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInR5cGVjaGVjayBlcnJvclwiKTtcbiAgfVxuICB1c2VJbXBlcmF0aXZlSGFuZGxlNyhyZWYsICgpID0+IHtcbiAgICByZXR1cm4gaW1hZ2VSZWYuY3VycmVudDtcbiAgfSwgW10pO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VQcmVsb2FkKHNyYyk7XG4gIGNvbnN0IHJldHJ5SW4gPSB1c2VDYWxsYmFjazEzKCh0aW1lb3V0KSA9PiB7XG4gICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRTcmMgPSBpbWFnZVJlZi5jdXJyZW50LnNyYztcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdTcmMgPSBpbWFnZVJlZi5jdXJyZW50Py5zcmM7XG4gICAgICBpZiAobmV3U3JjICE9PSBjdXJyZW50U3JjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGltYWdlUmVmLmN1cnJlbnQucmVtb3ZlQXR0cmlidXRlKFwic3JjXCIpO1xuICAgICAgaW1hZ2VSZWYuY3VycmVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgbmV3U3JjKTtcbiAgICB9LCB0aW1lb3V0KTtcbiAgfSwgW10pO1xuICBjb25zdCBkaWRHZXRFcnJvciA9IHVzZUNhbGxiYWNrMTMoKGUpID0+IHtcbiAgICBpZiAoIWVycm9ycy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPSAoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSArIDE7XG4gICAgaWYgKG9uRXJyb3IgJiYgKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPiBtYXhSZXRyaWVzKSB7XG4gICAgICBvbkVycm9yKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKGVycm9ycy5jdXJyZW50W2ltYWdlUmVmLmN1cnJlbnQ/LnNyY10gPz8gMCkgPD0gbWF4UmV0cmllcykge1xuICAgICAgY29uc3QgYmFja29mZiA9IGV4cG9uZW50aWFsQmFja29mZihlcnJvcnMuY3VycmVudFtpbWFnZVJlZi5jdXJyZW50Py5zcmNdID8/IDApO1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgbG9hZCBpbWFnZSB3aXRoIHNvdXJjZSAke2ltYWdlUmVmLmN1cnJlbnQ/LnNyY30sIHJldHJ5aW5nIGFnYWluIGluICR7YmFja29mZn1tc2ApO1xuICAgICAgcmV0cnlJbihiYWNrb2ZmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FuY2VsUmVuZGVyKFwiRXJyb3IgbG9hZGluZyBpbWFnZSB3aXRoIHNyYzogXCIgKyBpbWFnZVJlZi5jdXJyZW50Py5zcmMpO1xuICB9LCBbbWF4UmV0cmllcywgb25FcnJvciwgcmV0cnlJbl0pO1xuICBjb25zdCB7IGRlbGF5UmVuZGVyOiBkZWxheVJlbmRlcjIsIGNvbnRpbnVlUmVuZGVyOiBjb250aW51ZVJlbmRlcjIgfSA9IHVzZURlbGF5UmVuZGVyKCk7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uc3QgaXNQcmVtb3VudGluZyA9IEJvb2xlYW4oc2VxdWVuY2VDb250ZXh0Py5wcmVtb3VudGluZyk7XG4gICAgY29uc3QgaXNQb3N0bW91bnRpbmcgPSBCb29sZWFuKHNlcXVlbmNlQ29udGV4dD8ucG9zdG1vdW50aW5nKTtcbiAgICB1c2VMYXlvdXRFZmZlY3Q3KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgaWYgKGltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBpbWFnZVJlZi5jdXJyZW50LnNyYyA9IGFjdHVhbFNyYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IGltYWdlUmVmO1xuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyMihcIkxvYWRpbmcgPEltZz4gd2l0aCBzcmM9XCIgKyBhY3R1YWxTcmMsIHtcbiAgICAgICAgcmV0cmllczogZGVsYXlSZW5kZXJSZXRyaWVzID8/IHVuZGVmaW5lZCxcbiAgICAgICAgdGltZW91dEluTWlsbGlzZWNvbmRzOiBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyA/PyB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdW5ibG9jayA9IHBhdXNlV2hlbkxvYWRpbmcgJiYgIWlzUHJlbW91bnRpbmcgJiYgIWlzUG9zdG1vdW50aW5nID8gZGVsYXlQbGF5YmFjaygpLnVuYmxvY2sgOiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH07XG4gICAgICBsZXQgdW5tb3VudGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAodW5tb3VudGVkKSB7XG4gICAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXSA/PyAwKSA+IDApIHtcbiAgICAgICAgICBkZWxldGUgZXJyb3JzLmN1cnJlbnRbaW1hZ2VSZWYuY3VycmVudD8uc3JjXTtcbiAgICAgICAgICBjb25zb2xlLmluZm8oYFJldHJ5IHN1Y2Nlc3NmdWwgLSAke2ltYWdlUmVmLmN1cnJlbnQ/LnNyY30gaXMgbm93IGxvYWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgb25JbWFnZUZyYW1lPy4oY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdW5ibG9jaygpO1xuICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgIH07XG4gICAgICBpZiAoIWltYWdlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdXJyZW50LnNyYyA9IGFjdHVhbFNyYztcbiAgICAgIGN1cnJlbnQuZGVjb2RlKCkudGhlbihvbkNvbXBsZXRlKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICBpZiAoY3VycmVudC5jb21wbGV0ZSkge1xuICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVubW91bnRlZCA9IHRydWU7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Db21wbGV0ZSk7XG4gICAgICAgIHVuYmxvY2soKTtcbiAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIGFjdHVhbFNyYyxcbiAgICAgIGRlbGF5UGxheWJhY2ssXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIHBhdXNlV2hlbkxvYWRpbmcsXG4gICAgICBpc1ByZW1vdW50aW5nLFxuICAgICAgaXNQb3N0bW91bnRpbmcsXG4gICAgICBvbkltYWdlRnJhbWUsXG4gICAgICBjb250aW51ZVJlbmRlcjIsXG4gICAgICBkZWxheVJlbmRlcjJcbiAgICBdKTtcbiAgfVxuICBjb25zdCBjcm9zc09yaWdpblZhbHVlID0gZ2V0Q3Jvc3NPcmlnaW5WYWx1ZSh7XG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgcmVxdWVzdHNWaWRlb0ZyYW1lOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNChcImltZ1wiLCB7XG4gICAgLi4ucHJvcHMyLFxuICAgIHJlZjogaW1hZ2VSZWYsXG4gICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luVmFsdWUsXG4gICAgb25FcnJvcjogZGlkR2V0RXJyb3IsXG4gICAgZGVjb2Rpbmc6IFwic3luY1wiXG4gIH0pO1xufTtcbnZhciBJbWcgPSBmb3J3YXJkUmVmOChJbWdSZWZGb3J3YXJkaW5nKTtcbi8vIHNyYy9pbnRlcm5hbHMudHNcbmltcG9ydCB7IGNyZWF0ZVJlZiBhcyBjcmVhdGVSZWYzIH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy9Db21wb3NpdGlvbk1hbmFnZXIudHN4XG5pbXBvcnQgUmVhY3QyNCwge1xuICB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazE0LFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlIGFzIHVzZUltcGVyYXRpdmVIYW5kbGU4LFxuICB1c2VNZW1vIGFzIHVzZU1lbW8yNCxcbiAgdXNlUmVmIGFzIHVzZVJlZjE0LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE2XG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI1IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgY29tcG9zaXRpb25zUmVmID0gUmVhY3QyNC5jcmVhdGVSZWYoKTtcbnZhciBDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgYXVkaW9MYXRlbmN5SGludFxufSkgPT4ge1xuICBjb25zdCBbY29tcG9zaXRpb25zLCBzZXRDb21wb3NpdGlvbnNdID0gdXNlU3RhdGUxNihbXSk7XG4gIGNvbnN0IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYgPSB1c2VSZWYxNChjb21wb3NpdGlvbnMpO1xuICBjb25zdCBbZm9sZGVycywgc2V0Rm9sZGVyc10gPSB1c2VTdGF0ZTE2KFtdKTtcbiAgY29uc3QgW2NhbnZhc0NvbnRlbnQsIHNldENhbnZhc0NvbnRlbnRdID0gdXNlU3RhdGUxNihudWxsKTtcbiAgY29uc3QgdXBkYXRlQ29tcG9zaXRpb25zID0gdXNlQ2FsbGJhY2sxNCgodXBkYXRlQ29tcHMpID0+IHtcbiAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVkID0gdXBkYXRlQ29tcHMoY29tcHMpO1xuICAgICAgY3VycmVudGNvbXBvc2l0aW9uc1JlZi5jdXJyZW50ID0gdXBkYXRlZDtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyQ29tcG9zaXRpb24gPSB1c2VDYWxsYmFjazE0KChjb21wKSA9PiB7XG4gICAgdXBkYXRlQ29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgaWYgKGNvbXBzLmZpbmQoKGMyKSA9PiBjMi5pZCA9PT0gY29tcC5pZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y29tcC5pZH0gYXJlIHJlZ2lzdGVyZWQuYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IFsuLi5jb21wcywgY29tcF0uc2xpY2UoKS5zb3J0KChhMiwgYjIpID0+IGEyLm5vbmNlIC0gYjIubm9uY2UpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LCBbdXBkYXRlQ29tcG9zaXRpb25zXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrMTQoKGlkKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgcmV0dXJuIGNvbXBzLmZpbHRlcigoYzIpID0+IGMyLmlkICE9PSBpZCk7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazE0KChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgLi4ucHJldkZvbGRlcnMsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBhcmVudFxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IHVucmVnaXN0ZXJGb2xkZXIgPSB1c2VDYWxsYmFjazE0KChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgcmV0dXJuIHByZXZGb2xkZXJzLmZpbHRlcigocCkgPT4gIShwLm5hbWUgPT09IG5hbWUgJiYgcC5wYXJlbnQgPT09IHBhcmVudCkpO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGU4KGNvbXBvc2l0aW9uc1JlZiwgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBnZXRDb21wb3NpdGlvbnM6ICgpID0+IGN1cnJlbnRjb21wb3NpdGlvbnNSZWYuY3VycmVudFxuICAgIH07XG4gIH0sIFtdKTtcbiAgY29uc3QgY29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYzIpID0+IGNhbnZhc0NvbnRlbnQ/LnR5cGUgPT09IFwiY29tcG9zaXRpb25cIiA/IGMyLmlkID09PSBjYW52YXNDb250ZW50LmNvbXBvc2l0aW9uSWQgOiBudWxsKTtcbiAgY29uc3QgdXBkYXRlQ29tcG9zaXRpb25EZWZhdWx0UHJvcHMgPSB1c2VDYWxsYmFjazE0KChpZCwgbmV3RGVmYXVsdFByb3BzKSA9PiB7XG4gICAgc2V0Q29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZCA9IGNvbXBzLm1hcCgoYzIpID0+IHtcbiAgICAgICAgaWYgKGMyLmlkID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jMixcbiAgICAgICAgICAgIGRlZmF1bHRQcm9wczogbmV3RGVmYXVsdFByb3BzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYzI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvc2l0aW9ucyxcbiAgICAgIGZvbGRlcnMsXG4gICAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgICAgIGNhbnZhc0NvbnRlbnRcbiAgICB9O1xuICB9LCBbY29tcG9zaXRpb25zLCBmb2xkZXJzLCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSwgY2FudmFzQ29udGVudF0pO1xuICBjb25zdCBzZXR0ZXJzID0gdXNlTWVtbzI0KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICAgIHNldENhbnZhc0NvbnRlbnQsXG4gICAgICB1cGRhdGVDb21wb3NpdGlvbkRlZmF1bHRQcm9wcyxcbiAgICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICAgIH07XG4gIH0sIFtcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICB1bnJlZ2lzdGVyRm9sZGVyLFxuICAgIHVwZGF0ZUNvbXBvc2l0aW9uRGVmYXVsdFByb3BzLFxuICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvblxuICBdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNShDb21wb3NpdGlvbk1hbmFnZXIuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoQ29tcG9zaXRpb25TZXR0ZXJzLlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogc2V0dGVycyxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNShSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciwge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjUoUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI1KFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIG51bWJlck9mQXVkaW9UYWdzLFxuICAgICAgICAgICAgICBjb21wb25lbnQ6IGNvbXBvc2l0aW9uPy5jb21wb25lbnQgPz8gbnVsbCxcbiAgICAgICAgICAgICAgYXVkaW9MYXRlbmN5SGludCxcbiAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgfSk7XG59O1xuXG4vLyBzcmMvZGVmYXVsdC1jc3MudHNcbnZhciBleHBvcnRzX2RlZmF1bHRfY3NzID0ge307XG5fX2V4cG9ydChleHBvcnRzX2RlZmF1bHRfY3NzLCB7XG4gIG1ha2VEZWZhdWx0UHJldmlld0NTUzogKCkgPT4gbWFrZURlZmF1bHRQcmV2aWV3Q1NTLFxuICBpbmplY3RDU1M6ICgpID0+IGluamVjdENTUyxcbiAgT0JKRUNURklUX0NPTlRBSU5fQ0xBU1NfTkFNRTogKCkgPT4gT0JKRUNURklUX0NPTlRBSU5fQ0xBU1NfTkFNRVxufSk7XG52YXIgaW5qZWN0ZWQgPSB7fTtcbnZhciBpbmplY3RDU1MgPSAoY3NzKSA9PiB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluamVjdGVkW2Nzc10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIGhlYWQucHJlcGVuZChzdHlsZSk7XG4gIGluamVjdGVkW2Nzc10gPSB0cnVlO1xufTtcbnZhciBPQkpFQ1RGSVRfQ09OVEFJTl9DTEFTU19OQU1FID0gXCJfX3JlbW90aW9uX29iamVjdGZpdGNvbnRhaW5cIjtcbnZhciBtYWtlRGVmYXVsdFByZXZpZXdDU1MgPSAoc2NvcGUsIGJhY2tncm91bmRDb2xvcikgPT4ge1xuICBpZiAoIXNjb3BlKSB7XG4gICAgcmV0dXJuIGBcbiAgICAqIHtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgfVxuICAgIGJvZHkge1xuICAgICAgbWFyZ2luOiAwO1xuXHQgICAgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3J9O1xuICAgIH1cbiAgICAuJHtPQkpFQ1RGSVRfQ09OVEFJTl9DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgICBgO1xuICB9XG4gIHJldHVybiBgXG4gICAgJHtzY29wZX0gKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAke3Njb3BlfSAqOi13ZWJraXQtZnVsbC1zY3JlZW4ge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgICR7c2NvcGV9IC4ke09CSkVDVEZJVF9DT05UQUlOX0NMQVNTX05BTUV9IHtcbiAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuICBgO1xufTtcblxuLy8gc3JjL2dldC1wcmV2aWV3LWRvbS1lbGVtZW50LnRzXG52YXIgUkVNT1RJT05fU1RVRElPX0NPTlRBSU5FUl9FTEVNRU5UID0gXCJfX3JlbW90aW9uLXN0dWRpby1jb250YWluZXJcIjtcbnZhciBnZXRQcmV2aWV3RG9tRWxlbWVudCA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCk7XG59O1xuXG4vLyBzcmMvcmVnaXN0ZXItcm9vdC50c1xudmFyIFJvb3QgPSBudWxsO1xudmFyIGxpc3RlbmVycyA9IFtdO1xudmFyIHJlZ2lzdGVyUm9vdCA9IChjb21wKSA9PiB7XG4gIGlmICghY29tcCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIFJlYWN0IGNvbXBvbmVudCB0byByZWdpc3RlclJvb3QoKSwgYnV0ICR7SlNPTi5zdHJpbmdpZnkoY29tcCl9IHdhcyBwYXNzZWQuYCk7XG4gIH1cbiAgaWYgKFJvb3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWdpc3RlclJvb3QoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlwiKTtcbiAgfVxuICBSb290ID0gY29tcDtcbiAgbGlzdGVuZXJzLmZvckVhY2goKGwpID0+IHtcbiAgICBsKGNvbXApO1xuICB9KTtcbn07XG52YXIgZ2V0Um9vdCA9ICgpID0+IHtcbiAgcmV0dXJuIFJvb3Q7XG59O1xudmFyIHdhaXRGb3JSb290ID0gKGZuKSA9PiB7XG4gIGlmIChSb290KSB7XG4gICAgZm4oUm9vdCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIGxpc3RlbmVycy5wdXNoKGZuKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKChsKSA9PiBsICE9PSBmbik7XG4gIH07XG59O1xuXG4vLyBzcmMvUmVtb3Rpb25Sb290LnRzeFxuaW1wb3J0IHtcbiAgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDE4LFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0OCxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjYsXG4gIHVzZVJlZiBhcyB1c2VSZWYxNSxcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxN1xufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3VzZS1tZWRpYS1lbmFibGVkLnRzeFxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCBhcyBjcmVhdGVDb250ZXh0MTgsIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMwLCB1c2VNZW1vIGFzIHVzZU1lbW8yNSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDI2IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgTWVkaWFFbmFibGVkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQxOChudWxsKTtcbnZhciB1c2VWaWRlb0VuYWJsZWQgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MzAoTWVkaWFFbmFibGVkQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHJldHVybiB3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkO1xuICB9XG4gIGlmIChjb250ZXh0LnZpZGVvRW5hYmxlZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkO1xuICB9XG4gIHJldHVybiBjb250ZXh0LnZpZGVvRW5hYmxlZDtcbn07XG52YXIgdXNlQXVkaW9FbmFibGVkID0gKCkgPT4ge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDMwKE1lZGlhRW5hYmxlZENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICByZXR1cm4gd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZDtcbiAgfVxuICBpZiAoY29udGV4dC5hdWRpb0VuYWJsZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZDtcbiAgfVxuICByZXR1cm4gY29udGV4dC5hdWRpb0VuYWJsZWQ7XG59O1xudmFyIE1lZGlhRW5hYmxlZFByb3ZpZGVyID0gKHtcbiAgY2hpbGRyZW4sXG4gIHZpZGVvRW5hYmxlZCxcbiAgYXVkaW9FbmFibGVkXG59KSA9PiB7XG4gIGNvbnN0IHZhbHVlID0gdXNlTWVtbzI1KCgpID0+ICh7IHZpZGVvRW5hYmxlZCwgYXVkaW9FbmFibGVkIH0pLCBbdmlkZW9FbmFibGVkLCBhdWRpb0VuYWJsZWRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNihNZWRpYUVuYWJsZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWUsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xuXG4vLyBzcmMvUmVtb3Rpb25Sb290LnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDI3IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUmVtb3Rpb25Sb290ID0gKHtcbiAgY2hpbGRyZW4sXG4gIG51bWJlck9mQXVkaW9UYWdzLFxuICBsb2dMZXZlbCxcbiAgb25seVJlbmRlckNvbXBvc2l0aW9uLFxuICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSxcbiAgYXVkaW9MYXRlbmN5SGludCxcbiAgdmlkZW9FbmFibGVkLFxuICBhdWRpb0VuYWJsZWRcbn0pID0+IHtcbiAgY29uc3QgW3JlbW90aW9uUm9vdElkXSA9IHVzZVN0YXRlMTcoKCkgPT4gU3RyaW5nKHJhbmRvbShudWxsKSkpO1xuICBjb25zdCBbZnJhbWUsIHNldEZyYW1lXSA9IHVzZVN0YXRlMTcoKCkgPT4gZ2V0SW5pdGlhbEZyYW1lU3RhdGUoKSk7XG4gIGNvbnN0IFtwbGF5aW5nLCBzZXRQbGF5aW5nXSA9IHVzZVN0YXRlMTcoZmFsc2UpO1xuICBjb25zdCBpbXBlcmF0aXZlUGxheWluZyA9IHVzZVJlZjE1KGZhbHNlKTtcbiAgY29uc3QgW2Zhc3RSZWZyZXNoZXMsIHNldEZhc3RSZWZyZXNoZXNdID0gdXNlU3RhdGUxNygwKTtcbiAgY29uc3QgW21hbnVhbFJlZnJlc2hlcywgc2V0TWFudWFsUmVmcmVzaGVzXSA9IHVzZVN0YXRlMTcoMCk7XG4gIGNvbnN0IFtwbGF5YmFja1JhdGUsIHNldFBsYXliYWNrUmF0ZV0gPSB1c2VTdGF0ZTE3KDEpO1xuICBjb25zdCBhdWRpb0FuZFZpZGVvVGFncyA9IHVzZVJlZjE1KFtdKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHVzZUxheW91dEVmZmVjdDgoKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW90aW9uX3NldEZyYW1lID0gKGYsIGNvbXBvc2l0aW9uLCBhdHRlbXB0KSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdGlvbl9hdHRlbXB0ID0gYXR0ZW1wdDtcbiAgICAgICAgY29uc3QgaWQgPSBkZWxheVJlbmRlcjIoYFNldHRpbmcgdGhlIGN1cnJlbnQgZnJhbWUgdG8gJHtmfWApO1xuICAgICAgICBsZXQgYXN5bmNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBzZXRGcmFtZSgocykgPT4ge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHNbY29tcG9zaXRpb25dID8/IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWU7XG4gICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSA9PT0gZikge1xuICAgICAgICAgICAgYXN5bmNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgIFtjb21wb3NpdGlvbl06IGZcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGFzeW5jVXBkYXRlKSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNvbnRpbnVlUmVuZGVyMihpZCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlUmVuZGVyMihpZCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgPSBmYWxzZTtcbiAgICB9LCBbY29udGludWVSZW5kZXIyLCBkZWxheVJlbmRlcjJdKTtcbiAgfVxuICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyYW1lLFxuICAgICAgcGxheWluZyxcbiAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgcm9vdElkOiByZW1vdGlvblJvb3RJZCxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHNldFBsYXliYWNrUmF0ZSxcbiAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzXG4gICAgfTtcbiAgfSwgW2ZyYW1lLCBwbGF5YmFja1JhdGUsIHBsYXlpbmcsIHJlbW90aW9uUm9vdElkXSk7XG4gIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbzI2KCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0RnJhbWUsXG4gICAgICBzZXRQbGF5aW5nXG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBub25jZUNvbnRleHQgPSB1c2VNZW1vMjYoKCkgPT4ge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0Tm9uY2U6ICgpID0+IGNvdW50ZXIrKyxcbiAgICAgIGZhc3RSZWZyZXNoZXMsXG4gICAgICBtYW51YWxSZWZyZXNoZXNcbiAgICB9O1xuICB9LCBbZmFzdFJlZnJlc2hlcywgbWFudWFsUmVmcmVzaGVzXSk7XG4gIGNvbnN0IHNldE5vbmNlQ29udGV4dCA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluY3JlYXNlTWFudWFsUmVmcmVzaGVzOiAoKSA9PiB7XG4gICAgICAgIHNldE1hbnVhbFJlZnJlc2hlcygoaSkgPT4gaSArIDEpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0MTgoKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX21vZHVsZV9fICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX193ZWJwYWNrX21vZHVsZV9fLmhvdCkge1xuICAgICAgICBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmFkZFN0YXR1c0hhbmRsZXIoKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgICAgICBzZXRGYXN0UmVmcmVzaGVzKChpKSA9PiBpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgbG9nZ2luZyA9IHVzZU1lbW8yNigoKSA9PiB7XG4gICAgcmV0dXJuIHsgbG9nTGV2ZWwsIG1vdW50VGltZTogRGF0ZS5ub3coKSB9O1xuICB9LCBbbG9nTGV2ZWxdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhMb2dMZXZlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbG9nZ2luZyxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KE5vbmNlQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IG5vbmNlQ29udGV4dCxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoU2V0Tm9uY2VDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBzZXROb25jZUNvbnRleHQsXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoVGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgdmFsdWU6IHRpbWVsaW5lQ29udGV4dFZhbHVlLFxuICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogc2V0VGltZWxpbmVDb250ZXh0VmFsdWUsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KE1lZGlhRW5hYmxlZFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIHZpZGVvRW5hYmxlZCxcbiAgICAgICAgICAgICAgYXVkaW9FbmFibGVkLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KEVkaXRvclByb3BzUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDI3KFByZWZldGNoUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICAgICAgICAgICAgICAgIG9ubHlSZW5kZXJDb21wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGF1ZGlvTGF0ZW5jeUhpbnQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MjcoRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyNyhCdWZmZXJpbmdQcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9KTtcbn07XG5cbi8vIHNyYy9zZXR1cC1lbnYtdmFyaWFibGVzLnRzXG52YXIgZ2V0RW52VmFyaWFibGVzID0gKCkgPT4ge1xuICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUmVuZGVyaW5nKSB7XG4gICAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25fZW52VmFyaWFibGVzO1xuICAgIGlmICghcGFyYW0pIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uSlNPTi5wYXJzZShwYXJhbSksIE5PREVfRU5WOiBcInByb2R1Y3Rpb25cIiB9O1xuICB9XG4gIGlmIChmYWxzZSkge31cbiAgcmV0dXJuIHtcbiAgICBOT0RFX0VOVjogXCJwcm9kdWN0aW9uXCJcbiAgfTtcbn07XG52YXIgc2V0dXBFbnZWYXJpYWJsZXMgPSAoKSA9PiB7XG4gIGNvbnN0IGVudiA9IGdldEVudlZhcmlhYmxlcygpO1xuICBpZiAoIXdpbmRvdy5wcm9jZXNzKSB7XG4gICAgd2luZG93LnByb2Nlc3MgPSB7fTtcbiAgfVxuICBpZiAoIXdpbmRvdy5wcm9jZXNzLmVudikge1xuICAgIHdpbmRvdy5wcm9jZXNzLmVudiA9IHt9O1xuICB9XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgd2luZG93LnByb2Nlc3MuZW52W2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvdXNlLWN1cnJlbnQtc2NhbGUudHNcbmltcG9ydCBSZWFjdDI2LCB7IGNyZWF0ZUNvbnRleHQgYXMgY3JlYXRlQ29udGV4dDE5IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgQ3VycmVudFNjYWxlQ29udGV4dCA9IFJlYWN0MjYuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBQcmV2aWV3U2l6ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0MTkoe1xuICBzZXRTaXplOiAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LFxuICBzaXplOiB7IHNpemU6IFwiYXV0b1wiLCB0cmFuc2xhdGlvbjogeyB4OiAwLCB5OiAwIH0gfVxufSk7XG52YXIgY2FsY3VsYXRlU2NhbGUgPSAoe1xuICBjYW52YXNTaXplLFxuICBjb21wb3NpdGlvbkhlaWdodCxcbiAgY29tcG9zaXRpb25XaWR0aCxcbiAgcHJldmlld1NpemVcbn0pID0+IHtcbiAgY29uc3QgaGVpZ2h0UmF0aW8gPSBjYW52YXNTaXplLmhlaWdodCAvIGNvbXBvc2l0aW9uSGVpZ2h0O1xuICBjb25zdCB3aWR0aFJhdGlvID0gY2FudmFzU2l6ZS53aWR0aCAvIGNvbXBvc2l0aW9uV2lkdGg7XG4gIGNvbnN0IHJhdGlvID0gTWF0aC5taW4oaGVpZ2h0UmF0aW8sIHdpZHRoUmF0aW8pO1xuICBpZiAocHJldmlld1NpemUgPT09IFwiYXV0b1wiKSB7XG4gICAgaWYgKHJhdGlvID09PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG4gIHJldHVybiBOdW1iZXIocHJldmlld1NpemUpO1xufTtcbnZhciB1c2VDdXJyZW50U2NhbGUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBoYXNDb250ZXh0ID0gUmVhY3QyNi51c2VDb250ZXh0KEN1cnJlbnRTY2FsZUNvbnRleHQpO1xuICBjb25zdCB6b29tQ29udGV4dCA9IFJlYWN0MjYudXNlQ29udGV4dChQcmV2aWV3U2l6ZUNvbnRleHQpO1xuICBjb25zdCBjb25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCBlbnYgPSB1c2VSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gIGlmIChoYXNDb250ZXh0ID09PSBudWxsIHx8IGNvbmZpZyA9PT0gbnVsbCB8fCB6b29tQ29udGV4dCA9PT0gbnVsbCkge1xuICAgIGlmIChvcHRpb25zPy5kb250VGhyb3dJZk91dHNpZGVPZlJlbW90aW9uKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKGVudi5pc1JlbmRlcmluZykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICBcInVzZUN1cnJlbnRTY2FsZSgpIHdhcyBjYWxsZWQgb3V0c2lkZSBvZiBhIFJlbW90aW9uIGNvbnRleHQuXCIsXG4gICAgICBcIlRoaXMgaG9vayBjYW4gb25seSBiZSBjYWxsZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBiZWluZyByZW5kZXJlZCBieSBSZW1vdGlvbi5cIixcbiAgICAgIFwiSWYgeW91IHdhbnQgdG8gdGhpcyBob29rIHRvIHJldHVybiAxIG91dHNpZGUgb2YgUmVtb3Rpb24sIHBhc3Mge2RvbnRUaHJvd0lmT3V0c2lkZU9mUmVtb3Rpb246IHRydWV9IGFzIGFuIG9wdGlvbi5cIixcbiAgICAgIFwiSWYgeW91IHRoaW5rIHlvdSBjYWxsZWQgdGhpcyBob29rIGluIGEgUmVtb3Rpb24gY29tcG9uZW50LCBtYWtlIHN1cmUgYWxsIHZlcnNpb25zIG9mIFJlbW90aW9uIGFyZSBhbGlnbmVkLlwiXG4gICAgXS5qb2luKGBcbmApKTtcbiAgfVxuICBpZiAoaGFzQ29udGV4dC50eXBlID09PSBcInNjYWxlXCIpIHtcbiAgICByZXR1cm4gaGFzQ29udGV4dC5zY2FsZTtcbiAgfVxuICByZXR1cm4gY2FsY3VsYXRlU2NhbGUoe1xuICAgIGNhbnZhc1NpemU6IGhhc0NvbnRleHQuY2FudmFzU2l6ZSxcbiAgICBjb21wb3NpdGlvbkhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICBjb21wb3NpdGlvbldpZHRoOiBjb25maWcud2lkdGgsXG4gICAgcHJldmlld1NpemU6IHpvb21Db250ZXh0LnNpemUuc2l6ZVxuICB9KTtcbn07XG5cbi8vIHNyYy92aWRlby9PZmZ0aHJlYWRWaWRlby50c3hcbmltcG9ydCB7IHVzZUNhbGxiYWNrIGFzIHVzZUNhbGxiYWNrMTYgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxNSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MzEsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QxOSxcbiAgdXNlTGF5b3V0RWZmZWN0IGFzIHVzZUxheW91dEVmZmVjdDksXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzI3LFxuICB1c2VTdGF0ZSBhcyB1c2VTdGF0ZTE4XG59IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdmlkZW8vb2ZmdGhyZWFkLXZpZGVvLXNvdXJjZS50c1xudmFyIGdldE9mZnRocmVhZFZpZGVvU291cmNlID0gKHtcbiAgc3JjLFxuICB0cmFuc3BhcmVudCxcbiAgY3VycmVudFRpbWUsXG4gIHRvbmVNYXBwZWRcbn0pID0+IHtcbiAgcmV0dXJuIGBodHRwOi8vbG9jYWxob3N0OiR7d2luZG93LnJlbW90aW9uX3Byb3h5UG9ydH0vcHJveHk/c3JjPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldEFic29sdXRlU3JjKHNyYykpfSZ0aW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KE1hdGgubWF4KDAsIGN1cnJlbnRUaW1lKSl9JnRyYW5zcGFyZW50PSR7U3RyaW5nKHRyYW5zcGFyZW50KX0mdG9uZU1hcHBlZD0ke1N0cmluZyh0b25lTWFwcGVkKX1gO1xufTtcblxuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDI4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgT2ZmdGhyZWFkVmlkZW9Gb3JSZW5kZXJpbmcgPSAoe1xuICBvbkVycm9yLFxuICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc3JjLFxuICBtdXRlZCxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICB0cmFuc3BhcmVudCxcbiAgdG9uZU1hcHBlZCxcbiAgdG9uZUZyZXF1ZW5jeSxcbiAgbmFtZSxcbiAgbG9vcFZvbHVtZUN1cnZlQmVoYXZpb3IsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIG9uVmlkZW9GcmFtZSxcbiAgY3Jvc3NPcmlnaW4sXG4gIGF1ZGlvU3RyZWFtSW5kZXgsXG4gIC4uLnByb3BzMlxufSkgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yKTtcbiAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0MzEoU2VxdWVuY2VDb250ZXh0KTtcbiAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgY29uc3QgeyByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQgfSA9IHVzZUNvbnRleHQzMShSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBpZiAoIXNyYykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBgc3JjYCB3YXMgcGFzc2VkIHRvIDxPZmZ0aHJlYWRWaWRlbz4uXCIpO1xuICB9XG4gIGNvbnN0IGlkID0gdXNlTWVtbzI3KCgpID0+IGBvZmZ0aHJlYWR2aWRlby0ke3JhbmRvbShzcmMpfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHNyYyxcbiAgICBzZXF1ZW5jZUNvbnRleHQ/LmN1bXVsYXRlZEZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgc2VxdWVuY2VDb250ZXh0Py5kdXJhdGlvbkluRnJhbWVzXG4gIF0pO1xuICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmlkZW8gY29uZmlnIGZvdW5kXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgZnJhbWU6IHZvbHVtZVByb3BzRnJhbWUsXG4gICAgbWVkaWFWb2x1bWU6IDFcbiAgfSk7XG4gIHdhcm5BYm91dFRvb0hpZ2hWb2x1bWUodm9sdW1lKTtcbiAgdXNlRWZmZWN0MTkoKCkgPT4ge1xuICAgIGlmICghc3JjKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzcmMgcGFzc2VkXCIpO1xuICAgIH1cbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG11dGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2b2x1bWUgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMoc3JjKSxcbiAgICAgIGlkLFxuICAgICAgZnJhbWU6IGFic29sdXRlRnJhbWUsXG4gICAgICB2b2x1bWUsXG4gICAgICBtZWRpYUZyYW1lOiBmcmFtZSxcbiAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgICBhdWRpb1N0YXJ0RnJhbWU6IE1hdGgubWF4KDAsIC0oc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20gPz8gMCkpLFxuICAgICAgYXVkaW9TdHJlYW1JbmRleFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgbXV0ZWQsXG4gICAgc3JjLFxuICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgaWQsXG4gICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgIHZvbHVtZSxcbiAgICBmcmFtZSxcbiAgICBhYnNvbHV0ZUZyYW1lLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIGF1ZGlvU3RyZWFtSW5kZXhcbiAgXSk7XG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlTWVtbzI3KCgpID0+IHtcbiAgICByZXR1cm4gZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQoe1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdFxuICAgIH0pIC8gdmlkZW9Db25maWcuZnBzO1xuICB9LCBbZnJhbWUsIG1lZGlhU3RhcnRzQXQsIHBsYXliYWNrUmF0ZSwgdmlkZW9Db25maWcuZnBzXSk7XG4gIGNvbnN0IGFjdHVhbFNyYyA9IHVzZU1lbW8yNygoKSA9PiB7XG4gICAgcmV0dXJuIGdldE9mZnRocmVhZFZpZGVvU291cmNlKHtcbiAgICAgIHNyYyxcbiAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgdHJhbnNwYXJlbnQsXG4gICAgICB0b25lTWFwcGVkXG4gICAgfSk7XG4gIH0sIFt0b25lTWFwcGVkLCBjdXJyZW50VGltZSwgc3JjLCB0cmFuc3BhcmVudF0pO1xuICBjb25zdCBbaW1hZ2VTcmMsIHNldEltYWdlU3JjXSA9IHVzZVN0YXRlMTgobnVsbCk7XG4gIGNvbnN0IHsgZGVsYXlSZW5kZXI6IGRlbGF5UmVuZGVyMiwgY29udGludWVSZW5kZXI6IGNvbnRpbnVlUmVuZGVyMiB9ID0gdXNlRGVsYXlSZW5kZXIoKTtcbiAgdXNlTGF5b3V0RWZmZWN0OSgoKSA9PiB7XG4gICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fdmlkZW9FbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNsZWFudXAgPSBbXTtcbiAgICBzZXRJbWFnZVNyYyhudWxsKTtcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcjtcbiAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcjIoYEZldGNoaW5nICR7YWN0dWFsU3JjfSBmcm9tIHNlcnZlcmAsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGNvbnN0IGV4ZWN1dGUgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChhY3R1YWxTcmMsIHtcbiAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIGNhY2hlOiBcIm5vLXN0b3JlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNTAwKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgIGlmIChqc29uLmVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRVcEVycm9yTWVzc2FnZSA9IGpzb24uZXJyb3IucmVwbGFjZSgvXkVycm9yOiAvLCBcIlwiKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNsZWFuZWRVcEVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJldHVybmVkIHN0YXR1cyAke3Jlcy5zdGF0dXN9IHdoaWxlIGZldGNoaW5nICR7YWN0dWFsU3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXMuYmxvYigpO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBjbGVhbnVwLnB1c2goKCkgPT4gVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpKTtcbiAgICAgICAgc2V0SW1hZ2VTcmMoe1xuICAgICAgICAgIHNyYzogdXJsLFxuICAgICAgICAgIGhhbmRsZTogbmV3SGFuZGxlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcyhcImFib3J0ZWRcIikpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZVJlbmRlcjIobmV3SGFuZGxlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiRmFpbGVkIHRvIGZldGNoXCIpKSB7XG4gICAgICAgICAgZXJyID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggJHthY3R1YWxTcmN9LiBUaGlzIGNvdWxkIGJlIGNhdXNlZCBieSBDaHJvbWUgcmVqZWN0aW5nIHRoZSByZXF1ZXN0IGJlY2F1c2UgdGhlIGRpc2sgc3BhY2UgaXMgbG93LiBDb25zaWRlciBpbmNyZWFzaW5nIHRoZSBkaXNrIHNpemUgb2YgeW91ciBlbnZpcm9ubWVudC5gLCB7IGNhdXNlOiBlcnIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuY2VsUmVuZGVyKGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGV4ZWN1dGUoKTtcbiAgICBjbGVhbnVwLnB1c2goKCkgPT4ge1xuICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwLmZvckVhY2goKGMyKSA9PiBjMigpKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYWN0dWFsU3JjLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBvbkVycm9yLFxuICAgIGNvbnRpbnVlUmVuZGVyMixcbiAgICBkZWxheVJlbmRlcjJcbiAgXSk7XG4gIGNvbnN0IG9uRXJyID0gdXNlQ2FsbGJhY2sxNSgoKSA9PiB7XG4gICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgIG9uRXJyb3I/LihuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBpbWFnZSB3aXRoIHNyYyBcIiArIGltYWdlU3JjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbmNlbFJlbmRlcihcIkZhaWxlZCB0byBsb2FkIGltYWdlIHdpdGggc3JjIFwiICsgaW1hZ2VTcmMpO1xuICAgIH1cbiAgfSwgW2ltYWdlU3JjLCBvbkVycm9yXSk7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IHVzZU1lbW8yNygoKSA9PiB7XG4gICAgcmV0dXJuIFtPQkpFQ1RGSVRfQ09OVEFJTl9DTEFTU19OQU1FLCBwcm9wczIuY2xhc3NOYW1lXS5maWx0ZXIodHJ1dGh5KS5qb2luKFwiIFwiKTtcbiAgfSwgW3Byb3BzMi5jbGFzc05hbWVdKTtcbiAgY29uc3Qgb25JbWFnZUZyYW1lID0gdXNlQ2FsbGJhY2sxNSgoaW1nKSA9PiB7XG4gICAgaWYgKG9uVmlkZW9GcmFtZSkge1xuICAgICAgb25WaWRlb0ZyYW1lKGltZyk7XG4gICAgfVxuICB9LCBbb25WaWRlb0ZyYW1lXSk7XG4gIGlmICghaW1hZ2VTcmMgfHwgIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb250aW51ZVJlbmRlcjIoaW1hZ2VTcmMuaGFuZGxlKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOChJbWcsIHtcbiAgICBzcmM6IGltYWdlU3JjLnNyYyxcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgb25JbWFnZUZyYW1lLFxuICAgIC4uLnByb3BzMixcbiAgICBvbkVycm9yOiBvbkVycixcbiAgICBjbGFzc05hbWVcbiAgfSk7XG59O1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JQcmV2aWV3LnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmOSxcbiAgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MzIsXG4gIHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMSxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSBhcyB1c2VJbXBlcmF0aXZlSGFuZGxlOSxcbiAgdXNlTWVtbyBhcyB1c2VNZW1vMjgsXG4gIHVzZVJlZiBhcyB1c2VSZWYxNixcbiAgdXNlU3RhdGUgYXMgdXNlU3RhdGUxOVxufSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL2VtaXQtdmlkZW8tZnJhbWUudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QyMCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZUVtaXRWaWRlb0ZyYW1lID0gKHtcbiAgcmVmLFxuICBvblZpZGVvRnJhbWVcbn0pID0+IHtcbiAgdXNlRWZmZWN0MjAoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gcmVmO1xuICAgIGlmICghY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW9uVmlkZW9GcmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgaGFuZGxlID0gMDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25WaWRlb0ZyYW1lKHJlZi5jdXJyZW50KTtcbiAgICAgIGhhbmRsZSA9IHJlZi5jdXJyZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIH07XG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY3VycmVudC5jYW5jZWxWaWRlb0ZyYW1lQ2FsbGJhY2soaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbb25WaWRlb0ZyYW1lLCByZWZdKTtcbn07XG5cbi8vIHNyYy92aWRlby9WaWRlb0ZvclByZXZpZXcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MjkgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvckRldmVsb3BtZW50UmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzMiwgcmVmKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0MzIoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2hhcmVkQXVkaW9Db250ZXh0IG5vdCBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZjE2KG51bGwpO1xuICBjb25zdCBzaGFyZWRTb3VyY2UgPSB1c2VNZW1vMjgoKCkgPT4ge1xuICAgIGlmICghY29udGV4dC5hdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbWFrZVNoYXJlZEVsZW1lbnRTb3VyY2VOb2RlKHtcbiAgICAgIGF1ZGlvQ29udGV4dDogY29udGV4dC5hdWRpb0NvbnRleHQsXG4gICAgICByZWY6IHZpZGVvUmVmXG4gICAgfSk7XG4gIH0sIFtjb250ZXh0LmF1ZGlvQ29udGV4dF0pO1xuICBjb25zdCB7XG4gICAgdm9sdW1lLFxuICAgIG11dGVkLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yLFxuICAgIHNyYyxcbiAgICBvbkR1cmF0aW9uLFxuICAgIGFjY2VwdGFibGVUaW1lU2hpZnQsXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICB0b25lRnJlcXVlbmN5LFxuICAgIG5hbWUsXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc3R5bGUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICAgIG9uRXJyb3IsXG4gICAgb25BdXRvUGxheUVycm9yLFxuICAgIG9uVmlkZW9GcmFtZSxcbiAgICBjcm9zc09yaWdpbixcbiAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgIHVzZVdlYkF1ZGlvQXBpLFxuICAgIGF1ZGlvU3RyZWFtSW5kZXgsXG4gICAgLi4ubmF0aXZlUHJvcHNcbiAgfSA9IHByb3BzMjtcbiAgY29uc3QgX3Byb3BzVmFsaWQgPSB0cnVlO1xuICBpZiAoIV9wcm9wc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZWNoZWNrIGVycm9yXCIpO1xuICB9XG4gIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcChsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiKTtcbiAgY29uc3QgeyBmcHMsIGR1cmF0aW9uSW5GcmFtZXMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHBhcmVudFNlcXVlbmNlID0gdXNlQ29udGV4dDMyKFNlcXVlbmNlQ29udGV4dCk7XG4gIGNvbnN0IHsgaGlkZGVuIH0gPSB1c2VDb250ZXh0MzIoU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCk7XG4gIGNvbnN0IGxvZ0xldmVsID0gdXNlTG9nTGV2ZWwoKTtcbiAgY29uc3QgbW91bnRUaW1lID0gdXNlTW91bnRUaW1lKCk7XG4gIGNvbnN0IFt0aW1lbGluZUlkXSA9IHVzZVN0YXRlMTkoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgY29uc3QgaXNTZXF1ZW5jZUhpZGRlbiA9IGhpZGRlblt0aW1lbGluZUlkXSA/PyBmYWxzZTtcbiAgaWYgKHR5cGVvZiBhY2NlcHRhYmxlVGltZVNoaWZ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWNjZXB0YWJsZVRpbWVTaGlmdCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgY29uc3QgdXNlclByZWZlcnJlZFZvbHVtZSA9IGV2YWx1YXRlVm9sdW1lKHtcbiAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgIHZvbHVtZSxcbiAgICBtZWRpYVZvbHVtZVxuICB9KTtcbiAgd2FybkFib3V0VG9vSGlnaFZvbHVtZSh1c2VyUHJlZmVycmVkVm9sdW1lKTtcbiAgdXNlTWVkaWFJblRpbWVsaW5lKHtcbiAgICB2b2x1bWUsXG4gICAgbWVkaWFWb2x1bWUsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgc3JjLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIGRpc3BsYXlOYW1lOiBuYW1lID8/IG51bGwsXG4gICAgaWQ6IHRpbWVsaW5lSWQsXG4gICAgc3RhY2s6IF9yZW1vdGlvbkludGVybmFsU3RhY2ssXG4gICAgc2hvd0luVGltZWxpbmUsXG4gICAgcHJlbW91bnREaXNwbGF5OiBwYXJlbnRTZXF1ZW5jZT8ucHJlbW91bnREaXNwbGF5ID8/IG51bGwsXG4gICAgcG9zdG1vdW50RGlzcGxheTogcGFyZW50U2VxdWVuY2U/LnBvc3Rtb3VudERpc3BsYXkgPz8gbnVsbCxcbiAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkXG4gIH0pO1xuICB1c2VNZWRpYVBsYXliYWNrKHtcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgc3JjLFxuICAgIG1lZGlhVHlwZTogXCJ2aWRlb1wiLFxuICAgIHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyA/PyBudWxsLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4ocGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nKSxcbiAgICBpc1Bvc3Rtb3VudGluZzogQm9vbGVhbihwYXJlbnRTZXF1ZW5jZT8ucG9zdG1vdW50aW5nKSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbFxuICB9KTtcbiAgdXNlTWVkaWFUYWcoe1xuICAgIGlkOiB0aW1lbGluZUlkLFxuICAgIGlzUG9zdG1vdW50aW5nOiBCb29sZWFuKHBhcmVudFNlcXVlbmNlPy5wb3N0bW91bnRpbmcpLFxuICAgIGlzUHJlbW91bnRpbmc6IEJvb2xlYW4ocGFyZW50U2VxdWVuY2U/LnByZW1vdW50aW5nKSxcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgbWVkaWFUeXBlOiBcInZpZGVvXCIsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gbnVsbFxuICB9KTtcbiAgdXNlVm9sdW1lKHtcbiAgICBsb2dMZXZlbCxcbiAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgdm9sdW1lOiB1c2VyUHJlZmVycmVkVm9sdW1lLFxuICAgIHNvdXJjZTogc2hhcmVkU291cmNlLFxuICAgIHNob3VsZFVzZVdlYkF1ZGlvQXBpOiB1c2VXZWJBdWRpb0FwaSA/PyBmYWxzZVxuICB9KTtcbiAgY29uc3QgYWN0dWFsRnJvbSA9IHBhcmVudFNlcXVlbmNlID8gcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tIDogMDtcbiAgY29uc3QgZHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZSA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMsIGR1cmF0aW9uSW5GcmFtZXMpIDogZHVyYXRpb25JbkZyYW1lcztcbiAgY29uc3QgcHJlbG9hZGVkU3JjID0gdXNlUHJlbG9hZChzcmMpO1xuICBjb25zdCBhY3R1YWxTcmMgPSB1c2VBcHBlbmRWaWRlb0ZyYWdtZW50KHtcbiAgICBhY3R1YWxTcmM6IHByZWxvYWRlZFNyYyxcbiAgICBhY3R1YWxGcm9tLFxuICAgIGR1cmF0aW9uLFxuICAgIGZwc1xuICB9KTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTkocmVmLCAoKSA9PiB7XG4gICAgcmV0dXJuIHZpZGVvUmVmLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbiAgdXNlU3RhdGUxOSgoKSA9PiBwbGF5YmFja0xvZ2dpbmcoe1xuICAgIGxvZ0xldmVsLFxuICAgIG1lc3NhZ2U6IGBNb3VudGluZyB2aWRlbyB3aXRoIHNvdXJjZSA9ICR7YWN0dWFsU3JjfSwgdj0ke1ZFUlNJT059LCB1c2VyIGFnZW50PSR7dHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIiA/IFwic2VydmVyXCIgOiBuYXZpZ2F0b3IudXNlckFnZW50fWAsXG4gICAgdGFnOiBcInZpZGVvXCIsXG4gICAgbW91bnRUaW1lXG4gIH0pKTtcbiAgdXNlRWZmZWN0MjEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVycm9ySGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGlmIChjdXJyZW50LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBDb2RlICR7Y3VycmVudC5lcnJvci5jb2RlfTogJHtjdXJyZW50LmVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvICR7c3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3NyY31gKTtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yIHdoaWxlIHBsYXlpbmcgdGhlIHZpZGVvXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgfTtcbiAgfSwgW29uRXJyb3IsIHNyY10pO1xuICBjb25zdCBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrID0gdXNlUmVmMTYob25EdXJhdGlvbik7XG4gIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudCA9IG9uRHVyYXRpb247XG4gIHVzZUVtaXRWaWRlb0ZyYW1lKHsgcmVmOiB2aWRlb1JlZiwgb25WaWRlb0ZyYW1lIH0pO1xuICB1c2VFZmZlY3QyMSgoKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgIGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudD8uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQ/LihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgIH07XG4gIH0sIFtzcmNdKTtcbiAgdXNlRWZmZWN0MjEoKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc0lvc1NhZmFyaSgpKSB7XG4gICAgICBjdXJyZW50LnByZWxvYWQgPSBcIm1ldGFkYXRhXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQucHJlbG9hZCA9IFwiYXV0b1wiO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBhY3R1YWxTdHlsZSA9IHVzZU1lbW8yOCgoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgb3BhY2l0eTogaXNTZXF1ZW5jZUhpZGRlbiA/IDAgOiBzdHlsZT8ub3BhY2l0eSA/PyAxXG4gICAgfTtcbiAgfSwgW2lzU2VxdWVuY2VIaWRkZW4sIHN0eWxlXSk7XG4gIGNvbnN0IGNyb3NzT3JpZ2luVmFsdWUgPSBnZXRDcm9zc09yaWdpblZhbHVlKHtcbiAgICBjcm9zc09yaWdpbixcbiAgICByZXF1ZXN0c1ZpZGVvRnJhbWU6IEJvb2xlYW4ob25WaWRlb0ZyYW1lKVxuICB9KTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyOShcInZpZGVvXCIsIHtcbiAgICByZWY6IHZpZGVvUmVmLFxuICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkIHx8IGlzU2VxdWVuY2VIaWRkZW4gfHwgdXNlclByZWZlcnJlZFZvbHVtZSA8PSAwLFxuICAgIHBsYXlzSW5saW5lOiB0cnVlLFxuICAgIHNyYzogYWN0dWFsU3JjLFxuICAgIGxvb3A6IF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZCxcbiAgICBzdHlsZTogYWN0dWFsU3R5bGUsXG4gICAgZGlzYWJsZVJlbW90ZVBsYXliYWNrOiB0cnVlLFxuICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpblZhbHVlLFxuICAgIC4uLm5hdGl2ZVByb3BzXG4gIH0pO1xufTtcbnZhciBWaWRlb0ZvclByZXZpZXcgPSBmb3J3YXJkUmVmOShWaWRlb0ZvckRldmVsb3BtZW50UmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLy8gc3JjL3ZpZGVvL09mZnRocmVhZFZpZGVvLnRzeFxuaW1wb3J0IHsganN4IGFzIGpzeDMwIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSW5uZXJPZmZ0aHJlYWRWaWRlbyA9IChwcm9wczIpID0+IHtcbiAgY29uc3Qge1xuICAgIHN0YXJ0RnJvbSxcbiAgICBlbmRBdCxcbiAgICB0cmltQmVmb3JlLFxuICAgIHRyaW1BZnRlcixcbiAgICBuYW1lLFxuICAgIHBhdXNlV2hlbkJ1ZmZlcmluZyxcbiAgICBzdGFjayxcbiAgICBzaG93SW5UaW1lbGluZSxcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXNlUmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNigoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9LCBbXSk7XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8T2ZmdGhyZWFkVmlkZW8+XFxgIHRhZyByZXF1aXJlcyBhIHN0cmluZyBmb3IgXFxgc3JjXFxgLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkocHJvcHMyLnNyYyl9IGluc3RlYWQuYCk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVRyaW1Qcm9wcyh7IHN0YXJ0RnJvbSwgZW5kQXQsIHRyaW1CZWZvcmUsIHRyaW1BZnRlciB9KTtcbiAgY29uc3QgeyB0cmltQmVmb3JlVmFsdWUsIHRyaW1BZnRlclZhbHVlIH0gPSByZXNvbHZlVHJpbVByb3BzKHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXJcbiAgfSk7XG4gIGlmICh0eXBlb2YgdHJpbUJlZm9yZVZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmltQWZ0ZXJWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzAoU2VxdWVuY2UsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBmcm9tOiAwIC0gKHRyaW1CZWZvcmVWYWx1ZSA/PyAwKSxcbiAgICAgIHNob3dJblRpbWVsaW5lOiBmYWxzZSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IHRyaW1BZnRlclZhbHVlLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzAoSW5uZXJPZmZ0aHJlYWRWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgdHJpbUFmdGVyOiB1bmRlZmluZWQsXG4gICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICAgIHRyaW1CZWZvcmU6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhY2s6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnRGcm9tOiB1bmRlZmluZWQsXG4gICAgICAgIGVuZEF0OiB1bmRlZmluZWRcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgdmFsaWRhdGVNZWRpYVByb3BzKHByb3BzMiwgXCJWaWRlb1wiKTtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMChPZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZywge1xuICAgICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgdHJpbUFmdGVyOiB1bmRlZmluZWQsXG4gICAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgICBzaG93SW5UaW1lbGluZSxcbiAgICAgIHRyaW1CZWZvcmU6IHVuZGVmaW5lZCxcbiAgICAgIHN0YWNrOiB1bmRlZmluZWQsXG4gICAgICBzdGFydEZyb206IHVuZGVmaW5lZCxcbiAgICAgIGVuZEF0OiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfVxuICBjb25zdCB7XG4gICAgdHJhbnNwYXJlbnQsXG4gICAgdG9uZU1hcHBlZCxcbiAgICBvbkF1dG9QbGF5RXJyb3IsXG4gICAgb25WaWRlb0ZyYW1lLFxuICAgIGNyb3NzT3JpZ2luLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAuLi5wcm9wc0ZvclByZXZpZXdcbiAgfSA9IG90aGVyUHJvcHM7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzAoVmlkZW9Gb3JQcmV2aWV3LCB7XG4gICAgX3JlbW90aW9uSW50ZXJuYWxTdGFjazogc3RhY2sgPz8gbnVsbCxcbiAgICBvbkR1cmF0aW9uLFxuICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IHRydWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgc2hvd0luVGltZWxpbmU6IHNob3dJblRpbWVsaW5lID8/IHRydWUsXG4gICAgb25BdXRvUGxheUVycm9yOiBvbkF1dG9QbGF5RXJyb3IgPz8gdW5kZWZpbmVkLFxuICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgLi4ucHJvcHNGb3JQcmV2aWV3LFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogZmFsc2VcbiAgfSk7XG59O1xudmFyIE9mZnRocmVhZFZpZGVvID0gKHtcbiAgc3JjLFxuICBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLFxuICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gIGF1ZGlvU3RyZWFtSW5kZXgsXG4gIGNsYXNzTmFtZSxcbiAgY3Jvc3NPcmlnaW4sXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIGlkLFxuICBsb29wVm9sdW1lQ3VydmVCZWhhdmlvcixcbiAgbXV0ZWQsXG4gIG5hbWUsXG4gIG9uQXV0b1BsYXlFcnJvcixcbiAgb25FcnJvcixcbiAgb25WaWRlb0ZyYW1lLFxuICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gIHBsYXliYWNrUmF0ZSxcbiAgc2hvd0luVGltZWxpbmUsXG4gIHN0eWxlLFxuICB0b25lRnJlcXVlbmN5LFxuICB0b25lTWFwcGVkLFxuICB0cmFuc3BhcmVudCxcbiAgdHJpbUFmdGVyLFxuICB0cmltQmVmb3JlLFxuICB1c2VXZWJBdWRpb0FwaSxcbiAgdm9sdW1lLFxuICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQsXG4gIGVuZEF0LFxuICBzdGFjayxcbiAgc3RhcnRGcm9tLFxuICBpbWFnZUZvcm1hdFxufSkgPT4ge1xuICBpZiAoaW1hZ2VGb3JtYXQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPE9mZnRocmVhZFZpZGVvPlxcYCB0YWcgZG9lcyBubyBsb25nZXIgYWNjZXB0IFxcYGltYWdlRm9ybWF0XFxgLiBVc2UgdGhlIFxcYHRyYW5zcGFyZW50XFxgIHByb3AgaWYgeW91IHdhbnQgdG8gcmVuZGVyIGEgdHJhbnNwYXJlbnQgdmlkZW8uYCk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMChJbm5lck9mZnRocmVhZFZpZGVvLCB7XG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyxcbiAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/PyB0cnVlLFxuICAgIGF1ZGlvU3RyZWFtSW5kZXg6IGF1ZGlvU3RyZWFtSW5kZXggPz8gMCxcbiAgICBjbGFzc05hbWUsXG4gICAgY3Jvc3NPcmlnaW4sXG4gICAgZGVsYXlSZW5kZXJSZXRyaWVzLFxuICAgIGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzLFxuICAgIGlkLFxuICAgIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yOiBsb29wVm9sdW1lQ3VydmVCZWhhdmlvciA/PyBcInJlcGVhdFwiLFxuICAgIG11dGVkOiBtdXRlZCA/PyBmYWxzZSxcbiAgICBuYW1lLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IG51bGwsXG4gICAgb25FcnJvcixcbiAgICBvblZpZGVvRnJhbWUsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gdHJ1ZSxcbiAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgPz8gMSxcbiAgICBzaG93SW5UaW1lbGluZTogc2hvd0luVGltZWxpbmUgPz8gdHJ1ZSxcbiAgICBzcmMsXG4gICAgc3RhY2ssXG4gICAgc3RhcnRGcm9tLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIGVuZEF0LFxuICAgIHN0eWxlLFxuICAgIHRvbmVNYXBwZWQ6IHRvbmVNYXBwZWQgPz8gdHJ1ZSxcbiAgICB0cmFuc3BhcmVudDogdHJhbnNwYXJlbnQgPz8gZmFsc2UsXG4gICAgdHJpbUFmdGVyLFxuICAgIHRyaW1CZWZvcmUsXG4gICAgdXNlV2ViQXVkaW9BcGk6IHVzZVdlYkF1ZGlvQXBpID8/IGZhbHNlLFxuICAgIHZvbHVtZVxuICB9KTtcbn07XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKE9mZnRocmVhZFZpZGVvKTtcblxuLy8gc3JjL3dhdGNoLXN0YXRpYy1maWxlLnRzXG52YXIgV0FUQ0hfUkVNT1RJT05fU1RBVElDX0ZJTEVTID0gXCJyZW1vdGlvbl9zdGF0aWNGaWxlc0NoYW5nZWRcIjtcbnZhciB3YXRjaFN0YXRpY0ZpbGUgPSAoZmlsZU5hbWUsIGNhbGxiYWNrKSA9PiB7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIndhdGNoU3RhdGljRmlsZSgpIGhhcyBtb3ZlZCBpbnRvIHRoZSBgQHJlbW90aW9uL3N0dWRpb2AgcGFja2FnZS4gVXBkYXRlIHlvdXIgaW1wb3J0cy5cIik7XG4gIH1cbiAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8pIHtcbiAgICBjb25zb2xlLndhcm4oXCJUaGUgd2F0Y2hTdGF0aWNGaWxlKCkgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uXCIpO1xuICAgIHJldHVybiB7IGNhbmNlbDogKCkgPT4ge1xuICAgICAgcmV0dXJuO1xuICAgIH0gfTtcbiAgfVxuICBjb25zdCB3aXRob3V0U3RhdGljQmFzZSA9IGZpbGVOYW1lLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpID8gZmlsZU5hbWUucmVwbGFjZSh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSwgXCJcIikgOiBmaWxlTmFtZTtcbiAgY29uc3Qgd2l0aG91dExlYWRpbmdTbGFzaCA9IHdpdGhvdXRTdGF0aWNCYXNlLnN0YXJ0c1dpdGgoXCIvXCIpID8gd2l0aG91dFN0YXRpY0Jhc2Uuc2xpY2UoMSkgOiB3aXRob3V0U3RhdGljQmFzZTtcbiAgbGV0IHByZXZGaWxlRGF0YSA9IHdpbmRvdy5yZW1vdGlvbl9zdGF0aWNGaWxlcy5maW5kKChmaWxlKSA9PiBmaWxlLm5hbWUgPT09IHdpdGhvdXRMZWFkaW5nU2xhc2gpO1xuICBjb25zdCBjaGVja0ZpbGUgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBzdGF0aWNGaWxlcyA9IGV2ZW50LmRldGFpbC5maWxlcztcbiAgICBjb25zdCBuZXdGaWxlRGF0YSA9IHN0YXRpY0ZpbGVzLmZpbmQoKGZpbGUpID0+IGZpbGUubmFtZSA9PT0gd2l0aG91dExlYWRpbmdTbGFzaCk7XG4gICAgaWYgKCFuZXdGaWxlRGF0YSkge1xuICAgICAgaWYgKHByZXZGaWxlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgICAgcHJldkZpbGVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldkZpbGVEYXRhID09PSB1bmRlZmluZWQgfHwgcHJldkZpbGVEYXRhLmxhc3RNb2RpZmllZCAhPT0gbmV3RmlsZURhdGEubGFzdE1vZGlmaWVkKSB7XG4gICAgICBjYWxsYmFjayhuZXdGaWxlRGF0YSk7XG4gICAgICBwcmV2RmlsZURhdGEgPSBuZXdGaWxlRGF0YTtcbiAgICB9XG4gIH07XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUywgY2hlY2tGaWxlKTtcbiAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xuICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihXQVRDSF9SRU1PVElPTl9TVEFUSUNfRklMRVMsIGNoZWNrRmlsZSk7XG4gIH07XG4gIHJldHVybiB7IGNhbmNlbCB9O1xufTtcblxuLy8gc3JjL3dyYXAtcmVtb3Rpb24tY29udGV4dC50c3hcbmltcG9ydCBSZWFjdDMwLCB7IHVzZU1lbW8gYXMgdXNlTWVtbzI5IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBqc3ggYXMganN4MzEgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmZ1bmN0aW9uIHVzZVJlbW90aW9uQ29udGV4dHMoKSB7XG4gIGNvbnN0IGNvbXBvc2l0aW9uTWFuYWdlckN0eCA9IFJlYWN0MzAudXNlQ29udGV4dChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICBjb25zdCB0aW1lbGluZUNvbnRleHQgPSBSZWFjdDMwLnVzZUNvbnRleHQoVGltZWxpbmVDb250ZXh0KTtcbiAgY29uc3Qgc2V0VGltZWxpbmVDb250ZXh0ID0gUmVhY3QzMC51c2VDb250ZXh0KFNldFRpbWVsaW5lQ29udGV4dCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IFJlYWN0MzAudXNlQ29udGV4dChTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBub25jZUNvbnRleHQgPSBSZWFjdDMwLnVzZUNvbnRleHQoTm9uY2VDb250ZXh0KTtcbiAgY29uc3QgY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQgPSBSZWFjdDMwLnVzZUNvbnRleHQoQ2FuVXNlUmVtb3Rpb25Ib29rcyk7XG4gIGNvbnN0IHByZWxvYWRDb250ZXh0ID0gUmVhY3QzMC51c2VDb250ZXh0KFByZWxvYWRDb250ZXh0KTtcbiAgY29uc3QgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCA9IFJlYWN0MzAudXNlQ29udGV4dChSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0KTtcbiAgY29uc3QgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCA9IFJlYWN0MzAudXNlQ29udGV4dChSZW5kZXJBc3NldE1hbmFnZXIpO1xuICBjb25zdCBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0ID0gUmVhY3QzMC51c2VDb250ZXh0KFNlcXVlbmNlTWFuYWdlcik7XG4gIGNvbnN0IGJ1ZmZlck1hbmFnZXJDb250ZXh0ID0gUmVhY3QzMC51c2VDb250ZXh0KEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCk7XG4gIGNvbnN0IGxvZ0xldmVsQ29udGV4dCA9IFJlYWN0MzAudXNlQ29udGV4dChMb2dMZXZlbENvbnRleHQpO1xuICByZXR1cm4gdXNlTWVtbzI5KCgpID0+ICh7XG4gICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgIHRpbWVsaW5lQ29udGV4dCxcbiAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgc2VxdWVuY2VDb250ZXh0LFxuICAgIG5vbmNlQ29udGV4dCxcbiAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICBwcmVsb2FkQ29udGV4dCxcbiAgICByZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LFxuICAgIHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsXG4gICAgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICBidWZmZXJNYW5hZ2VyQ29udGV4dCxcbiAgICBsb2dMZXZlbENvbnRleHRcbiAgfSksIFtcbiAgICBjb21wb3NpdGlvbk1hbmFnZXJDdHgsXG4gICAgbm9uY2VDb250ZXh0LFxuICAgIHNlcXVlbmNlQ29udGV4dCxcbiAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgdGltZWxpbmVDb250ZXh0LFxuICAgIGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LFxuICAgIHByZWxvYWRDb250ZXh0LFxuICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgIGJ1ZmZlck1hbmFnZXJDb250ZXh0LFxuICAgIGxvZ0xldmVsQ29udGV4dFxuICBdKTtcbn1cbnZhciBSZW1vdGlvbkNvbnRleHRQcm92aWRlciA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGV4dHMgfSA9IHByb3BzMjtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMShMb2dMZXZlbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dHMubG9nTGV2ZWxDb250ZXh0LFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzEoQ2FuVXNlUmVtb3Rpb25Ib29rcy5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IGNvbnRleHRzLmNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMShOb25jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IGNvbnRleHRzLm5vbmNlQ29udGV4dCxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMShQcmVsb2FkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5wcmVsb2FkQ29udGV4dCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMxKENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLmNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzEoU2VxdWVuY2VNYW5hZ2VyLlByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZU1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMxKFJlbmRlckFzc2V0TWFuYWdlci5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5yZW5kZXJBc3NldE1hbmFnZXJDb250ZXh0LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzEoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNvbnRleHRzLnJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMxKFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMudGltZWxpbmVDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMxKFNldFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXRUaW1lbGluZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gzMShTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb250ZXh0cy5zZXF1ZW5jZUNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDMxKEJ1ZmZlcmluZ0NvbnRleHRSZWFjdC5Qcm92aWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY29udGV4dHMuYnVmZmVyTWFuYWdlckNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH0pO1xufTtcblxuLy8gc3JjL2ludGVybmFscy50c1xudmFyIGNvbXBvc2l0aW9uU2VsZWN0b3JSZWYgPSBjcmVhdGVSZWYzKCk7XG52YXIgSW50ZXJuYWxzID0ge1xuICB1c2VVbnNhZmVWaWRlb0NvbmZpZyxcbiAgdXNlRnJhbWVGb3JWb2x1bWVQcm9wLFxuICB1c2VUaW1lbGluZVBvc2l0aW9uLFxuICBldmFsdWF0ZVZvbHVtZSxcbiAgZ2V0QWJzb2x1dGVTcmMsXG4gIFRpbWVsaW5lOiBleHBvcnRzX3RpbWVsaW5lX3Bvc2l0aW9uX3N0YXRlLFxuICB2YWxpZGF0ZU1lZGlhVHJpbVByb3BzLFxuICB2YWxpZGF0ZU1lZGlhUHJvcHMsXG4gIHJlc29sdmVUcmltUHJvcHMsXG4gIFZpZGVvRm9yUHJldmlldyxcbiAgQ29tcG9zaXRpb25NYW5hZ2VyLFxuICBDb21wb3NpdGlvblNldHRlcnMsXG4gIFNlcXVlbmNlTWFuYWdlcixcbiAgU2VxdWVuY2VWaXNpYmlsaXR5VG9nZ2xlQ29udGV4dCxcbiAgUmVtb3Rpb25Sb290LFxuICB1c2VWaWRlbyxcbiAgZ2V0Um9vdCxcbiAgdXNlTWVkaWFWb2x1bWVTdGF0ZSxcbiAgdXNlTWVkaWFNdXRlZFN0YXRlLFxuICB1c2VNZWRpYUluVGltZWxpbmUsXG4gIHVzZUxhenlDb21wb25lbnQsXG4gIHRydXRoeSxcbiAgU2VxdWVuY2VDb250ZXh0LFxuICB1c2VSZW1vdGlvbkNvbnRleHRzLFxuICBSZW1vdGlvbkNvbnRleHRQcm92aWRlcixcbiAgQ1NTVXRpbHM6IGV4cG9ydHNfZGVmYXVsdF9jc3MsXG4gIHNldHVwRW52VmFyaWFibGVzLFxuICBNZWRpYVZvbHVtZUNvbnRleHQsXG4gIFNldE1lZGlhVm9sdW1lQ29udGV4dCxcbiAgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgU2hhcmVkQXVkaW9Db250ZXh0LFxuICBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlcixcbiAgaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlLFxuICBjYWxjdWxhdGVNZWRpYUR1cmF0aW9uLFxuICBpc0NvbXBvc2l0aW9uSWRWYWxpZCxcbiAgZ2V0UHJldmlld0RvbUVsZW1lbnQsXG4gIGNvbXBvc2l0aW9uc1JlZixcbiAgcG9ydGFsTm9kZSxcbiAgd2FpdEZvclJvb3QsXG4gIENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlcixcbiAgQ2FuVXNlUmVtb3Rpb25Ib29rcyxcbiAgUHJlZmV0Y2hQcm92aWRlcixcbiAgRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyLFxuICBJc1BsYXllckNvbnRleHRQcm92aWRlcixcbiAgdXNlSXNQbGF5ZXIsXG4gIEVkaXRvclByb3BzUHJvdmlkZXIsXG4gIEVkaXRvclByb3BzQ29udGV4dCxcbiAgdXNlUHJlbG9hZCxcbiAgTm9uY2VDb250ZXh0LFxuICBTZXROb25jZUNvbnRleHQsXG4gIHJlc29sdmVWaWRlb0NvbmZpZyxcbiAgdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyxcbiAgcmVzb2x2ZUNvbXBvc2l0aW9uc1JlZixcbiAgUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLFxuICBSRU1PVElPTl9TVFVESU9fQ09OVEFJTkVSX0VMRU1FTlQsXG4gIFJlbmRlckFzc2V0TWFuYWdlcixcbiAgcGVyc2lzdEN1cnJlbnRGcmFtZSxcbiAgdXNlVGltZWxpbmVTZXRGcmFtZSxcbiAgaXNJb3NTYWZhcmksXG4gIFdBVENIX1JFTU9USU9OX1NUQVRJQ19GSUxFUyxcbiAgYWRkU2VxdWVuY2VTdGFja1RyYWNlcyxcbiAgdXNlTWVkaWFTdGFydHNBdCxcbiAgQnVmZmVyaW5nUHJvdmlkZXIsXG4gIEJ1ZmZlcmluZ0NvbnRleHRSZWFjdCxcbiAgZW5hYmxlU2VxdWVuY2VTdGFja1RyYWNlcyxcbiAgQ3VycmVudFNjYWxlQ29udGV4dCxcbiAgUHJldmlld1NpemVDb250ZXh0LFxuICBjYWxjdWxhdGVTY2FsZSxcbiAgZWRpdG9yUHJvcHNQcm92aWRlclJlZixcbiAgUFJPUFNfVVBEQVRFRF9FWFRFUk5BTExZLFxuICB2YWxpZGF0ZVJlbmRlckFzc2V0LFxuICBMb2csXG4gIExvZ0xldmVsQ29udGV4dCxcbiAgdXNlTG9nTGV2ZWwsXG4gIHBsYXliYWNrTG9nZ2luZyxcbiAgdGltZVZhbHVlUmVmLFxuICBjb21wb3NpdGlvblNlbGVjdG9yUmVmLFxuICBSZW1vdGlvbkVudmlyb25tZW50Q29udGV4dCxcbiAgd2FybkFib3V0VG9vSGlnaFZvbHVtZSxcbiAgQXVkaW9Gb3JQcmV2aWV3LFxuICBPQkpFQ1RGSVRfQ09OVEFJTl9DTEFTU19OQU1FLFxuICBJbm5lck9mZnRocmVhZFZpZGVvLFxuICB1c2VCYXNpY01lZGlhSW5UaW1lbGluZSxcbiAgZ2V0SW5wdXRQcm9wc092ZXJyaWRlLFxuICBzZXRJbnB1dFByb3BzT3ZlcnJpZGUsXG4gIHVzZVZpZGVvRW5hYmxlZCxcbiAgdXNlQXVkaW9FbmFibGVkLFxuICB1c2VJc1BsYXllckJ1ZmZlcmluZ1xufTtcbi8vIHNyYy9pbnRlcnBvbGF0ZS1jb2xvcnMudHNcbnZhciBOVU1CRVIgPSBcIlstK10/XFxcXGQqXFxcXC4/XFxcXGQrXCI7XG52YXIgUEVSQ0VOVEFHRSA9IE5VTUJFUiArIFwiJVwiO1xuZnVuY3Rpb24gY2FsbCguLi5hcmdzKSB7XG4gIHJldHVybiBcIlxcXFwoXFxcXHMqKFwiICsgYXJncy5qb2luKFwiKVxcXFxzKixcXFxccyooXCIpICsgXCIpXFxcXHMqXFxcXClcIjtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXJzKCkge1xuICBjb25zdCBjYWNoZWRNYXRjaGVycyA9IHtcbiAgICByZ2I6IHVuZGVmaW5lZCxcbiAgICByZ2JhOiB1bmRlZmluZWQsXG4gICAgaHNsOiB1bmRlZmluZWQsXG4gICAgaHNsYTogdW5kZWZpbmVkLFxuICAgIGhleDM6IHVuZGVmaW5lZCxcbiAgICBoZXg0OiB1bmRlZmluZWQsXG4gICAgaGV4NTogdW5kZWZpbmVkLFxuICAgIGhleDY6IHVuZGVmaW5lZCxcbiAgICBoZXg4OiB1bmRlZmluZWRcbiAgfTtcbiAgaWYgKGNhY2hlZE1hdGNoZXJzLnJnYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiID0gbmV3IFJlZ0V4cChcInJnYlwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMucmdiYSA9IG5ldyBSZWdFeHAoXCJyZ2JhXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbCA9IG5ldyBSZWdFeHAoXCJoc2xcIiArIGNhbGwoTlVNQkVSLCBQRVJDRU5UQUdFLCBQRVJDRU5UQUdFKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaHNsYSA9IG5ldyBSZWdFeHAoXCJoc2xhXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSwgTlVNQkVSKSk7XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4MyA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDQgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4NiA9IC9eIyhbMC05YS1mQS1GXXs2fSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg4ID0gL14jKFswLTlhLWZBLUZdezh9KSQvO1xuICB9XG4gIHJldHVybiBjYWNoZWRNYXRjaGVycztcbn1cbmZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICBpZiAodCA8IDApIHtcbiAgICB0ICs9IDE7XG4gIH1cbiAgaWYgKHQgPiAxKSB7XG4gICAgdCAtPSAxO1xuICB9XG4gIGlmICh0IDwgMSAvIDYpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgfVxuICBpZiAodCA8IDEgLyAyKSB7XG4gICAgcmV0dXJuIHE7XG4gIH1cbiAgaWYgKHQgPCAyIC8gMykge1xuICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgfVxuICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgY29uc3QgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gIGNvbnN0IGcgPSBodWUycmdiKHAsIHEsIGgpO1xuICBjb25zdCBiMiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiMiAqIDI1NSkgPDwgODtcbn1cbmZ1bmN0aW9uIHBhcnNlMjU1KHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RyLCAxMCk7XG4gIGlmIChpbnQgPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGludCA+IDI1NSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIGludDtcbn1cbmZ1bmN0aW9uIHBhcnNlMzYwKHN0cikge1xuICBjb25zdCBpbnQgPSBOdW1iZXIucGFyc2VGbG9hdChzdHIpO1xuICByZXR1cm4gKGludCAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7XG59XG5mdW5jdGlvbiBwYXJzZTEoc3RyKSB7XG4gIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIGlmIChudW0gPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKG51bSA+IDEpIHtcbiAgICByZXR1cm4gMjU1O1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDI1NSk7XG59XG5mdW5jdGlvbiBwYXJzZVBlcmNlbnRhZ2Uoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIGlmIChpbnQgPCAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGludCA+IDEwMCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBpbnQgLyAxMDA7XG59XG52YXIgY29sb3JOYW1lcyA9IHtcbiAgdHJhbnNwYXJlbnQ6IDAsXG4gIGFsaWNlYmx1ZTogNDA0Mjg1MDMwMyxcbiAgYW50aXF1ZXdoaXRlOiA0MjA5NzYwMjU1LFxuICBhcXVhOiAxNjc3NzIxNSxcbiAgYXF1YW1hcmluZTogMjE0NzQ3MjYzOSxcbiAgYXp1cmU6IDQwNDMzMDkwNTUsXG4gIGJlaWdlOiA0MTI2NTMwODE1LFxuICBiaXNxdWU6IDQyOTMxODI3MTksXG4gIGJsYWNrOiAyNTUsXG4gIGJsYW5jaGVkYWxtb25kOiA0MjkzNjQzNzc1LFxuICBibHVlOiA2NTUzNSxcbiAgYmx1ZXZpb2xldDogMjMxODEzMTk2NyxcbiAgYnJvd246IDI3NzEwMDQxNTksXG4gIGJ1cmx5d29vZDogMzczNjYzNTM5MSxcbiAgYnVybnRzaWVubmE6IDM5MzQxNTAxNDMsXG4gIGNhZGV0Ymx1ZTogMTYwNDIzMTQyMyxcbiAgY2hhcnRyZXVzZTogMjE0NzQxODM2NyxcbiAgY2hvY29sYXRlOiAzNTMwMTA0NTc1LFxuICBjb3JhbDogNDI4NjUzMzg4NyxcbiAgY29ybmZsb3dlcmJsdWU6IDE2ODc1NDczOTEsXG4gIGNvcm5zaWxrOiA0Mjk0NDk5NTgzLFxuICBjcmltc29uOiAzNjkyMzEzODU1LFxuICBjeWFuOiAxNjc3NzIxNSxcbiAgZGFya2JsdWU6IDM1ODM5LFxuICBkYXJrY3lhbjogOTE0NTM0MyxcbiAgZGFya2dvbGRlbnJvZDogMzA5NTc5MjYzOSxcbiAgZGFya2dyYXk6IDI4NDY0Njg2MDcsXG4gIGRhcmtncmVlbjogNjU1Mzg1NSxcbiAgZGFya2dyZXk6IDI4NDY0Njg2MDcsXG4gIGRhcmtraGFraTogMzE4MjkxNDU1OSxcbiAgZGFya21hZ2VudGE6IDIzMzIwNjg4NjMsXG4gIGRhcmtvbGl2ZWdyZWVuOiAxNDMzMDg3OTk5LFxuICBkYXJrb3JhbmdlOiA0Mjg3MzY1Mzc1LFxuICBkYXJrb3JjaGlkOiAyNTcwMjQzMzI3LFxuICBkYXJrcmVkOiAyMzMyMDMzMjc5LFxuICBkYXJrc2FsbW9uOiAzOTE4OTUzMjE1LFxuICBkYXJrc2VhZ3JlZW46IDI0MTE0OTk1MTksXG4gIGRhcmtzbGF0ZWJsdWU6IDEyMTE5OTMwODcsXG4gIGRhcmtzbGF0ZWdyYXk6IDc5MzcyNjk3NSxcbiAgZGFya3NsYXRlZ3JleTogNzkzNzI2OTc1LFxuICBkYXJrdHVycXVvaXNlOiAxMzU1NDE3NSxcbiAgZGFya3Zpb2xldDogMjQ4MzA4MjIzOSxcbiAgZGVlcHBpbms6IDQyNzk1Mzg2ODcsXG4gIGRlZXBza3libHVlOiAxMjU4MjkxMSxcbiAgZGltZ3JheTogMTc2ODUxNjA5NSxcbiAgZGltZ3JleTogMTc2ODUxNjA5NSxcbiAgZG9kZ2VyYmx1ZTogNTEyODE5MTk5LFxuICBmaXJlYnJpY2s6IDI5ODg1ODE2MzEsXG4gIGZsb3JhbHdoaXRlOiA0Mjk0NjM1Nzc1LFxuICBmb3Jlc3RncmVlbjogNTc5NTQzODA3LFxuICBmdWNoc2lhOiA0Mjc4MjU1NjE1LFxuICBnYWluc2Jvcm86IDM3MDU0NjIwMTUsXG4gIGdob3N0d2hpdGU6IDQxNzcwNjgwMzEsXG4gIGdvbGQ6IDQyOTIyODA1NzUsXG4gIGdvbGRlbnJvZDogMzY2ODI1NDk3NSxcbiAgZ3JheTogMjE1NTkwNTI3OSxcbiAgZ3JlZW46IDgzODg4NjMsXG4gIGdyZWVueWVsbG93OiAyOTE5MTgyMzM1LFxuICBncmV5OiAyMTU1OTA1Mjc5LFxuICBob25leWRldzogNDA0MzMwNTIxNSxcbiAgaG90cGluazogNDI4NTExNzY5NSxcbiAgaW5kaWFucmVkOiAzNDQ1MzgyMzk5LFxuICBpbmRpZ286IDEyNTgzMjQ3MzUsXG4gIGl2b3J5OiA0Mjk0OTYzNDU1LFxuICBraGFraTogNDA0MTY0MTIxNSxcbiAgbGF2ZW5kZXI6IDM4NzM4OTcyMTUsXG4gIGxhdmVuZGVyYmx1c2g6IDQyOTM5ODE2OTUsXG4gIGxhd25ncmVlbjogMjA5Njg5MDExMSxcbiAgbGVtb25jaGlmZm9uOiA0Mjk0NjI2ODE1LFxuICBsaWdodGJsdWU6IDI5MTY2NzMyNzksXG4gIGxpZ2h0Y29yYWw6IDQwMzQ5NTM0NzEsXG4gIGxpZ2h0Y3lhbjogMzc3NDg3MzU5OSxcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDQyMTA3NDIwMTUsXG4gIGxpZ2h0Z3JheTogMzU1Mzg3NDk0MyxcbiAgbGlnaHRncmVlbjogMjQzMTU1Mzc5MSxcbiAgbGlnaHRncmV5OiAzNTUzODc0OTQzLFxuICBsaWdodHBpbms6IDQyOTAxNjcyOTUsXG4gIGxpZ2h0c2FsbW9uOiA0Mjg4NzA3MzI3LFxuICBsaWdodHNlYWdyZWVuOiA1NDg1ODAwOTUsXG4gIGxpZ2h0c2t5Ymx1ZTogMjI3ODQ4ODgzMSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c2xhdGVncmV5OiAyMDA1NDQxMDIzLFxuICBsaWdodHN0ZWVsYmx1ZTogMjk2NTY5MjE1OSxcbiAgbGlnaHR5ZWxsb3c6IDQyOTQ5NTkzNTksXG4gIGxpbWU6IDE2NzExOTM1LFxuICBsaW1lZ3JlZW46IDg1MjMwODczNSxcbiAgbGluZW46IDQyMTAwOTE3NzUsXG4gIG1hZ2VudGE6IDQyNzgyNTU2MTUsXG4gIG1hcm9vbjogMjE0NzQ4MzkwMyxcbiAgbWVkaXVtYXF1YW1hcmluZTogMTcyNDc1NDY4NyxcbiAgbWVkaXVtYmx1ZTogNTI3MzUsXG4gIG1lZGl1bW9yY2hpZDogMzEyNjE4NzAwNyxcbiAgbWVkaXVtcHVycGxlOiAyNDczNjQ3MTAzLFxuICBtZWRpdW1zZWFncmVlbjogMTAxODM5MzA4NyxcbiAgbWVkaXVtc2xhdGVibHVlOiAyMDcwNDc0NDk1LFxuICBtZWRpdW1zcHJpbmdncmVlbjogMTY0MjM2NzksXG4gIG1lZGl1bXR1cnF1b2lzZTogMTIyMTcwOTA1NSxcbiAgbWVkaXVtdmlvbGV0cmVkOiAzMzQwMDc2NTQzLFxuICBtaWRuaWdodGJsdWU6IDQyMTA5NzcyNyxcbiAgbWludGNyZWFtOiA0MTI3MTkzODU1LFxuICBtaXN0eXJvc2U6IDQyOTMxOTAxNDMsXG4gIG1vY2Nhc2luOiA0MjkzMTc4ODc5LFxuICBuYXZham93aGl0ZTogNDI5Mjc4MzYxNSxcbiAgbmF2eTogMzMwMjMsXG4gIG9sZGxhY2U6IDQyNjA3NTExMDMsXG4gIG9saXZlOiAyMTU1ODcyNTExLFxuICBvbGl2ZWRyYWI6IDE4MDQ0Nzc0MzksXG4gIG9yYW5nZTogNDI4OTAwMzc3NSxcbiAgb3JhbmdlcmVkOiA0MjgyNzEyMzE5LFxuICBvcmNoaWQ6IDM2NjQ4MjgxNTksXG4gIHBhbGVnb2xkZW5yb2Q6IDQwMDgyMjU1MzUsXG4gIHBhbGVncmVlbjogMjU2NjYyNTUzNSxcbiAgcGFsZXR1cnF1b2lzZTogMjk1MTY3MTU1MSxcbiAgcGFsZXZpb2xldHJlZDogMzY4MTU4ODIyMyxcbiAgcGFwYXlhd2hpcDogNDI5MzkwNzk2NyxcbiAgcGVhY2hwdWZmOiA0MjkyNTI0NTQzLFxuICBwZXJ1OiAzNDQ4MDYxOTUxLFxuICBwaW5rOiA0MjkwODI1MjE1LFxuICBwbHVtOiAzNzE4MzA3MzI3LFxuICBwb3dkZXJibHVlOiAyOTY3NTI5MjE1LFxuICBwdXJwbGU6IDIxNDc1MTY2NzEsXG4gIHJlYmVjY2FwdXJwbGU6IDE3MTQ2NTc3OTEsXG4gIHJlZDogNDI3ODE5MDMzNSxcbiAgcm9zeWJyb3duOiAzMTYzNTI1MTE5LFxuICByb3lhbGJsdWU6IDEwOTc0NTgxNzUsXG4gIHNhZGRsZWJyb3duOiAyMzM2NTYwMTI3LFxuICBzYWxtb246IDQyMDI3MjIwNDcsXG4gIHNhbmR5YnJvd246IDQxMDQ0MTM0MzksXG4gIHNlYWdyZWVuOiA3ODA4ODM5NjcsXG4gIHNlYXNoZWxsOiA0Mjk0MzA3NTgzLFxuICBzaWVubmE6IDI2ODk3NDAyODcsXG4gIHNpbHZlcjogMzIzMzg1Nzc5MSxcbiAgc2t5Ymx1ZTogMjI3ODQ4NDk5MSxcbiAgc2xhdGVibHVlOiAxNzg0MzM1ODcxLFxuICBzbGF0ZWdyYXk6IDE4ODc0NzM5MTksXG4gIHNsYXRlZ3JleTogMTg4NzQ3MzkxOSxcbiAgc25vdzogNDI5NDYzODMzNSxcbiAgc3ByaW5nZ3JlZW46IDE2NzQ0NDQ3LFxuICBzdGVlbGJsdWU6IDExODI5NzExMzUsXG4gIHRhbjogMzUzNTA0NzkzNSxcbiAgdGVhbDogODQyMTYzMSxcbiAgdGhpc3RsZTogMzYzNjQ1MTU4MyxcbiAgdG9tYXRvOiA0Mjg0Njk2NTc1LFxuICB0dXJxdW9pc2U6IDEwODg0NzUzOTEsXG4gIHZpb2xldDogNDAwMTU1ODI3MSxcbiAgd2hlYXQ6IDQxMjUwMTI5OTEsXG4gIHdoaXRlOiA0Mjk0OTY3Mjk1LFxuICB3aGl0ZXNtb2tlOiA0MTI2NTM3MjE1LFxuICB5ZWxsb3c6IDQyOTQ5MDIwMTUsXG4gIHllbGxvd2dyZWVuOiAyNTk3MTM5MTk5XG59O1xuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgY29uc3QgbWF0Y2hlcnMgPSBnZXRNYXRjaGVycygpO1xuICBsZXQgbWF0Y2g7XG4gIGlmIChtYXRjaGVycy5oZXg2KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4Ni5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAoY29sb3JOYW1lc1tjb2xvcl0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjb2xvck5hbWVzW2NvbG9yXTtcbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLnJnYmEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IHBhcnNlMjU1KG1hdGNoWzNdKSA8PCA4IHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXgzKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4My5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDgpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg4LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oZXg0KSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaGV4NC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArIG1hdGNoWzFdICsgbWF0Y2hbMl0gKyBtYXRjaFsyXSArIG1hdGNoWzNdICsgbWF0Y2hbM10gKyBtYXRjaFs0XSArIG1hdGNoWzRdLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oc2wpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2wuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAoaHNsVG9SZ2IocGFyc2UzNjAobWF0Y2hbMV0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLCBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbM10pKSB8IDI1NSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChtYXRjaGVycy5oc2xhKSB7XG4gICAgaWYgKG1hdGNoID0gbWF0Y2hlcnMuaHNsYS5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgcGFyc2UxKG1hdGNoWzRdKSkgPj4+IDA7XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjb2xvciBzdHJpbmcgJHtjb2xvcn0gcHJvdmlkZWRgKTtcbn1cbnZhciBvcGFjaXR5ID0gKGMyKSA9PiB7XG4gIHJldHVybiAoYzIgPj4gMjQgJiAyNTUpIC8gMjU1O1xufTtcbnZhciByZWQgPSAoYzIpID0+IHtcbiAgcmV0dXJuIGMyID4+IDE2ICYgMjU1O1xufTtcbnZhciBncmVlbiA9IChjMikgPT4ge1xuICByZXR1cm4gYzIgPj4gOCAmIDI1NTtcbn07XG52YXIgYmx1ZSA9IChjMikgPT4ge1xuICByZXR1cm4gYzIgJiAyNTU7XG59O1xudmFyIHJnYmFDb2xvciA9IChyLCBnLCBiMiwgYWxwaGEpID0+IHtcbiAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7YjJ9LCAke2FscGhhfSlgO1xufTtcbmZ1bmN0aW9uIHByb2Nlc3NDb2xvcihjb2xvcikge1xuICBjb25zdCBub3JtYWxpemVkQ29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gIHJldHVybiAobm9ybWFsaXplZENvbG9yIDw8IDI0IHwgbm9ybWFsaXplZENvbG9yID4+PiA4KSA+Pj4gMDtcbn1cbnZhciBpbnRlcnBvbGF0ZUNvbG9yc1JHQiA9ICh2YWx1ZSwgaW5wdXRSYW5nZSwgY29sb3JzKSA9PiB7XG4gIGNvbnN0IFtyLCBnLCBiMiwgYTJdID0gW3JlZCwgZ3JlZW4sIGJsdWUsIG9wYWNpdHldLm1hcCgoZikgPT4ge1xuICAgIGNvbnN0IHVucm91bmRlZCA9IGludGVycG9sYXRlKHZhbHVlLCBpbnB1dFJhbmdlLCBjb2xvcnMubWFwKChjMikgPT4gZihjMikpLCB7XG4gICAgICBleHRyYXBvbGF0ZUxlZnQ6IFwiY2xhbXBcIixcbiAgICAgIGV4dHJhcG9sYXRlUmlnaHQ6IFwiY2xhbXBcIlxuICAgIH0pO1xuICAgIGlmIChmID09PSBvcGFjaXR5KSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHVucm91bmRlZC50b0ZpeGVkKDMpKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQodW5yb3VuZGVkKTtcbiAgfSk7XG4gIHJldHVybiByZ2JhQ29sb3IociwgZywgYjIsIGEyKTtcbn07XG52YXIgaW50ZXJwb2xhdGVDb2xvcnMgPSAoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlKSA9PiB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImlucHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWRcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBvdXRwdXRSYW5nZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnB1dFJhbmdlIChcIiArIGlucHV0UmFuZ2UubGVuZ3RoICsgXCIgdmFsdWVzIHByb3ZpZGVkKSBhbmQgb3V0cHV0UmFuZ2UgKFwiICsgb3V0cHV0UmFuZ2UubGVuZ3RoICsgXCIgdmFsdWVzIHByb3ZpZGVkKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNvbnN0IHByb2Nlc3NlZE91dHB1dFJhbmdlID0gb3V0cHV0UmFuZ2UubWFwKChjMikgPT4gcHJvY2Vzc0NvbG9yKGMyKSk7XG4gIHJldHVybiBpbnRlcnBvbGF0ZUNvbG9yc1JHQihpbnB1dCwgaW5wdXRSYW5nZSwgcHJvY2Vzc2VkT3V0cHV0UmFuZ2UpO1xufTtcbi8vIHNyYy92YWxpZGF0ZS1mcmFtZS50c1xudmFyIHZhbGlkYXRlRnJhbWUgPSAoe1xuICBhbGxvd0Zsb2F0cyxcbiAgZHVyYXRpb25JbkZyYW1lcyxcbiAgZnJhbWVcbn0pID0+IHtcbiAgaWYgKHR5cGVvZiBmcmFtZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEFyZ3VtZW50IG1pc3NpbmcgZm9yIHBhcmFtZXRlciBcImZyYW1lXCJgKTtcbiAgfVxuICBpZiAodHlwZW9mIGZyYW1lICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgcGFzc2VkIGZvciBcImZyYW1lXCIgaXMgbm90IGEgbnVtYmVyOiAke2ZyYW1lfWApO1xuICB9XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBGcmFtZSAke2ZyYW1lfSBpcyBub3QgZmluaXRlYCk7XG4gIH1cbiAgaWYgKGZyYW1lICUgMSAhPT0gMCAmJiAhYWxsb3dGbG9hdHMpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQXJndW1lbnQgZm9yIGZyYW1lIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2ZyYW1lfWApO1xuICB9XG4gIGlmIChmcmFtZSA8IDAgJiYgZnJhbWUgPCAtZHVyYXRpb25JbkZyYW1lcykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGxvd2VzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAkey1kdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChmcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgaGlnaGVzdCBmcmFtZSB0aGF0IGNhbiBiZSByZW5kZXJlZCBpcyAke2R1cmF0aW9uSW5GcmFtZXMgLSAxfWApO1xuICB9XG59O1xuLy8gc3JjL3Nlcmllcy9pbmRleC50c3hcbmltcG9ydCB7IENoaWxkcmVuLCBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMCwgdXNlTWVtbyBhcyB1c2VNZW1vMzAgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3Nlcmllcy9mbGF0dGVuLWNoaWxkcmVuLnRzeFxuaW1wb3J0IFJlYWN0MzEgZnJvbSBcInJlYWN0XCI7XG52YXIgZmxhdHRlbkNoaWxkcmVuID0gKGNoaWxkcmVuKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuQXJyYXkgPSBSZWFjdDMxLkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICByZXR1cm4gY2hpbGRyZW5BcnJheS5yZWR1Y2UoKGZsYXRDaGlsZHJlbiwgY2hpbGQpID0+IHtcbiAgICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QzMS5GcmFnbWVudCkge1xuICAgICAgcmV0dXJuIGZsYXRDaGlsZHJlbi5jb25jYXQoZmxhdHRlbkNoaWxkcmVuKGNoaWxkLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgfVxuICAgIGZsYXRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gZmxhdENoaWxkcmVuO1xuICB9LCBbXSk7XG59O1xuXG4vLyBzcmMvc2VyaWVzL2lzLWluc2lkZS1zZXJpZXMudHN4XG5pbXBvcnQgUmVhY3QzMiwgeyBjcmVhdGVDb250ZXh0IGFzIGNyZWF0ZUNvbnRleHQyMCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsganN4IGFzIGpzeDMyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSXNJbnNpZGVTZXJpZXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDIwKGZhbHNlKTtcbnZhciBJc0luc2lkZVNlcmllc0NvbnRhaW5lciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMihJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgICBjaGlsZHJlblxuICB9KTtcbn07XG52YXIgSXNOb3RJbnNpZGVTZXJpZXNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMihJc0luc2lkZVNlcmllc0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIHVzZVJlcXVpcmVUb0JlSW5zaWRlU2VyaWVzID0gKCkgPT4ge1xuICBjb25zdCBpc0luc2lkZVNlcmllcyA9IFJlYWN0MzIudXNlQ29udGV4dChJc0luc2lkZVNlcmllc0NvbnRleHQpO1xuICBpZiAoIWlzSW5zaWRlU2VyaWVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBjb21wb25lbnQgbXVzdCBiZSBpbnNpZGUgYSA8U2VyaWVzIC8+IGNvbXBvbmVudC5cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9zZXJpZXMvaW5kZXgudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7IGNoaWxkcmVuIH0sIF9yZWYpID0+IHtcbiAgdXNlUmVxdWlyZVRvQmVJbnNpZGVTZXJpZXMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzMyhJc05vdEluc2lkZVNlcmllc1Byb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW5cbiAgfSk7XG59O1xudmFyIFNlcmllc1NlcXVlbmNlID0gZm9yd2FyZFJlZjEwKFNlcmllc1NlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcbnZhciBTZXJpZXMgPSAocHJvcHMyKSA9PiB7XG4gIGNvbnN0IGNoaWxkcmVuVmFsdWUgPSB1c2VNZW1vMzAoKCkgPT4ge1xuICAgIGxldCBzdGFydEZyYW1lID0gMDtcbiAgICBjb25zdCBmbGF0dGVuZWRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wczIuY2hpbGRyZW4pO1xuICAgIHJldHVybiBDaGlsZHJlbi5tYXAoZmxhdHRlbmVkQ2hpbGRyZW4sIChjaGlsZCwgaSkgPT4ge1xuICAgICAgY29uc3QgY2FzdGVkQ2hpbGQgPSBjaGlsZDtcbiAgICAgIGlmICh0eXBlb2YgY2FzdGVkQ2hpbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGNhc3RlZENoaWxkLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSA8U2VyaWVzIC8+IGNvbXBvbmVudCBvbmx5IGFjY2VwdHMgYSBsaXN0IG9mIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50cyBhcyBpdHMgY2hpbGRyZW4sIGJ1dCB5b3UgcGFzc2VkIGEgc3RyaW5nIFwiJHtjYXN0ZWRDaGlsZH1cImApO1xuICAgICAgfVxuICAgICAgaWYgKGNhc3RlZENoaWxkLnR5cGUgIT09IFNlcmllc1NlcXVlbmNlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSA8U2VyaWVzIC8+IGNvbXBvbmVudCBvbmx5IGFjY2VwdHMgYSBsaXN0IG9mIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50cyBhcyBpdHMgY2hpbGRyZW4sIGJ1dCBnb3QgJHtjYXN0ZWRDaGlsZH0gaW5zdGVhZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVidWdJbmZvID0gYGluZGV4ID0gJHtpfSwgZHVyYXRpb24gPSAke2Nhc3RlZENoaWxkLnByb3BzLmR1cmF0aW9uSW5GcmFtZXN9YDtcbiAgICAgIGlmICghY2FzdGVkQ2hpbGQ/LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnQgKCR7ZGVidWdJbmZvfSkgd2FzIGRldGVjdGVkIHRvIG5vdCBoYXZlIGFueSBjaGlsZHJlbi4gRGVsZXRlIGl0IHRvIGZpeCB0aGlzIGVycm9yLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgZHVyYXRpb25JbkZyYW1lc1Byb3AgPSBjYXN0ZWRDaGlsZC5wcm9wcy5kdXJhdGlvbkluRnJhbWVzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBjaGlsZHJlbjogX2NoaWxkcmVuLFxuICAgICAgICBmcm9tLFxuICAgICAgICBuYW1lLFxuICAgICAgICAuLi5wYXNzZWRQcm9wc1xuICAgICAgfSA9IGNhc3RlZENoaWxkLnByb3BzO1xuICAgICAgaWYgKGkgIT09IGZsYXR0ZW5lZENoaWxkcmVuLmxlbmd0aCAtIDEgfHwgZHVyYXRpb25JbkZyYW1lc1Byb3AgIT09IEluZmluaXR5KSB7XG4gICAgICAgIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzUHJvcCwge1xuICAgICAgICAgIGNvbXBvbmVudDogYG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRgLFxuICAgICAgICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0ID0gY2FzdGVkQ2hpbGQucHJvcHMub2Zmc2V0ID8/IDA7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwib2Zmc2V0XCIgcHJvcGVydHkgb2YgYSA8U2VyaWVzLlNlcXVlbmNlIC8+IG11c3Qgbm90IGJlIE5hTiwgYnV0IGdvdCBOYU4gKCR7ZGVidWdJbmZvfSkuYCk7XG4gICAgICB9XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIm9mZnNldFwiIHByb3BlcnR5IG9mIGEgPFNlcmllcy5TZXF1ZW5jZSAvPiBtdXN0IGJlIGZpbml0ZSwgYnV0IGdvdCAke29mZnNldH0gKCR7ZGVidWdJbmZvfSkuYCk7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ICUgMSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtvZmZzZXR9ICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudFN0YXJ0RnJhbWUgPSBzdGFydEZyYW1lICsgb2Zmc2V0O1xuICAgICAgc3RhcnRGcmFtZSArPSBkdXJhdGlvbkluRnJhbWVzUHJvcCArIG9mZnNldDtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoU2VxdWVuY2UsIHtcbiAgICAgICAgbmFtZTogbmFtZSB8fCBcIjxTZXJpZXMuU2VxdWVuY2U+XCIsXG4gICAgICAgIGZyb206IGN1cnJlbnRTdGFydEZyYW1lLFxuICAgICAgICBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzUHJvcCxcbiAgICAgICAgLi4ucGFzc2VkUHJvcHMsXG4gICAgICAgIHJlZjogY2FzdGVkQ2hpbGQucmVmLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBbcHJvcHMyLmNoaWxkcmVuXSk7XG4gIGlmIChFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUykge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzMoSXNJbnNpZGVTZXJpZXNDb250YWluZXIsIHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzMoU2VxdWVuY2UsIHtcbiAgICAgICAgLi4ucHJvcHMyLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5WYWx1ZVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeDMzKElzSW5zaWRlU2VyaWVzQ29udGFpbmVyLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuVmFsdWVcbiAgfSk7XG59O1xuU2VyaWVzLlNlcXVlbmNlID0gU2VyaWVzU2VxdWVuY2U7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKFNlcmllc1NlcXVlbmNlKTtcbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRpb24tc3ByaW5nLWR1cmF0aW9uLnRzXG52YXIgdmFsaWRhdGVTcHJpbmdEdXJhdGlvbiA9IChkdXIpID0+IHtcbiAgaWYgKHR5cGVvZiBkdXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBkdXIgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIGEgXCJudW1iZXJcIiBidXQgaXMgXCIke3R5cGVvZiBkdXJ9XCJgKTtcbiAgfVxuICBpZiAoTnVtYmVyLmlzTmFOKGR1cikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBpcyBOYU4sIHdoaWNoIGl0IG11c3Qgbm90IGJlJyk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgZmluaXRlLCBidXQgaXMgJyArIGR1cik7XG4gIH1cbiAgaWYgKGR1ciA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGlzICcgKyBkdXIpO1xuICB9XG59O1xuXG4vLyBzcmMvc3ByaW5nL3NwcmluZy11dGlscy50c1xudmFyIGRlZmF1bHRTcHJpbmdDb25maWcgPSB7XG4gIGRhbXBpbmc6IDEwLFxuICBtYXNzOiAxLFxuICBzdGlmZm5lc3M6IDEwMCxcbiAgb3ZlcnNob290Q2xhbXBpbmc6IGZhbHNlXG59O1xudmFyIGFkdmFuY2VDYWNoZSA9IHt9O1xuZnVuY3Rpb24gYWR2YW5jZSh7XG4gIGFuaW1hdGlvbixcbiAgbm93LFxuICBjb25maWdcbn0pIHtcbiAgY29uc3QgeyB0b1ZhbHVlLCBsYXN0VGltZXN0YW1wLCBjdXJyZW50LCB2ZWxvY2l0eSB9ID0gYW5pbWF0aW9uO1xuICBjb25zdCBkZWx0YVRpbWUgPSBNYXRoLm1pbihub3cgLSBsYXN0VGltZXN0YW1wLCA2NCk7XG4gIGlmIChjb25maWcuZGFtcGluZyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ByaW5nIGRhbXBpbmcgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCwgb3RoZXJ3aXNlIHRoZSBzcHJpbmcoKSBhbmltYXRpb24gd2lsbCBuZXZlciBlbmQsIGNhdXNpbmcgYW4gaW5maW5pdGUgbG9vcC5cIik7XG4gIH1cbiAgY29uc3QgYzIgPSBjb25maWcuZGFtcGluZztcbiAgY29uc3QgbSA9IGNvbmZpZy5tYXNzO1xuICBjb25zdCBrID0gY29uZmlnLnN0aWZmbmVzcztcbiAgY29uc3QgY2FjaGVLZXkgPSBbXG4gICAgdG9WYWx1ZSxcbiAgICBsYXN0VGltZXN0YW1wLFxuICAgIGN1cnJlbnQsXG4gICAgdmVsb2NpdHksXG4gICAgYzIsXG4gICAgbSxcbiAgICBrLFxuICAgIG5vd1xuICBdLmpvaW4oXCItXCIpO1xuICBpZiAoYWR2YW5jZUNhY2hlW2NhY2hlS2V5XSkge1xuICAgIHJldHVybiBhZHZhbmNlQ2FjaGVbY2FjaGVLZXldO1xuICB9XG4gIGNvbnN0IHYwID0gLXZlbG9jaXR5O1xuICBjb25zdCB4MCA9IHRvVmFsdWUgLSBjdXJyZW50O1xuICBjb25zdCB6ZXRhID0gYzIgLyAoMiAqIE1hdGguc3FydChrICogbSkpO1xuICBjb25zdCBvbWVnYTAgPSBNYXRoLnNxcnQoayAvIG0pO1xuICBjb25zdCBvbWVnYTEgPSBvbWVnYTAgKiBNYXRoLnNxcnQoMSAtIHpldGEgKiogMik7XG4gIGNvbnN0IHQgPSBkZWx0YVRpbWUgLyAxMDAwO1xuICBjb25zdCBzaW4xID0gTWF0aC5zaW4ob21lZ2ExICogdCk7XG4gIGNvbnN0IGNvczEgPSBNYXRoLmNvcyhvbWVnYTEgKiB0KTtcbiAgY29uc3QgdW5kZXJEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC16ZXRhICogb21lZ2EwICogdCk7XG4gIGNvbnN0IHVuZGVyRGFtcGVkRnJhZzEgPSB1bmRlckRhbXBlZEVudmVsb3BlICogKHNpbjEgKiAoKHYwICsgemV0YSAqIG9tZWdhMCAqIHgwKSAvIG9tZWdhMSkgKyB4MCAqIGNvczEpO1xuICBjb25zdCB1bmRlckRhbXBlZFBvc2l0aW9uID0gdG9WYWx1ZSAtIHVuZGVyRGFtcGVkRnJhZzE7XG4gIGNvbnN0IHVuZGVyRGFtcGVkVmVsb2NpdHkgPSB6ZXRhICogb21lZ2EwICogdW5kZXJEYW1wZWRGcmFnMSAtIHVuZGVyRGFtcGVkRW52ZWxvcGUgKiAoY29zMSAqICh2MCArIHpldGEgKiBvbWVnYTAgKiB4MCkgLSBvbWVnYTEgKiB4MCAqIHNpbjEpO1xuICBjb25zdCBjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUgPSBNYXRoLmV4cCgtb21lZ2EwICogdCk7XG4gIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRQb3NpdGlvbiA9IHRvVmFsdWUgLSBjcml0aWNhbGx5RGFtcGVkRW52ZWxvcGUgKiAoeDAgKyAodjAgKyBvbWVnYTAgKiB4MCkgKiB0KTtcbiAgY29uc3QgY3JpdGljYWxseURhbXBlZFZlbG9jaXR5ID0gY3JpdGljYWxseURhbXBlZEVudmVsb3BlICogKHYwICogKHQgKiBvbWVnYTAgLSAxKSArIHQgKiB4MCAqIG9tZWdhMCAqIG9tZWdhMCk7XG4gIGNvbnN0IGFuaW1hdGlvbk5vZGUgPSB7XG4gICAgdG9WYWx1ZSxcbiAgICBwcmV2UG9zaXRpb246IGN1cnJlbnQsXG4gICAgbGFzdFRpbWVzdGFtcDogbm93LFxuICAgIGN1cnJlbnQ6IHpldGEgPCAxID8gdW5kZXJEYW1wZWRQb3NpdGlvbiA6IGNyaXRpY2FsbHlEYW1wZWRQb3NpdGlvbixcbiAgICB2ZWxvY2l0eTogemV0YSA8IDEgPyB1bmRlckRhbXBlZFZlbG9jaXR5IDogY3JpdGljYWxseURhbXBlZFZlbG9jaXR5XG4gIH07XG4gIGFkdmFuY2VDYWNoZVtjYWNoZUtleV0gPSBhbmltYXRpb25Ob2RlO1xuICByZXR1cm4gYW5pbWF0aW9uTm9kZTtcbn1cbnZhciBjYWxjdWxhdGlvbkNhY2hlID0ge307XG5mdW5jdGlvbiBzcHJpbmdDYWxjdWxhdGlvbih7XG4gIGZyYW1lLFxuICBmcHMsXG4gIGNvbmZpZyA9IHt9XG59KSB7XG4gIGNvbnN0IGZyb20gPSAwO1xuICBjb25zdCB0byA9IDE7XG4gIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgIGZyYW1lLFxuICAgIGZwcyxcbiAgICBjb25maWcuZGFtcGluZyxcbiAgICBjb25maWcubWFzcyxcbiAgICBjb25maWcub3ZlcnNob290Q2xhbXBpbmcsXG4gICAgY29uZmlnLnN0aWZmbmVzc1xuICBdLmpvaW4oXCItXCIpO1xuICBpZiAoY2FsY3VsYXRpb25DYWNoZVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm4gY2FsY3VsYXRpb25DYWNoZVtjYWNoZUtleV07XG4gIH1cbiAgbGV0IGFuaW1hdGlvbiA9IHtcbiAgICBsYXN0VGltZXN0YW1wOiAwLFxuICAgIGN1cnJlbnQ6IGZyb20sXG4gICAgdG9WYWx1ZTogdG8sXG4gICAgdmVsb2NpdHk6IDAsXG4gICAgcHJldlBvc2l0aW9uOiAwXG4gIH07XG4gIGNvbnN0IGZyYW1lQ2xhbXBlZCA9IE1hdGgubWF4KDAsIGZyYW1lKTtcbiAgY29uc3QgdW5ldmVuUmVzdCA9IGZyYW1lQ2xhbXBlZCAlIDE7XG4gIGZvciAobGV0IGYgPSAwO2YgPD0gTWF0aC5mbG9vcihmcmFtZUNsYW1wZWQpOyBmKyspIHtcbiAgICBpZiAoZiA9PT0gTWF0aC5mbG9vcihmcmFtZUNsYW1wZWQpKSB7XG4gICAgICBmICs9IHVuZXZlblJlc3Q7XG4gICAgfVxuICAgIGNvbnN0IHRpbWUgPSBmIC8gZnBzICogMTAwMDtcbiAgICBhbmltYXRpb24gPSBhZHZhbmNlKHtcbiAgICAgIGFuaW1hdGlvbixcbiAgICAgIG5vdzogdGltZSxcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICAuLi5kZWZhdWx0U3ByaW5nQ29uZmlnLFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjYWxjdWxhdGlvbkNhY2hlW2NhY2hlS2V5XSA9IGFuaW1hdGlvbjtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn1cblxuLy8gc3JjL3NwcmluZy9tZWFzdXJlLXNwcmluZy50c1xudmFyIGNhY2hlID0gbmV3IE1hcDtcbmZ1bmN0aW9uIG1lYXN1cmVTcHJpbmcoe1xuICBmcHMsXG4gIGNvbmZpZyA9IHt9LFxuICB0aHJlc2hvbGQgPSAwLjAwNVxufSkge1xuICBpZiAodHlwZW9mIHRocmVzaG9sZCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRocmVzaG9sZCBtdXN0IGJlIGEgbnVtYmVyLCBnb3QgJHt0aHJlc2hvbGR9IG9mIHR5cGUgJHt0eXBlb2YgdGhyZXNob2xkfWApO1xuICB9XG4gIGlmICh0aHJlc2hvbGQgPT09IDApIHtcbiAgICByZXR1cm4gSW5maW5pdHk7XG4gIH1cbiAgaWYgKHRocmVzaG9sZCA9PT0gMSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChpc05hTih0aHJlc2hvbGQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRocmVzaG9sZCBpcyBOYU5cIik7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUodGhyZXNob2xkKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaHJlc2hvbGQgaXMgbm90IGZpbml0ZVwiKTtcbiAgfVxuICBpZiAodGhyZXNob2xkIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaHJlc2hvbGQgaXMgYmVsb3cgMFwiKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IFtcbiAgICBmcHMsXG4gICAgY29uZmlnLmRhbXBpbmcsXG4gICAgY29uZmlnLm1hc3MsXG4gICAgY29uZmlnLm92ZXJzaG9vdENsYW1waW5nLFxuICAgIGNvbmZpZy5zdGlmZm5lc3MsXG4gICAgdGhyZXNob2xkXG4gIF0uam9pbihcIi1cIik7XG4gIGlmIChjYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChjYWNoZUtleSk7XG4gIH1cbiAgdmFsaWRhdGVGcHMoZnBzLCBcInRvIHRoZSBtZWFzdXJlU3ByaW5nKCkgZnVuY3Rpb25cIiwgZmFsc2UpO1xuICBsZXQgZnJhbWUgPSAwO1xuICBsZXQgZmluaXNoZWRGcmFtZSA9IDA7XG4gIGNvbnN0IGNhbGMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHNwcmluZ0NhbGN1bGF0aW9uKHtcbiAgICAgIGZwcyxcbiAgICAgIGZyYW1lLFxuICAgICAgY29uZmlnXG4gICAgfSk7XG4gIH07XG4gIGxldCBhbmltYXRpb24gPSBjYWxjKCk7XG4gIGNvbnN0IGNhbGNEaWZmZXJlbmNlID0gKCkgPT4ge1xuICAgIHJldHVybiBNYXRoLmFicyhhbmltYXRpb24uY3VycmVudCAtIGFuaW1hdGlvbi50b1ZhbHVlKTtcbiAgfTtcbiAgbGV0IGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICB3aGlsZSAoZGlmZmVyZW5jZSA+PSB0aHJlc2hvbGQpIHtcbiAgICBmcmFtZSsrO1xuICAgIGFuaW1hdGlvbiA9IGNhbGMoKTtcbiAgICBkaWZmZXJlbmNlID0gY2FsY0RpZmZlcmVuY2UoKTtcbiAgfVxuICBmaW5pc2hlZEZyYW1lID0gZnJhbWU7XG4gIGZvciAobGV0IGkgPSAwO2kgPCAyMDsgaSsrKSB7XG4gICAgZnJhbWUrKztcbiAgICBhbmltYXRpb24gPSBjYWxjKCk7XG4gICAgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gICAgaWYgKGRpZmZlcmVuY2UgPj0gdGhyZXNob2xkKSB7XG4gICAgICBpID0gMDtcbiAgICAgIGZpbmlzaGVkRnJhbWUgPSBmcmFtZSArIDE7XG4gICAgfVxuICB9XG4gIGNhY2hlLnNldChjYWNoZUtleSwgZmluaXNoZWRGcmFtZSk7XG4gIHJldHVybiBmaW5pc2hlZEZyYW1lO1xufVxuXG4vLyBzcmMvc3ByaW5nL2luZGV4LnRzXG5mdW5jdGlvbiBzcHJpbmcoe1xuICBmcmFtZTogcGFzc2VkRnJhbWUsXG4gIGZwcyxcbiAgY29uZmlnID0ge30sXG4gIGZyb20gPSAwLFxuICB0byA9IDEsXG4gIGR1cmF0aW9uSW5GcmFtZXM6IHBhc3NlZER1cmF0aW9uSW5GcmFtZXMsXG4gIGR1cmF0aW9uUmVzdFRocmVzaG9sZCxcbiAgZGVsYXkgPSAwLFxuICByZXZlcnNlID0gZmFsc2Vcbn0pIHtcbiAgdmFsaWRhdGVTcHJpbmdEdXJhdGlvbihwYXNzZWREdXJhdGlvbkluRnJhbWVzKTtcbiAgdmFsaWRhdGVGcmFtZSh7XG4gICAgZnJhbWU6IHBhc3NlZEZyYW1lLFxuICAgIGR1cmF0aW9uSW5GcmFtZXM6IEluZmluaXR5LFxuICAgIGFsbG93RmxvYXRzOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZUZwcyhmcHMsIFwidG8gc3ByaW5nKClcIiwgZmFsc2UpO1xuICBjb25zdCBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID0gcmV2ZXJzZSB8fCB0eXBlb2YgcGFzc2VkRHVyYXRpb25JbkZyYW1lcyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgY29uc3QgbmF0dXJhbER1cmF0aW9uID0gbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvbiA/IG1lYXN1cmVTcHJpbmcoe1xuICAgIGZwcyxcbiAgICBjb25maWcsXG4gICAgdGhyZXNob2xkOiBkdXJhdGlvblJlc3RUaHJlc2hvbGRcbiAgfSkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IG5hdHVyYWxEdXJhdGlvbkdldHRlciA9IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb24gPyB7XG4gICAgZ2V0OiAoKSA9PiBuYXR1cmFsRHVyYXRpb25cbiAgfSA6IHtcbiAgICBnZXQ6ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRpZCBub3QgY2FsY3VsYXRlIG5hdHVyYWwgZHVyYXRpb24sIHRoaXMgaXMgYW4gZXJyb3Igd2l0aCBSZW1vdGlvbi4gUGxlYXNlIHJlcG9ydFwiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHJldmVyc2VQcm9jZXNzZWQgPSByZXZlcnNlID8gKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgPz8gbmF0dXJhbER1cmF0aW9uR2V0dGVyLmdldCgpKSAtIHBhc3NlZEZyYW1lIDogcGFzc2VkRnJhbWU7XG4gIGNvbnN0IGRlbGF5UHJvY2Vzc2VkID0gcmV2ZXJzZVByb2Nlc3NlZCArIChyZXZlcnNlID8gZGVsYXkgOiAtZGVsYXkpO1xuICBjb25zdCBkdXJhdGlvblByb2Nlc3NlZCA9IHBhc3NlZER1cmF0aW9uSW5GcmFtZXMgPT09IHVuZGVmaW5lZCA/IGRlbGF5UHJvY2Vzc2VkIDogZGVsYXlQcm9jZXNzZWQgLyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyAvIG5hdHVyYWxEdXJhdGlvbkdldHRlci5nZXQoKSk7XG4gIGlmIChwYXNzZWREdXJhdGlvbkluRnJhbWVzICYmIGRlbGF5UHJvY2Vzc2VkID4gcGFzc2VkRHVyYXRpb25JbkZyYW1lcykge1xuICAgIHJldHVybiB0bztcbiAgfVxuICBjb25zdCBzcHIgPSBzcHJpbmdDYWxjdWxhdGlvbih7XG4gICAgZnBzLFxuICAgIGZyYW1lOiBkdXJhdGlvblByb2Nlc3NlZCxcbiAgICBjb25maWdcbiAgfSk7XG4gIGNvbnN0IGlubmVyID0gY29uZmlnLm92ZXJzaG9vdENsYW1waW5nID8gdG8gPj0gZnJvbSA/IE1hdGgubWluKHNwci5jdXJyZW50LCB0bykgOiBNYXRoLm1heChzcHIuY3VycmVudCwgdG8pIDogc3ByLmN1cnJlbnQ7XG4gIGNvbnN0IGludGVycG9sYXRlZCA9IGZyb20gPT09IDAgJiYgdG8gPT09IDEgPyBpbm5lciA6IGludGVycG9sYXRlKGlubmVyLCBbMCwgMV0sIFtmcm9tLCB0b10pO1xuICByZXR1cm4gaW50ZXJwb2xhdGVkO1xufVxuLy8gc3JjL3N0YXRpYy1maWxlLnRzXG52YXIgcHJvYmxlbWF0aWNDaGFyYWN0ZXJzID0ge1xuICBcIiUzQVwiOiBcIjpcIixcbiAgXCIlMkZcIjogXCIvXCIsXG4gIFwiJTNGXCI6IFwiP1wiLFxuICBcIiUyM1wiOiBcIiNcIixcbiAgXCIlNUJcIjogXCJbXCIsXG4gIFwiJTVEXCI6IFwiXVwiLFxuICBcIiU0MFwiOiBcIkBcIixcbiAgXCIlMjFcIjogXCIhXCIsXG4gIFwiJTI0XCI6IFwiJFwiLFxuICBcIiUyNlwiOiBcIiZcIixcbiAgXCIlMjdcIjogXCInXCIsXG4gIFwiJTI4XCI6IFwiKFwiLFxuICBcIiUyOVwiOiBcIilcIixcbiAgXCIlMkFcIjogXCIqXCIsXG4gIFwiJTJCXCI6IFwiK1wiLFxuICBcIiUyQ1wiOiBcIixcIixcbiAgXCIlM0JcIjogXCI7XCJcbn07XG52YXIgZGlkV2FybjIgPSB7fTtcbnZhciB3YXJuT25jZTMgPSAobWVzc2FnZSkgPT4ge1xuICBpZiAoZGlkV2FybjJbbWVzc2FnZV0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICBkaWRXYXJuMlttZXNzYWdlXSA9IHRydWU7XG59O1xudmFyIGluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyID0gKHBhdGgpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJvYmxlbWF0aWNDaGFyYWN0ZXJzKSkge1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHJldHVybiB7IGNvbnRhaW5zSGV4OiB0cnVlLCBoZXhDb2RlOiBrZXkgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgY29udGFpbnNIZXg6IGZhbHNlIH07XG59O1xudmFyIHRyaW1MZWFkaW5nU2xhc2ggPSAocGF0aCkgPT4ge1xuICBpZiAocGF0aC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB0cmltTGVhZGluZ1NsYXNoKHBhdGguc3Vic3RyaW5nKDEpKTtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn07XG52YXIgaW5uZXIgPSAocGF0aCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgod2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB2YWx1ZSBcIiR7cGF0aH1cIiBpcyBhbHJlYWR5IHByZWZpeGVkIHdpdGggdGhlIHN0YXRpYyBiYXNlICR7d2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2V9LiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHN0YXRpY0ZpbGUoKSBvbiBpdC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3dpbmRvdy5yZW1vdGlvbl9zdGF0aWNCYXNlfS8ke3RyaW1MZWFkaW5nU2xhc2gocGF0aCl9YDtcbiAgfVxuICByZXR1cm4gYC8ke3RyaW1MZWFkaW5nU2xhc2gocGF0aCl9YDtcbn07XG52YXIgZW5jb2RlQnlTcGxpdHRpbmcgPSAocGF0aCkgPT4ge1xuICBjb25zdCBzcGxpdEJ5U2xhc2ggPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgY29uc3QgZW5jb2RlZEFycmF5ID0gc3BsaXRCeVNsYXNoLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZWxlbWVudCk7XG4gIH0pO1xuICBjb25zdCBtZXJnZWQgPSBlbmNvZGVkQXJyYXkuam9pbihcIi9cIik7XG4gIHJldHVybiBtZXJnZWQ7XG59O1xudmFyIHN0YXRpY0ZpbGUgPSAocGF0aCkgPT4ge1xuICBpZiAocGF0aCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJudWxsIHdhcyBwYXNzZWQgdG8gc3RhdGljRmlsZSgpXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bmRlZmluZWQgd2FzIHBhc3NlZCB0byBzdGF0aWNGaWxlKClcIik7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzdGF0aWNGaWxlKCkgZG9lcyBub3Qgc3VwcG9ydCByZW1vdGUgVVJMcyAtIGdvdCBcIiR7cGF0aH1cIi4gSW5zdGVhZCwgcGFzcyB0aGUgVVJMIHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gc3RhdGljRmlsZSgpLiBTZWU6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvc3RhdGljZmlsZS1yZW1vdGUtdXJsc2ApO1xuICB9XG4gIGlmIChwYXRoLnN0YXJ0c1dpdGgoXCIuLlwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIuL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IHJlbGF0aXZlIHBhdGhzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBuYW1lIG9mIGEgZmlsZSB0aGF0IGlzIGluc2lkZSB0aGUgcHVibGljLyBmb2xkZXIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gIH1cbiAgaWYgKHBhdGguc3RhcnRzV2l0aChcIi9Vc2Vyc1wiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvaG9tZVwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvdG1wXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIi9ldGNcIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiL29wdFwiKSB8fCBwYXRoLnN0YXJ0c1dpdGgoXCIvdmFyXCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIkM6XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIkQ6XCIpIHx8IHBhdGguc3RhcnRzV2l0aChcIkU6XCIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgYWJzb2x1dGUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBpZiAocGF0aC5zdGFydHNXaXRoKFwicHVibGljL1wiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYERvIG5vdCBpbmNsdWRlIHRoZSBwdWJsaWMvIHByZWZpeCB3aGVuIHVzaW5nIHN0YXRpY0ZpbGUoKSAtIGdvdCBcIiR7cGF0aH1cIi4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgfVxuICBjb25zdCBpbmNsdWRlc0hleCA9IGluY2x1ZGVzSGV4T2ZVbnNhZmVDaGFyKHBhdGgpO1xuICBpZiAoaW5jbHVkZXNIZXguY29udGFpbnNIZXgpIHtcbiAgICB3YXJuT25jZTMoYFdBUk5JTkc6IFlvdSBzZWVtIHRvIHBhc3MgYW4gYWxyZWFkeSBlbmNvZGVkIHBhdGggKHBhdGggY29udGFpbnMgJHtpbmNsdWRlc0hleC5oZXhDb2RlfSkuIFNpbmNlIFJlbW90aW9uIDQuMCwgdGhlIGVuY29kaW5nIGlzIGRvbmUgYnkgc3RhdGljRmlsZSgpIGl0c2VsZi4gWW91IG1heSB3YW50IHRvIHJlbW92ZSBhIGVuY29kZVVSSUNvbXBvbmVudCgpIHdyYXBwaW5nLmApO1xuICB9XG4gIGNvbnN0IHByZXByb2Nlc3NlZCA9IGVuY29kZUJ5U3BsaXR0aW5nKHBhdGgpO1xuICBjb25zdCBwcmVwYXJzZWQgPSBpbm5lcihwcmVwcm9jZXNzZWQpO1xuICBpZiAoIXByZXBhcnNlZC5zdGFydHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiBgLyR7cHJlcGFyc2VkfWA7XG4gIH1cbiAgcmV0dXJuIHByZXBhcnNlZDtcbn07XG4vLyBzcmMvU3RpbGwudHN4XG5pbXBvcnQgUmVhY3QzNCBmcm9tIFwicmVhY3RcIjtcbnZhciBTdGlsbCA9IChwcm9wczIpID0+IHtcbiAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgLi4ucHJvcHMyLFxuICAgIGR1cmF0aW9uSW5GcmFtZXM6IDEsXG4gICAgZnBzOiAxXG4gIH07XG4gIHJldHVybiBSZWFjdDM0LmNyZWF0ZUVsZW1lbnQoQ29tcG9zaXRpb24sIG5ld1Byb3BzKTtcbn07XG4vLyBzcmMvdmlkZW8vVmlkZW8udHN4XG5pbXBvcnQgeyBmb3J3YXJkUmVmIGFzIGZvcndhcmRSZWYxMiwgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2sxNywgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MzQgfSBmcm9tIFwicmVhY3RcIjtcblxuLy8gc3JjL3ZpZGVvL1ZpZGVvRm9yUmVuZGVyaW5nLnRzeFxuaW1wb3J0IHtcbiAgZm9yd2FyZFJlZiBhcyBmb3J3YXJkUmVmMTEsXG4gIHVzZUNvbnRleHQgYXMgdXNlQ29udGV4dDMzLFxuICB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MjIsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUgYXMgdXNlSW1wZXJhdGl2ZUhhbmRsZTEwLFxuICB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0MTAsXG4gIHVzZU1lbW8gYXMgdXNlTWVtbzMxLFxuICB1c2VSZWYgYXMgdXNlUmVmMTdcbn0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy92aWRlby9zZWVrLXVudGlsLXJpZ2h0LnRzXG52YXIgcm91bmRUbzZDb21tYXMgPSAobnVtKSA9PiB7XG4gIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDFlNSkgLyAxZTU7XG59O1xudmFyIHNlZWtUb1RpbWUgPSAoe1xuICBlbGVtZW50LFxuICBkZXNpcmVkVGltZSxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShlbGVtZW50LmN1cnJlbnRUaW1lLCBkZXNpcmVkVGltZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2FpdDogUHJvbWlzZS5yZXNvbHZlKGRlc2lyZWRUaW1lKSxcbiAgICAgIGNhbmNlbDogKCkgPT4ge31cbiAgICB9O1xuICB9XG4gIHNlZWsoe1xuICAgIGxvZ0xldmVsLFxuICAgIG1lZGlhUmVmOiBlbGVtZW50LFxuICAgIHRpbWU6IGRlc2lyZWRUaW1lLFxuICAgIHdoeTogXCJTZWVraW5nIGR1cmluZyByZW5kZXJpbmdcIixcbiAgICBtb3VudFRpbWVcbiAgfSk7XG4gIGxldCBjYW5jZWw7XG4gIGxldCBjYW5jZWxTZWVrZWQgPSBudWxsO1xuICBjb25zdCBwcm9tID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjYW5jZWwgPSBlbGVtZW50LnJlcXVlc3RWaWRlb0ZyYW1lQ2FsbGJhY2soKG5vdywgbWV0YWRhdGEpID0+IHtcbiAgICAgIGNvbnN0IGRpc3BsYXlJbiA9IG1ldGFkYXRhLmV4cGVjdGVkRGlzcGxheVRpbWUgLSBub3c7XG4gICAgICBpZiAoZGlzcGxheUluIDw9IDApIHtcbiAgICAgICAgcmVzb2x2ZShtZXRhZGF0YS5tZWRpYVRpbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShtZXRhZGF0YS5tZWRpYVRpbWUpO1xuICAgICAgfSwgZGlzcGxheUluICsgMTUwKTtcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IHdhaXRGb3JTZWVrZWRFdmVudCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgb25Eb25lID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uRG9uZSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNhbmNlbFNlZWtlZCA9ICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNlZWtlZFwiLCBvbkRvbmUpO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHdhaXQ6IFByb21pc2UuYWxsKFtwcm9tLCB3YWl0Rm9yU2Vla2VkRXZlbnRdKS50aGVuKChbdGltZV0pID0+IHRpbWUpLFxuICAgIGNhbmNlbDogKCkgPT4ge1xuICAgICAgY2FuY2VsU2Vla2VkPy4oKTtcbiAgICAgIGVsZW1lbnQuY2FuY2VsVmlkZW9GcmFtZUNhbGxiYWNrKGNhbmNlbCk7XG4gICAgfVxuICB9O1xufTtcbnZhciBzZWVrVG9UaW1lTXVsdGlwbGVVbnRpbFJpZ2h0ID0gKHtcbiAgZWxlbWVudCxcbiAgZGVzaXJlZFRpbWUsXG4gIGZwcyxcbiAgbG9nTGV2ZWwsXG4gIG1vdW50VGltZVxufSkgPT4ge1xuICBjb25zdCB0aHJlc2hvbGQgPSAxIC8gZnBzIC8gMjtcbiAgbGV0IGN1cnJlbnRDYW5jZWwgPSAoKSA9PiB7XG4gICAgcmV0dXJuO1xuICB9O1xuICBpZiAoTnVtYmVyLmlzRmluaXRlKGVsZW1lbnQuZHVyYXRpb24pICYmIGVsZW1lbnQuY3VycmVudFRpbWUgPj0gZWxlbWVudC5kdXJhdGlvbiAmJiBkZXNpcmVkVGltZSA+PSBlbGVtZW50LmR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb206IFByb21pc2UucmVzb2x2ZSgpLFxuICAgICAgY2FuY2VsOiAoKSA9PiB7fVxuICAgIH07XG4gIH1cbiAgY29uc3QgcHJvbSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmaXJzdFNlZWsgPSBzZWVrVG9UaW1lKHtcbiAgICAgIGVsZW1lbnQsXG4gICAgICBkZXNpcmVkVGltZTogZGVzaXJlZFRpbWUgKyB0aHJlc2hvbGQsXG4gICAgICBsb2dMZXZlbCxcbiAgICAgIG1vdW50VGltZVxuICAgIH0pO1xuICAgIGZpcnN0U2Vlay53YWl0LnRoZW4oKHNlZWtlZFRvKSA9PiB7XG4gICAgICBjb25zdCBkaWZmZXJlbmNlID0gTWF0aC5hYnMoZGVzaXJlZFRpbWUgLSBzZWVrZWRUbyk7XG4gICAgICBpZiAoZGlmZmVyZW5jZSA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpZ24gPSBkZXNpcmVkVGltZSA+IHNlZWtlZFRvID8gMSA6IC0xO1xuICAgICAgY29uc3QgbmV3U2VlayA9IHNlZWtUb1RpbWUoe1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBkZXNpcmVkVGltZTogc2Vla2VkVG8gKyB0aHJlc2hvbGQgKiBzaWduLFxuICAgICAgICBsb2dMZXZlbCxcbiAgICAgICAgbW91bnRUaW1lXG4gICAgICB9KTtcbiAgICAgIGN1cnJlbnRDYW5jZWwgPSBuZXdTZWVrLmNhbmNlbDtcbiAgICAgIG5ld1NlZWsud2FpdC50aGVuKChuZXdUaW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0RpZmZlcmVuY2UgPSBNYXRoLmFicyhkZXNpcmVkVGltZSAtIG5ld1RpbWUpO1xuICAgICAgICBpZiAocm91bmRUbzZDb21tYXMobmV3RGlmZmVyZW5jZSkgPD0gcm91bmRUbzZDb21tYXModGhyZXNob2xkKSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhpcmRTZWVrID0gc2Vla1RvVGltZSh7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBkZXNpcmVkVGltZTogZGVzaXJlZFRpbWUgKyB0aHJlc2hvbGQsXG4gICAgICAgICAgbG9nTGV2ZWwsXG4gICAgICAgICAgbW91bnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICBjdXJyZW50Q2FuY2VsID0gdGhpcmRTZWVrLmNhbmNlbDtcbiAgICAgICAgcmV0dXJuIHRoaXJkU2Vlay53YWl0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdXJyZW50Q2FuY2VsID0gZmlyc3RTZWVrLmNhbmNlbDtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcHJvbSxcbiAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgIGN1cnJlbnRDYW5jZWwoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvdmlkZW8vVmlkZW9Gb3JSZW5kZXJpbmcudHN4XG5pbXBvcnQgeyBqc3ggYXMganN4MzQgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbnZhciBWaWRlb0ZvclJlbmRlcmluZ0ZvcndhcmRGdW5jdGlvbiA9ICh7XG4gIG9uRXJyb3IsXG4gIHZvbHVtZTogdm9sdW1lUHJvcCxcbiAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICBwbGF5YmFja1JhdGUsXG4gIG9uRHVyYXRpb24sXG4gIHRvbmVGcmVxdWVuY3ksXG4gIG5hbWUsXG4gIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMsXG4gIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgZGVsYXlSZW5kZXJUaW1lb3V0SW5NaWxsaXNlY29uZHMsXG4gIGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yLFxuICBhdWRpb1N0cmVhbUluZGV4LFxuICAuLi5wcm9wczJcbn0sIHJlZikgPT4ge1xuICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKGxvb3BWb2x1bWVDdXJ2ZUJlaGF2aW9yID8/IFwicmVwZWF0XCIpO1xuICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmMTcobnVsbCk7XG4gIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQzMyhTZXF1ZW5jZUNvbnRleHQpO1xuICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgbG9nTGV2ZWwgPSB1c2VMb2dMZXZlbCgpO1xuICBjb25zdCBtb3VudFRpbWUgPSB1c2VNb3VudFRpbWUoKTtcbiAgY29uc3QgeyBkZWxheVJlbmRlcjogZGVsYXlSZW5kZXIyLCBjb250aW51ZVJlbmRlcjogY29udGludWVSZW5kZXIyIH0gPSB1c2VEZWxheVJlbmRlcigpO1xuICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dDMzKFJlbmRlckFzc2V0TWFuYWdlcik7XG4gIGNvbnN0IGlkID0gdXNlTWVtbzMxKCgpID0+IGB2aWRlby0ke3JhbmRvbShwcm9wczIuc3JjID8/IFwiXCIpfS0ke3NlcXVlbmNlQ29udGV4dD8uY3VtdWxhdGVkRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQ/LmR1cmF0aW9uSW5GcmFtZXN9YCwgW1xuICAgIHByb3BzMi5zcmMsXG4gICAgc2VxdWVuY2VDb250ZXh0Py5jdW11bGF0ZWRGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tLFxuICAgIHNlcXVlbmNlQ29udGV4dD8uZHVyYXRpb25JbkZyYW1lc1xuICBdKTtcbiAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZpZGVvIGNvbmZpZyBmb3VuZFwiKTtcbiAgfVxuICBjb25zdCB2b2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgdm9sdW1lOiB2b2x1bWVQcm9wLFxuICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgIG1lZGlhVm9sdW1lOiAxXG4gIH0pO1xuICB3YXJuQWJvdXRUb29IaWdoVm9sdW1lKHZvbHVtZSk7XG4gIHVzZUVmZmVjdDIyKCgpID0+IHtcbiAgICBpZiAoIXByb3BzMi5zcmMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNyYyBwYXNzZWRcIik7XG4gICAgfVxuICAgIGlmIChwcm9wczIubXV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghd2luZG93LnJlbW90aW9uX2F1ZGlvRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIHNyYzogZ2V0QWJzb2x1dGVTcmMocHJvcHMyLnNyYyksXG4gICAgICBpZCxcbiAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgdm9sdW1lLFxuICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSA/PyAxLFxuICAgICAgdG9uZUZyZXF1ZW5jeTogdG9uZUZyZXF1ZW5jeSA/PyAxLFxuICAgICAgYXVkaW9TdGFydEZyYW1lOiBNYXRoLm1heCgwLCAtKHNlcXVlbmNlQ29udGV4dD8ucmVsYXRpdmVGcm9tID8/IDApKSxcbiAgICAgIGF1ZGlvU3RyZWFtSW5kZXg6IGF1ZGlvU3RyZWFtSW5kZXggPz8gMFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQoaWQpO1xuICB9LCBbXG4gICAgcHJvcHMyLm11dGVkLFxuICAgIHByb3BzMi5zcmMsXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICBpZCxcbiAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgdm9sdW1lLFxuICAgIGZyYW1lLFxuICAgIGFic29sdXRlRnJhbWUsXG4gICAgcGxheWJhY2tSYXRlLFxuICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgc2VxdWVuY2VDb250ZXh0Py5yZWxhdGl2ZUZyb20sXG4gICAgYXVkaW9TdHJlYW1JbmRleFxuICBdKTtcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTEwKHJlZiwgKCkgPT4ge1xuICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdDIyKCgpID0+IHtcbiAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgICAgZnJhbWUsXG4gICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlID0gZGVsYXlSZW5kZXIyKGBSZW5kZXJpbmcgPEh0bWw1VmlkZW8gLz4gd2l0aCBzcmM9XCIke3Byb3BzMi5zcmN9XCIgYXQgdGltZSAke2N1cnJlbnRUaW1lfWAsIHtcbiAgICAgIHJldHJpZXM6IGRlbGF5UmVuZGVyUmV0cmllcyA/PyB1bmRlZmluZWQsXG4gICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIGlmICh3aW5kb3cucHJvY2Vzcz8uZW52Py5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNBcHByb3hpbWF0ZWx5VGhlU2FtZShjdXJyZW50LmN1cnJlbnRUaW1lLCBjdXJyZW50VGltZSkpIHtcbiAgICAgIGlmIChjdXJyZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbG9hZGVkRGF0YUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihoYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgbG9hZGVkRGF0YUhhbmRsZXIpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZW5kZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWVrMiA9IHNlZWtUb1RpbWVNdWx0aXBsZVVudGlsUmlnaHQoe1xuICAgICAgZWxlbWVudDogY3VycmVudCxcbiAgICAgIGRlc2lyZWRUaW1lOiBjdXJyZW50VGltZSxcbiAgICAgIGZwczogdmlkZW9Db25maWcuZnBzLFxuICAgICAgbG9nTGV2ZWwsXG4gICAgICBtb3VudFRpbWVcbiAgICB9KTtcbiAgICBzZWVrMi5wcm9tLnRoZW4oKCkgPT4ge1xuICAgICAgY29udGludWVSZW5kZXIyKGhhbmRsZSk7XG4gICAgfSk7XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKGN1cnJlbnQ/LmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBvY2N1cnJlZCBpbiB2aWRlb1wiLCBjdXJyZW50Py5lcnJvcik7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3Igd2hpbGUgcGxheWluZyB0aGUgdmlkZW8gJHtwcm9wczIuc3JjfTogQ29kZSAke2N1cnJlbnQuZXJyb3IuY29kZX0gLSAke2N1cnJlbnQ/LmVycm9yPy5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBicm93c2VyIHRocmV3IGFuIGVycm9yXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZXJyb3JIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNlZWsyLmNhbmNlbCgpO1xuICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgZW5kZWRIYW5kbGVyKTtcbiAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICBjb250aW51ZVJlbmRlcjIoaGFuZGxlKTtcbiAgICB9O1xuICB9LCBbXG4gICAgdm9sdW1lUHJvcHNGcmFtZSxcbiAgICBwcm9wczIuc3JjLFxuICAgIHBsYXliYWNrUmF0ZSxcbiAgICB2aWRlb0NvbmZpZy5mcHMsXG4gICAgZnJhbWUsXG4gICAgbWVkaWFTdGFydHNBdCxcbiAgICBvbkVycm9yLFxuICAgIGRlbGF5UmVuZGVyUmV0cmllcyxcbiAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICBsb2dMZXZlbCxcbiAgICBtb3VudFRpbWUsXG4gICAgY29udGludWVSZW5kZXIyLFxuICAgIGRlbGF5UmVuZGVyMlxuICBdKTtcbiAgY29uc3QgeyBzcmMgfSA9IHByb3BzMjtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgdXNlTGF5b3V0RWZmZWN0MTAoKCkgPT4ge1xuICAgICAgaWYgKHdpbmRvdy5wcm9jZXNzPy5lbnY/Lk5PREVfRU5WID09PSBcInRlc3RcIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcjIoXCJMb2FkaW5nIDxIdG1sNVZpZGVvPiBkdXJhdGlvbiB3aXRoIHNyYz1cIiArIHNyYywge1xuICAgICAgICByZXRyaWVzOiBkZWxheVJlbmRlclJldHJpZXMgPz8gdW5kZWZpbmVkLFxuICAgICAgICB0aW1lb3V0SW5NaWxsaXNlY29uZHM6IGRlbGF5UmVuZGVyVGltZW91dEluTWlsbGlzZWNvbmRzID8/IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgICAgY29uc3QgZGlkTG9hZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/LmR1cmF0aW9uKSB7XG4gICAgICAgICAgb25EdXJhdGlvbihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfTtcbiAgICAgIGlmIChjdXJyZW50Py5kdXJhdGlvbikge1xuICAgICAgICBvbkR1cmF0aW9uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyMihuZXdIYW5kbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIGRpZExvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGN1cnJlbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCBkaWRMb2FkKTtcbiAgICAgICAgY29udGludWVSZW5kZXIyKG5ld0hhbmRsZSk7XG4gICAgICB9O1xuICAgIH0sIFtcbiAgICAgIHNyYyxcbiAgICAgIG9uRHVyYXRpb24sXG4gICAgICBkZWxheVJlbmRlclJldHJpZXMsXG4gICAgICBkZWxheVJlbmRlclRpbWVvdXRJbk1pbGxpc2Vjb25kcyxcbiAgICAgIGNvbnRpbnVlUmVuZGVyMixcbiAgICAgIGRlbGF5UmVuZGVyMlxuICAgIF0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzQoXCJ2aWRlb1wiLCB7XG4gICAgcmVmOiB2aWRlb1JlZixcbiAgICBkaXNhYmxlUmVtb3RlUGxheWJhY2s6IHRydWUsXG4gICAgLi4ucHJvcHMyXG4gIH0pO1xufTtcbnZhciBWaWRlb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWYxMShWaWRlb0ZvclJlbmRlcmluZ0ZvcndhcmRGdW5jdGlvbik7XG5cbi8vIHNyYy92aWRlby9WaWRlby50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gzNSB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xudmFyIFZpZGVvRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzMiwgcmVmKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXIsXG4gICAgbmFtZSxcbiAgICBwYXVzZVdoZW5CdWZmZXJpbmcsXG4gICAgc3RhY2ssXG4gICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkLFxuICAgIHNob3dJblRpbWVsaW5lLFxuICAgIG9uQXV0b1BsYXlFcnJvcixcbiAgICAuLi5vdGhlclByb3BzXG4gIH0gPSBwcm9wczI7XG4gIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wczI7XG4gIGNvbnN0IHsgZnBzIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICBjb25zdCBlbnZpcm9ubWVudCA9IHVzZVJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgY29uc3QgeyBkdXJhdGlvbnMsIHNldER1cmF0aW9ucyB9ID0gdXNlQ29udGV4dDM0KER1cmF0aW9uc0NvbnRleHQpO1xuICBpZiAodHlwZW9mIHJlZiA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN0cmluZyByZWZzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvcHMyLnNyYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcXGA8SHRtbDVWaWRlbz5cXGAgdGFnIHJlcXVpcmVzIGEgc3RyaW5nIGZvciBcXGBzcmNcXGAsIGJ1dCBnb3QgJHtKU09OLnN0cmluZ2lmeShwcm9wczIuc3JjKX0gaW5zdGVhZC5gKTtcbiAgfVxuICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHByb3BzMi5zcmMpO1xuICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2sxNygoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgIHNldER1cmF0aW9ucyh7IHR5cGU6IFwiZ290LWR1cmF0aW9uXCIsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gIH0sIFtzZXREdXJhdGlvbnNdKTtcbiAgY29uc3Qgb25WaWRlb0ZyYW1lID0gdXNlQ2FsbGJhY2sxNygoKSA9PiB7fSwgW10pO1xuICBjb25zdCBkdXJhdGlvbkZldGNoZWQgPSBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJlbG9hZGVkU3JjKV0gPz8gZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByb3BzMi5zcmMpXTtcbiAgdmFsaWRhdGVNZWRpYVRyaW1Qcm9wcyh7IHN0YXJ0RnJvbSwgZW5kQXQsIHRyaW1CZWZvcmUsIHRyaW1BZnRlciB9KTtcbiAgY29uc3QgeyB0cmltQmVmb3JlVmFsdWUsIHRyaW1BZnRlclZhbHVlIH0gPSByZXNvbHZlVHJpbVByb3BzKHtcbiAgICBzdGFydEZyb20sXG4gICAgZW5kQXQsXG4gICAgdHJpbUJlZm9yZSxcbiAgICB0cmltQWZ0ZXJcbiAgfSk7XG4gIGlmIChsb29wICYmIGR1cmF0aW9uRmV0Y2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25GZXRjaGVkKSkge1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNShIdG1sNVZpZGVvLCB7XG4gICAgICAgIC4uLnByb3BzT3RoZXJUaGFuTG9vcCxcbiAgICAgICAgcmVmLFxuICAgICAgICBfcmVtb3Rpb25JbnRlcm5hbE5hdGl2ZUxvb3BQYXNzZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZWRpYUR1cmF0aW9uID0gZHVyYXRpb25GZXRjaGVkICogZnBzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzUoTG9vcCwge1xuICAgICAgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTWVkaWFEdXJhdGlvbih7XG4gICAgICAgIHRyaW1BZnRlcjogdHJpbUFmdGVyVmFsdWUsXG4gICAgICAgIG1lZGlhRHVyYXRpb25JbkZyYW1lczogbWVkaWFEdXJhdGlvbixcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwcm9wczIucGxheWJhY2tSYXRlID8/IDEsXG4gICAgICAgIHRyaW1CZWZvcmU6IHRyaW1CZWZvcmVWYWx1ZVxuICAgICAgfSksXG4gICAgICBsYXlvdXQ6IFwibm9uZVwiLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzUoSHRtbDVWaWRlbywge1xuICAgICAgICAuLi5wcm9wc090aGVyVGhhbkxvb3AsXG4gICAgICAgIHJlZixcbiAgICAgICAgX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkOiB0cnVlXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgdHJpbUJlZm9yZVZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiB0cmltQWZ0ZXJWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MzUoU2VxdWVuY2UsIHtcbiAgICAgIGxheW91dDogXCJub25lXCIsXG4gICAgICBmcm9tOiAwIC0gKHRyaW1CZWZvcmVWYWx1ZSA/PyAwKSxcbiAgICAgIHNob3dJblRpbWVsaW5lOiBmYWxzZSxcbiAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IHRyaW1BZnRlclZhbHVlLFxuICAgICAgbmFtZSxcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MzUoSHRtbDVWaWRlbywge1xuICAgICAgICBwYXVzZVdoZW5CdWZmZXJpbmc6IHBhdXNlV2hlbkJ1ZmZlcmluZyA/PyBmYWxzZSxcbiAgICAgICAgLi4ub3RoZXJQcm9wcyxcbiAgICAgICAgcmVmXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHZhbGlkYXRlTWVkaWFQcm9wcyh7IHBsYXliYWNrUmF0ZTogcHJvcHMyLnBsYXliYWNrUmF0ZSwgdm9sdW1lOiBwcm9wczIudm9sdW1lIH0sIFwiSHRtbDVWaWRlb1wiKTtcbiAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNShWaWRlb0ZvclJlbmRlcmluZywge1xuICAgICAgb25EdXJhdGlvbixcbiAgICAgIG9uVmlkZW9GcmFtZTogb25WaWRlb0ZyYW1lID8/IG51bGwsXG4gICAgICAuLi5vdGhlclByb3BzLFxuICAgICAgcmVmXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gzNShWaWRlb0ZvclByZXZpZXcsIHtcbiAgICBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSxcbiAgICAuLi5vdGhlclByb3BzLFxuICAgIHJlZixcbiAgICBvblZpZGVvRnJhbWU6IG51bGwsXG4gICAgcGF1c2VXaGVuQnVmZmVyaW5nOiBwYXVzZVdoZW5CdWZmZXJpbmcgPz8gZmFsc2UsXG4gICAgb25EdXJhdGlvbixcbiAgICBfcmVtb3Rpb25JbnRlcm5hbFN0YWNrOiBzdGFjayA/PyBudWxsLFxuICAgIF9yZW1vdGlvbkludGVybmFsTmF0aXZlTG9vcFBhc3NlZDogX3JlbW90aW9uSW50ZXJuYWxOYXRpdmVMb29wUGFzc2VkID8/IGZhbHNlLFxuICAgIHNob3dJblRpbWVsaW5lOiBzaG93SW5UaW1lbGluZSA/PyB0cnVlLFxuICAgIG9uQXV0b1BsYXlFcnJvcjogb25BdXRvUGxheUVycm9yID8/IHVuZGVmaW5lZFxuICB9KTtcbn07XG52YXIgSHRtbDVWaWRlbyA9IGZvcndhcmRSZWYxMihWaWRlb0ZvcndhcmRpbmdGdW5jdGlvbik7XG5hZGRTZXF1ZW5jZVN0YWNrVHJhY2VzKEh0bWw1VmlkZW8pO1xudmFyIFZpZGVvID0gSHRtbDVWaWRlbztcbi8vIHNyYy9pbmRleC50c1xuY2hlY2tNdWx0aXBsZVJlbW90aW9uVmVyc2lvbnMoKTtcbnZhciBFeHBlcmltZW50YWwgPSB7XG4gIENsaXBwZXIsXG4gIE51bGwsXG4gIHVzZUlzUGxheWVyXG59O1xudmFyIHByb3h5T2JqID0ge307XG52YXIgQ29uZmlnID0gbmV3IFByb3h5KHByb3h5T2JqLCB7XG4gIGdldChfLCBwcm9wKSB7XG4gICAgaWYgKHByb3AgPT09IFwiQnVuZGxpbmdcIiB8fCBwcm9wID09PSBcIlJlbmRlcmluZ1wiIHx8IHByb3AgPT09IFwiTG9nXCIgfHwgcHJvcCA9PT0gXCJQdXBwZXRlZXJcIiB8fCBwcm9wID09PSBcIk91dHB1dFwiKSB7XG4gICAgICByZXR1cm4gQ29uZmlnO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFwi4pqg77iPICBUaGUgQ0xJIGNvbmZpZ3VyYXRpb24gaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gUmVtb3Rpb24gQ29yZS5cIik7XG4gICAgICBjb25zb2xlLndhcm4oXCJVcGRhdGUgdGhlIGltcG9ydCBmcm9tIHRoZSBjb25maWcgZmlsZTpcIik7XG4gICAgICBjb25zb2xlLndhcm4oKTtcbiAgICAgIGNvbnNvbGUud2FybihcIi0gRGVsZXRlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJyZW1vdGlvblwiOycpO1xuICAgICAgY29uc29sZS53YXJuKFwiKyBSZXBsYWNlOlwiKTtcbiAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJAcmVtb3Rpb24vY2xpL2NvbmZpZ1wiOycpO1xuICAgICAgY29uc29sZS53YXJuKCk7XG4gICAgICBjb25zb2xlLndhcm4oXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzLzQtMC1taWdyYXRpb24uXCIpO1xuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH07XG4gIH1cbn0pO1xuYWRkU2VxdWVuY2VTdGFja1RyYWNlcyhTZXF1ZW5jZSk7XG5leHBvcnQge1xuICB3YXRjaFN0YXRpY0ZpbGUsXG4gIHVzZVZpZGVvQ29uZmlnLFxuICB1c2VSZW1vdGlvbkVudmlyb25tZW50LFxuICB1c2VEZWxheVJlbmRlcixcbiAgdXNlQ3VycmVudFNjYWxlLFxuICB1c2VDdXJyZW50RnJhbWUsXG4gIHVzZUJ1ZmZlclN0YXRlLFxuICBzdGF0aWNGaWxlLFxuICBzcHJpbmcsXG4gIHJlZ2lzdGVyUm9vdCxcbiAgcmFuZG9tLFxuICBwcmVmZXRjaCxcbiAgbWVhc3VyZVNwcmluZyxcbiAgaW50ZXJwb2xhdGVDb2xvcnMsXG4gIGludGVycG9sYXRlLFxuICBnZXRTdGF0aWNGaWxlcyxcbiAgZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCxcbiAgZ2V0SW5wdXRQcm9wcyxcbiAgZGVsYXlSZW5kZXIsXG4gIGNvbnRpbnVlUmVuZGVyLFxuICBjYW5jZWxSZW5kZXIsXG4gIFZpZGVvLFxuICBWRVJTSU9OLFxuICBTdGlsbCxcbiAgU2VyaWVzLFxuICBTZXF1ZW5jZSxcbiAgT2ZmdGhyZWFkVmlkZW8sXG4gIExvb3AsXG4gIEludGVybmFscyxcbiAgSW1nLFxuICBJRnJhbWUsXG4gIEh0bWw1VmlkZW8sXG4gIEh0bWw1QXVkaW8sXG4gIEZyZWV6ZSxcbiAgRm9sZGVyQ29udGV4dCxcbiAgRm9sZGVyLFxuICBFeHBlcmltZW50YWwsXG4gIEVhc2luZyxcbiAgQ29uZmlnLFxuICBDb21wb3NpdGlvbixcbiAgQXVkaW8sXG4gIEFydGlmYWN0LFxuICBBbmltYXRlZEltYWdlLFxuICBBYnNvbHV0ZUZpbGxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/remotion/dist/esm/no-react.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/remotion/dist/esm/no-react.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoReactInternals: () => (/* binding */ NoReactInternals),\n/* harmony export */   interpolate: () => (/* binding */ interpolate),\n/* harmony export */   random: () => (/* binding */ random)\n/* harmony export */ });\n// src/interpolate.ts\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n  const { extrapolateLeft, extrapolateRight, easing } = options;\n  let result = input;\n  const [inputMin, inputMax] = inputRange;\n  const [outputMin, outputMax] = outputRange;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\") {\n      return result;\n    }\n    if (extrapolateLeft === \"clamp\") {\n      result = inputMin;\n    } else if (extrapolateLeft === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateLeft === \"extend\") {}\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\") {\n      return result;\n    }\n    if (extrapolateRight === \"clamp\") {\n      result = inputMax;\n    } else if (extrapolateRight === \"wrap\") {\n      const range = inputMax - inputMin;\n      result = ((result - inputMin) % range + range) % range + inputMin;\n    } else if (extrapolateRight === \"extend\") {}\n  }\n  if (outputMin === outputMax) {\n    return outputMin;\n  }\n  result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  let i;\n  for (i = 1;i < inputRange.length - 1; ++i) {\n    if (inputRange[i] >= input) {\n      break;\n    }\n  }\n  return i - 1;\n}\nfunction checkValidInputRange(arr) {\n  for (let i = 1;i < arr.length; ++i) {\n    if (!(arr[i] > arr[i - 1])) {\n      throw new Error(`inputRange must be strictly monotonically increasing but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction checkInfiniteRange(name, arr) {\n  if (arr.length < 2) {\n    throw new Error(name + \" must have at least 2 elements\");\n  }\n  for (const element of arr) {\n    if (typeof element !== \"number\") {\n      throw new Error(`${name} must contain only numbers`);\n    }\n    if (!Number.isFinite(element)) {\n      throw new Error(`${name} must contain only finite numbers, but got [${arr.join(\",\")}]`);\n    }\n  }\n}\nfunction interpolate(input, inputRange, outputRange, options) {\n  if (typeof input === \"undefined\") {\n    throw new Error(\"input can not be undefined\");\n  }\n  if (typeof inputRange === \"undefined\") {\n    throw new Error(\"inputRange can not be undefined\");\n  }\n  if (typeof outputRange === \"undefined\") {\n    throw new Error(\"outputRange can not be undefined\");\n  }\n  if (inputRange.length !== outputRange.length) {\n    throw new Error(\"inputRange (\" + inputRange.length + \") and outputRange (\" + outputRange.length + \") must have the same length\");\n  }\n  checkInfiniteRange(\"inputRange\", inputRange);\n  checkInfiniteRange(\"outputRange\", outputRange);\n  checkValidInputRange(inputRange);\n  const easing = options?.easing ?? ((num) => num);\n  let extrapolateLeft = \"extend\";\n  if (options?.extrapolateLeft !== undefined) {\n    extrapolateLeft = options.extrapolateLeft;\n  }\n  let extrapolateRight = \"extend\";\n  if (options?.extrapolateRight !== undefined) {\n    extrapolateRight = options.extrapolateRight;\n  }\n  if (typeof input !== \"number\") {\n    throw new TypeError(\"Cannot interpolate an input which is not a number\");\n  }\n  const range = findRange(input, inputRange);\n  return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n    easing,\n    extrapolateLeft,\n    extrapolateRight\n  });\n}\n// src/random.ts\nfunction mulberry32(a) {\n  let t = a + 1831565813;\n  t = Math.imul(t ^ t >>> 15, t | 1);\n  t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n  return ((t ^ t >>> 14) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n  let i = 0;\n  let chr = 0;\n  let hash = 0;\n  for (i = 0;i < str.length; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0;\n  }\n  return hash;\n}\nvar random = (seed, dummy) => {\n  if (dummy !== undefined) {\n    throw new TypeError(\"random() takes only one argument\");\n  }\n  if (seed === null) {\n    return Math.random();\n  }\n  if (typeof seed === \"string\") {\n    return mulberry32(hashCode(seed));\n  }\n  if (typeof seed === \"number\") {\n    return mulberry32(seed * 10000000000);\n  }\n  throw new Error(\"random() argument must be a number or a string\");\n};\n// src/truthy.ts\nfunction truthy(value) {\n  return Boolean(value);\n}\n\n// src/delay-render.ts\nif (typeof window !== \"undefined\") {\n  window.remotion_renderReady = false;\n  if (!window.remotion_delayRenderTimeouts) {\n    window.remotion_delayRenderTimeouts = {};\n  }\n}\nvar DELAY_RENDER_CALLSTACK_TOKEN = \"The delayRender was called:\";\nvar DELAY_RENDER_RETRIES_LEFT = \"Retries left: \";\nvar DELAY_RENDER_RETRY_TOKEN = \"- Rendering the frame will be retried.\";\nvar DELAY_RENDER_CLEAR_TOKEN = \"handle was cleared after\";\n\n// src/input-props-serialization.ts\nvar DATE_TOKEN = \"remotion-date:\";\nvar FILE_TOKEN = \"remotion-file:\";\nvar serializeJSONWithSpecialTypes = ({\n  data,\n  indent,\n  staticBase\n}) => {\n  let customDateUsed = false;\n  let customFileUsed = false;\n  let mapUsed = false;\n  let setUsed = false;\n  try {\n    const serializedString = JSON.stringify(data, function(key, value) {\n      const item = this[key];\n      if (item instanceof Date) {\n        customDateUsed = true;\n        return `${DATE_TOKEN}${item.toISOString()}`;\n      }\n      if (item instanceof Map) {\n        mapUsed = true;\n        return value;\n      }\n      if (item instanceof Set) {\n        setUsed = true;\n        return value;\n      }\n      if (typeof item === \"string\" && staticBase !== null && item.startsWith(staticBase)) {\n        customFileUsed = true;\n        return `${FILE_TOKEN}${item.replace(staticBase + \"/\", \"\")}`;\n      }\n      return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n  } catch (err) {\n    throw new Error(\"Could not serialize the passed input props to JSON: \" + err.message);\n  }\n};\nvar deserializeJSONWithSpecialTypes = (data) => {\n  return JSON.parse(data, (_, value) => {\n    if (typeof value === \"string\" && value.startsWith(DATE_TOKEN)) {\n      return new Date(value.replace(DATE_TOKEN, \"\"));\n    }\n    if (typeof value === \"string\" && value.startsWith(FILE_TOKEN)) {\n      return `${window.remotion_staticBase}/${value.replace(FILE_TOKEN, \"\")}`;\n    }\n    return value;\n  });\n};\n\n// src/interpolate-colors.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...args) {\n  return \"\\\\(\\\\s*(\" + args.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nfunction getMatchers() {\n  const cachedMatchers = {\n    rgb: undefined,\n    rgba: undefined,\n    hsl: undefined,\n    hsla: undefined,\n    hex3: undefined,\n    hex4: undefined,\n    hex5: undefined,\n    hex6: undefined,\n    hex8: undefined\n  };\n  if (cachedMatchers.rgb === undefined) {\n    cachedMatchers.rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\n    cachedMatchers.rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\n    cachedMatchers.hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\n    cachedMatchers.hsla = new RegExp(\"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n    cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n    cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n    cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n  }\n  return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0) {\n    t += 1;\n  }\n  if (t > 1) {\n    t -= 1;\n  }\n  if (t < 1 / 6) {\n    return p + (q - p) * 6 * t;\n  }\n  if (t < 1 / 2) {\n    return q;\n  }\n  if (t < 2 / 3) {\n    return p + (q - p) * (2 / 3 - t) * 6;\n  }\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n  const int = Number.parseInt(str, 10);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 255) {\n    return 255;\n  }\n  return int;\n}\nfunction parse360(str) {\n  const int = Number.parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = Number.parseFloat(str);\n  if (num < 0) {\n    return 0;\n  }\n  if (num > 1) {\n    return 255;\n  }\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = Number.parseFloat(str);\n  if (int < 0) {\n    return 0;\n  }\n  if (int > 100) {\n    return 1;\n  }\n  return int / 100;\n}\nvar colorNames = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\nfunction normalizeColor(color) {\n  const matchers = getMatchers();\n  let match;\n  if (matchers.hex6) {\n    if (match = matchers.hex6.exec(color)) {\n      return Number.parseInt(match[1] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (colorNames[color] !== undefined) {\n    return colorNames[color];\n  }\n  if (matchers.rgb) {\n    if (match = matchers.rgb.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;\n    }\n  }\n  if (matchers.rgba) {\n    if (match = matchers.rgba.exec(color)) {\n      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;\n    }\n  }\n  if (matchers.hex3) {\n    if (match = matchers.hex3.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + \"ff\", 16) >>> 0;\n    }\n  }\n  if (matchers.hex8) {\n    if (match = matchers.hex8.exec(color)) {\n      return Number.parseInt(match[1], 16) >>> 0;\n    }\n  }\n  if (matchers.hex4) {\n    if (match = matchers.hex4.exec(color)) {\n      return Number.parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;\n    }\n  }\n  if (matchers.hsl) {\n    if (match = matchers.hsl.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;\n    }\n  }\n  if (matchers.hsla) {\n    if (match = matchers.hsla.exec(color)) {\n      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;\n    }\n  }\n  throw new Error(`invalid color string ${color} provided`);\n}\nfunction processColor(color) {\n  const normalizedColor = normalizeColor(color);\n  return (normalizedColor << 24 | normalizedColor >>> 8) >>> 0;\n}\n\n// src/prores-profile.ts\nvar proResProfileOptions = [\n  \"4444-xq\",\n  \"4444\",\n  \"hq\",\n  \"standard\",\n  \"light\",\n  \"proxy\"\n];\n\n// src/v5-flag.ts\nvar ENABLE_V5_BREAKING_CHANGES = false;\n\n// src/validate-frame.ts\nvar validateFrame = ({\n  allowFloats,\n  durationInFrames,\n  frame\n}) => {\n  if (typeof frame === \"undefined\") {\n    throw new TypeError(`Argument missing for parameter \"frame\"`);\n  }\n  if (typeof frame !== \"number\") {\n    throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n  }\n  if (!Number.isFinite(frame)) {\n    throw new RangeError(`Frame ${frame} is not finite`);\n  }\n  if (frame % 1 !== 0 && !allowFloats) {\n    throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n  }\n  if (frame < 0 && frame < -durationInFrames) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n  }\n  if (frame > durationInFrames - 1) {\n    throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n  }\n};\n\n// src/codec.ts\nvar validCodecs = [\n  \"h264\",\n  \"h265\",\n  \"vp8\",\n  \"vp9\",\n  \"mp3\",\n  \"aac\",\n  \"wav\",\n  \"prores\",\n  \"h264-mkv\",\n  \"h264-ts\",\n  \"gif\"\n];\n\n// src/validation/validate-default-codec.ts\nfunction validateCodec(defaultCodec, location, name) {\n  if (typeof defaultCodec === \"undefined\") {\n    return;\n  }\n  if (typeof defaultCodec !== \"string\") {\n    throw new TypeError(`The \"${name}\" prop ${location} must be a string, but you passed a value of type ${typeof defaultCodec}.`);\n  }\n  if (!validCodecs.includes(defaultCodec)) {\n    throw new Error(`The \"${name}\" prop ${location} must be one of ${validCodecs.join(\", \")}, but you passed ${defaultCodec}.`);\n  }\n}\n\n// src/validation/validate-default-props.ts\nvar validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n  if (!defaultProps) {\n    return;\n  }\n  if (typeof defaultProps !== \"object\") {\n    throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n  }\n  if (Array.isArray(defaultProps)) {\n    throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : \"\"}`);\n  }\n};\n\n// src/validation/validate-dimensions.ts\nfunction validateDimension(amount, nameOfProp, location) {\n  if (typeof amount !== \"number\") {\n    throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n  }\n  if (isNaN(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n  }\n  if (!Number.isFinite(amount)) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n  }\n  if (amount % 1 !== 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n  }\n  if (amount <= 0) {\n    throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n  }\n}\n\n// src/validation/validate-duration-in-frames.ts\nfunction validateDurationInFrames(durationInFrames, options) {\n  const { allowFloats, component } = options;\n  if (typeof durationInFrames === \"undefined\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n  }\n  if (typeof durationInFrames !== \"number\") {\n    throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n  }\n  if (durationInFrames <= 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n  }\n  if (!allowFloats && durationInFrames % 1 !== 0) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n  }\n  if (!Number.isFinite(durationInFrames)) {\n    throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n  }\n}\n\n// src/validation/validate-fps.ts\nfunction validateFps(fps, location, isGif) {\n  if (typeof fps !== \"number\") {\n    throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n  }\n  if (!Number.isFinite(fps)) {\n    throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n  }\n  if (isNaN(fps)) {\n    throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n  }\n  if (fps <= 0) {\n    throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n  }\n  if (isGif && fps > 50) {\n    throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n  }\n}\n\n// src/video/get-current-time.ts\nvar getExpectedMediaFrameUncorrected = ({\n  frame,\n  playbackRate,\n  startFrom\n}) => {\n  return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\n\n// src/absolute-src.ts\nvar getAbsoluteSrc = (relativeSrc) => {\n  if (typeof window === \"undefined\") {\n    return relativeSrc;\n  }\n  if (relativeSrc.startsWith(\"http://\") || relativeSrc.startsWith(\"https://\") || relativeSrc.startsWith(\"file://\") || relativeSrc.startsWith(\"blob:\") || relativeSrc.startsWith(\"data:\")) {\n    return relativeSrc;\n  }\n  return new URL(relativeSrc, window.origin).href;\n};\n\n// src/video/offthread-video-source.ts\nvar getOffthreadVideoSource = ({\n  src,\n  transparent,\n  currentTime,\n  toneMapped\n}) => {\n  return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(Math.max(0, currentTime))}&transparent=${String(transparent)}&toneMapped=${String(toneMapped)}`;\n};\n\n// src/no-react.ts\nvar NoReactInternals = {\n  processColor,\n  truthy,\n  validateFps,\n  validateDimension,\n  validateDurationInFrames,\n  validateDefaultAndInputProps,\n  validateFrame,\n  serializeJSONWithSpecialTypes,\n  bundleName: \"bundle.js\",\n  bundleMapName: \"bundle.js.map\",\n  deserializeJSONWithSpecialTypes,\n  DELAY_RENDER_CALLSTACK_TOKEN,\n  DELAY_RENDER_RETRY_TOKEN,\n  DELAY_RENDER_CLEAR_TOKEN,\n  DELAY_RENDER_ATTEMPT_TOKEN: DELAY_RENDER_RETRIES_LEFT,\n  getOffthreadVideoSource,\n  getExpectedMediaFrameUncorrected,\n  ENABLE_V5_BREAKING_CHANGES,\n  MIN_NODE_VERSION: ENABLE_V5_BREAKING_CHANGES ? 18 : 16,\n  MIN_BUN_VERSION: ENABLE_V5_BREAKING_CHANGES ? \"1.1.3\" : \"1.0.3\",\n  colorNames,\n  DATE_TOKEN,\n  FILE_TOKEN,\n  validateCodec,\n  proResProfileOptions\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVtb3Rpb24vZGlzdC9lc20vbm8tcmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJCQUEyQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0EseUJBQXlCLE1BQU0sNkNBQTZDLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEVBQUUsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCLEdBQUcsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDNUUsMENBQTBDLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDNUYsMENBQTBDLEVBQUU7QUFDNUMsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbW9kZXJuaXplLW5leHQtc3RhcnRlcmtpdC8uL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9uby1yZWFjdC5tanM/MjhmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW50ZXJwb2xhdGUudHNcbmZ1bmN0aW9uIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgZXh0cmFwb2xhdGVMZWZ0LCBleHRyYXBvbGF0ZVJpZ2h0LCBlYXNpbmcgfSA9IG9wdGlvbnM7XG4gIGxldCByZXN1bHQgPSBpbnB1dDtcbiAgY29uc3QgW2lucHV0TWluLCBpbnB1dE1heF0gPSBpbnB1dFJhbmdlO1xuICBjb25zdCBbb3V0cHV0TWluLCBvdXRwdXRNYXhdID0gb3V0cHV0UmFuZ2U7XG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiaWRlbnRpdHlcIikge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJjbGFtcFwiKSB7XG4gICAgICByZXN1bHQgPSBpbnB1dE1pbjtcbiAgICB9IGVsc2UgaWYgKGV4dHJhcG9sYXRlTGVmdCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImV4dGVuZFwiKSB7fVxuICB9XG4gIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImlkZW50aXR5XCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImNsYW1wXCIpIHtcbiAgICAgIHJlc3VsdCA9IGlucHV0TWF4O1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJ3cmFwXCIpIHtcbiAgICAgIGNvbnN0IHJhbmdlID0gaW5wdXRNYXggLSBpbnB1dE1pbjtcbiAgICAgIHJlc3VsdCA9ICgocmVzdWx0IC0gaW5wdXRNaW4pICUgcmFuZ2UgKyByYW5nZSkgJSByYW5nZSArIGlucHV0TWluO1xuICAgIH0gZWxzZSBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJleHRlbmRcIikge31cbiAgfVxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpIHtcbiAgICByZXR1cm4gb3V0cHV0TWluO1xuICB9XG4gIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTtpIDwgaW5wdXRSYW5nZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBpZiAoaW5wdXRSYW5nZVtpXSA+PSBpbnB1dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBpIC0gMTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFsaWRJbnB1dFJhbmdlKGFycikge1xuICBmb3IgKGxldCBpID0gMTtpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCEoYXJyW2ldID4gYXJyW2kgLSAxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW5wdXRSYW5nZSBtdXN0IGJlIHN0cmljdGx5IG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBidXQgZ290IFske2Fyci5qb2luKFwiLFwiKX1dYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjaGVja0luZmluaXRlUmFuZ2UobmFtZSwgYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHNcIik7XG4gIH1cbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFycikge1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IG51bWJlcnNgKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtuYW1lfSBtdXN0IGNvbnRhaW4gb25seSBmaW5pdGUgbnVtYmVycywgYnV0IGdvdCBbJHthcnIuam9pbihcIixcIil9XWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIGlucHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dFJhbmdlIGNhbiBub3QgYmUgdW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh0eXBlb2Ygb3V0cHV0UmFuZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0UmFuZ2UgKFwiICsgaW5wdXRSYW5nZS5sZW5ndGggKyBcIikgYW5kIG91dHB1dFJhbmdlIChcIiArIG91dHB1dFJhbmdlLmxlbmd0aCArIFwiKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICB9XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcImlucHV0UmFuZ2VcIiwgaW5wdXRSYW5nZSk7XG4gIGNoZWNrSW5maW5pdGVSYW5nZShcIm91dHB1dFJhbmdlXCIsIG91dHB1dFJhbmdlKTtcbiAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG4gIGNvbnN0IGVhc2luZyA9IG9wdGlvbnM/LmVhc2luZyA/PyAoKG51bSkgPT4gbnVtKTtcbiAgbGV0IGV4dHJhcG9sYXRlTGVmdCA9IFwiZXh0ZW5kXCI7XG4gIGlmIChvcHRpb25zPy5leHRyYXBvbGF0ZUxlZnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlTGVmdCA9IG9wdGlvbnMuZXh0cmFwb2xhdGVMZWZ0O1xuICB9XG4gIGxldCBleHRyYXBvbGF0ZVJpZ2h0ID0gXCJleHRlbmRcIjtcbiAgaWYgKG9wdGlvbnM/LmV4dHJhcG9sYXRlUmlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBvcHRpb25zLmV4dHJhcG9sYXRlUmlnaHQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgaW50ZXJwb2xhdGUgYW4gaW5wdXQgd2hpY2ggaXMgbm90IGEgbnVtYmVyXCIpO1xuICB9XG4gIGNvbnN0IHJhbmdlID0gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKTtcbiAgcmV0dXJuIGludGVycG9sYXRlRnVuY3Rpb24oaW5wdXQsIFtpbnB1dFJhbmdlW3JhbmdlXSwgaW5wdXRSYW5nZVtyYW5nZSArIDFdXSwgW291dHB1dFJhbmdlW3JhbmdlXSwgb3V0cHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIHtcbiAgICBlYXNpbmcsXG4gICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgIGV4dHJhcG9sYXRlUmlnaHRcbiAgfSk7XG59XG4vLyBzcmMvcmFuZG9tLnRzXG5mdW5jdGlvbiBtdWxiZXJyeTMyKGEpIHtcbiAgbGV0IHQgPSBhICsgMTgzMTU2NTgxMztcbiAgdCA9IE1hdGguaW11bCh0IF4gdCA+Pj4gMTUsIHQgfCAxKTtcbiAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiB0ID4+PiA3LCB0IHwgNjEpO1xuICByZXR1cm4gKCh0IF4gdCA+Pj4gMTQpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgbGV0IGkgPSAwO1xuICBsZXQgY2hyID0gMDtcbiAgbGV0IGhhc2ggPSAwO1xuICBmb3IgKGkgPSAwO2kgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDtcbiAgfVxuICByZXR1cm4gaGFzaDtcbn1cbnZhciByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgaWYgKGR1bW15ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicmFuZG9tKCkgdGFrZXMgb25seSBvbmUgYXJndW1lbnRcIik7XG4gIH1cbiAgaWYgKHNlZWQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBpZiAodHlwZW9mIHNlZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzZWVkID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nXCIpO1xufTtcbi8vIHNyYy90cnV0aHkudHNcbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICByZXR1cm4gQm9vbGVhbih2YWx1ZSk7XG59XG5cbi8vIHNyYy9kZWxheS1yZW5kZXIudHNcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xuICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzKSB7XG4gICAgd2luZG93LnJlbW90aW9uX2RlbGF5UmVuZGVyVGltZW91dHMgPSB7fTtcbiAgfVxufVxudmFyIERFTEFZX1JFTkRFUl9DQUxMU1RBQ0tfVE9LRU4gPSBcIlRoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOlwiO1xudmFyIERFTEFZX1JFTkRFUl9SRVRSSUVTX0xFRlQgPSBcIlJldHJpZXMgbGVmdDogXCI7XG52YXIgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOID0gXCItIFJlbmRlcmluZyB0aGUgZnJhbWUgd2lsbCBiZSByZXRyaWVkLlwiO1xudmFyIERFTEFZX1JFTkRFUl9DTEVBUl9UT0tFTiA9IFwiaGFuZGxlIHdhcyBjbGVhcmVkIGFmdGVyXCI7XG5cbi8vIHNyYy9pbnB1dC1wcm9wcy1zZXJpYWxpemF0aW9uLnRzXG52YXIgREFURV9UT0tFTiA9IFwicmVtb3Rpb24tZGF0ZTpcIjtcbnZhciBGSUxFX1RPS0VOID0gXCJyZW1vdGlvbi1maWxlOlwiO1xudmFyIHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzID0gKHtcbiAgZGF0YSxcbiAgaW5kZW50LFxuICBzdGF0aWNCYXNlXG59KSA9PiB7XG4gIGxldCBjdXN0b21EYXRlVXNlZCA9IGZhbHNlO1xuICBsZXQgY3VzdG9tRmlsZVVzZWQgPSBmYWxzZTtcbiAgbGV0IG1hcFVzZWQgPSBmYWxzZTtcbiAgbGV0IHNldFVzZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXNba2V5XTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjdXN0b21EYXRlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtEQVRFX1RPS0VOfSR7aXRlbS50b0lTT1N0cmluZygpfWA7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBtYXBVc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgc2V0VXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiAmJiBzdGF0aWNCYXNlICE9PSBudWxsICYmIGl0ZW0uc3RhcnRzV2l0aChzdGF0aWNCYXNlKSkge1xuICAgICAgICBjdXN0b21GaWxlVXNlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBgJHtGSUxFX1RPS0VOfSR7aXRlbS5yZXBsYWNlKHN0YXRpY0Jhc2UgKyBcIi9cIiwgXCJcIil9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBpbmRlbnQpO1xuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRTdHJpbmcsIGN1c3RvbURhdGVVc2VkLCBjdXN0b21GaWxlVXNlZCwgbWFwVXNlZCwgc2V0VXNlZCB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3Qgc2VyaWFsaXplIHRoZSBwYXNzZWQgaW5wdXQgcHJvcHMgdG8gSlNPTjogXCIgKyBlcnIubWVzc2FnZSk7XG4gIH1cbn07XG52YXIgZGVzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyA9IChkYXRhKSA9PiB7XG4gIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIChfLCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChEQVRFX1RPS0VOKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLnJlcGxhY2UoREFURV9UT0tFTiwgXCJcIikpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN0YXJ0c1dpdGgoRklMRV9UT0tFTikpIHtcbiAgICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt2YWx1ZS5yZXBsYWNlKEZJTEVfVE9LRU4sIFwiXCIpfWA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59O1xuXG4vLyBzcmMvaW50ZXJwb2xhdGUtY29sb3JzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICByZXR1cm4gXCJcXFxcKFxcXFxzKihcIiArIGFyZ3Muam9pbihcIilcXFxccyosXFxcXHMqKFwiKSArIFwiKVxcXFxzKlxcXFwpXCI7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVycygpIHtcbiAgY29uc3QgY2FjaGVkTWF0Y2hlcnMgPSB7XG4gICAgcmdiOiB1bmRlZmluZWQsXG4gICAgcmdiYTogdW5kZWZpbmVkLFxuICAgIGhzbDogdW5kZWZpbmVkLFxuICAgIGhzbGE6IHVuZGVmaW5lZCxcbiAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgaGV4NDogdW5kZWZpbmVkLFxuICAgIGhleDU6IHVuZGVmaW5lZCxcbiAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgaGV4ODogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYiA9IG5ldyBSZWdFeHAoXCJyZ2JcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKFwicmdiYVwiICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbiAgICBjYWNoZWRNYXRjaGVycy5oc2wgPSBuZXcgUmVnRXhwKFwiaHNsXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhzbGEgPSBuZXcgUmVnRXhwKFwiaHNsYVwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UsIE5VTUJFUikpO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICBjYWNoZWRNYXRjaGVycy5oZXg0ID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KSQvO1xuICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgY2FjaGVkTWF0Y2hlcnMuaGV4OCA9IC9eIyhbMC05YS1mQS1GXXs4fSkkLztcbiAgfVxuICByZXR1cm4gY2FjaGVkTWF0Y2hlcnM7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCArPSAxO1xuICB9XG4gIGlmICh0ID4gMSkge1xuICAgIHQgLT0gMTtcbiAgfVxuICBpZiAodCA8IDEgLyA2KSB7XG4gICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gIH1cbiAgaWYgKHQgPCAxIC8gMikge1xuICAgIHJldHVybiBxO1xuICB9XG4gIGlmICh0IDwgMiAvIDMpIHtcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xUb1JnYihoLCBzLCBsKSB7XG4gIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICBjb25zdCByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICBjb25zdCBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgcmV0dXJuIE1hdGgucm91bmQociAqIDI1NSkgPDwgMjQgfCBNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2IHwgTWF0aC5yb3VuZChiICogMjU1KSA8PCA4O1xufVxuZnVuY3Rpb24gcGFyc2UyNTUoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMjU1KSB7XG4gICAgcmV0dXJuIDI1NTtcbiAgfVxuICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKG51bSA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobnVtID4gMSkge1xuICAgIHJldHVybiAyNTU7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgaWYgKGludCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAoaW50ID4gMTAwKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cbnZhciBjb2xvck5hbWVzID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICBjb25zdCBtYXRjaGVycyA9IGdldE1hdGNoZXJzKCk7XG4gIGxldCBtYXRjaDtcbiAgaWYgKG1hdGNoZXJzLmhleDYpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgXCJmZlwiLCAxNikgPj4+IDA7XG4gICAgfVxuICB9XG4gIGlmIChjb2xvck5hbWVzW2NvbG9yXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZXNbY29sb3JdO1xuICB9XG4gIGlmIChtYXRjaGVycy5yZ2IpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5yZ2IuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCAyNTUpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMucmdiYSkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLnJnYmEuZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgcGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2IHwgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDMpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIFwiZmZcIiwgMTYpID4+PiAwO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hlcnMuaGV4OCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhleDguZXhlYyhjb2xvcikpIHtcbiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhleDQpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oZXg0LmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdICsgbWF0Y2hbMV0gKyBtYXRjaFsyXSArIG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFszXSArIG1hdGNoWzRdICsgbWF0Y2hbNF0sIDE2KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbCkge1xuICAgIGlmIChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkge1xuICAgICAgcmV0dXJuIChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHwgMjU1KSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgaWYgKG1hdGNoZXJzLmhzbGEpIHtcbiAgICBpZiAobWF0Y2ggPSBtYXRjaGVycy5oc2xhLmV4ZWMoY29sb3IpKSB7XG4gICAgICByZXR1cm4gKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gMDtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNvbG9yIHN0cmluZyAke2NvbG9yfSBwcm92aWRlZGApO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbG9yKGNvbG9yKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRDb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGNvbG9yKTtcbiAgcmV0dXJuIChub3JtYWxpemVkQ29sb3IgPDwgMjQgfCBub3JtYWxpemVkQ29sb3IgPj4+IDgpID4+PiAwO1xufVxuXG4vLyBzcmMvcHJvcmVzLXByb2ZpbGUudHNcbnZhciBwcm9SZXNQcm9maWxlT3B0aW9ucyA9IFtcbiAgXCI0NDQ0LXhxXCIsXG4gIFwiNDQ0NFwiLFxuICBcImhxXCIsXG4gIFwic3RhbmRhcmRcIixcbiAgXCJsaWdodFwiLFxuICBcInByb3h5XCJcbl07XG5cbi8vIHNyYy92NS1mbGFnLnRzXG52YXIgRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPSBmYWxzZTtcblxuLy8gc3JjL3ZhbGlkYXRlLWZyYW1lLnRzXG52YXIgdmFsaWRhdGVGcmFtZSA9ICh7XG4gIGFsbG93RmxvYXRzLFxuICBkdXJhdGlvbkluRnJhbWVzLFxuICBmcmFtZVxufSkgPT4ge1xuICBpZiAodHlwZW9mIGZyYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgbWlzc2luZyBmb3IgcGFyYW1ldGVyIFwiZnJhbWVcImApO1xuICB9XG4gIGlmICh0eXBlb2YgZnJhbWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBwYXNzZWQgZm9yIFwiZnJhbWVcIiBpcyBub3QgYSBudW1iZXI6ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWUpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEZyYW1lICR7ZnJhbWV9IGlzIG5vdCBmaW5pdGVgKTtcbiAgfVxuICBpZiAoZnJhbWUgJSAxICE9PSAwICYmICFhbGxvd0Zsb2F0cykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBBcmd1bWVudCBmb3IgZnJhbWUgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZnJhbWV9YCk7XG4gIH1cbiAgaWYgKGZyYW1lIDwgMCAmJiBmcmFtZSA8IC1kdXJhdGlvbkluRnJhbWVzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgbG93ZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7LWR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gIH1cbiAgaWYgKGZyYW1lID4gZHVyYXRpb25JbkZyYW1lcyAtIDEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQ2Fubm90IHVzZSBmcmFtZSAke2ZyYW1lfTogRHVyYXRpb24gb2YgY29tcG9zaXRpb24gaXMgJHtkdXJhdGlvbkluRnJhbWVzfSwgdGhlcmVmb3JlIHRoZSBoaWdoZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7ZHVyYXRpb25JbkZyYW1lcyAtIDF9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy9jb2RlYy50c1xudmFyIHZhbGlkQ29kZWNzID0gW1xuICBcImgyNjRcIixcbiAgXCJoMjY1XCIsXG4gIFwidnA4XCIsXG4gIFwidnA5XCIsXG4gIFwibXAzXCIsXG4gIFwiYWFjXCIsXG4gIFwid2F2XCIsXG4gIFwicHJvcmVzXCIsXG4gIFwiaDI2NC1ta3ZcIixcbiAgXCJoMjY0LXRzXCIsXG4gIFwiZ2lmXCJcbl07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRlZmF1bHQtY29kZWMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlQ29kZWMoZGVmYXVsdENvZGVjLCBsb2NhdGlvbiwgbmFtZSkge1xuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRlZmF1bHRDb2RlYyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZX1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBzdHJpbmcsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkZWZhdWx0Q29kZWN9LmApO1xuICB9XG4gIGlmICghdmFsaWRDb2RlY3MuaW5jbHVkZXMoZGVmYXVsdENvZGVjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBvbmUgb2YgJHt2YWxpZENvZGVjcy5qb2luKFwiLCBcIil9LCBidXQgeW91IHBhc3NlZCAke2RlZmF1bHRDb2RlY30uYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZhbGlkYXRpb24vdmFsaWRhdGUtZGVmYXVsdC1wcm9wcy50c1xudmFyIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMgPSAoZGVmYXVsdFByb3BzLCBuYW1lLCBjb21wb3NpdGlvbklkKSA9PiB7XG4gIGlmICghZGVmYXVsdFByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmYXVsdFByb3BzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGRlZmF1bHRQcm9wc31gKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0UHJvcHMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBtdXN0IGJlIGFuIG9iamVjdCwgYW4gYXJyYXkgd2FzIHBhc3NlZCAke2NvbXBvc2l0aW9uSWQgPyBgZm9yIGNvbXBvc2l0aW9uIFwiJHtjb21wb3NpdGlvbklkfVwiYCA6IFwiXCJ9YCk7XG4gIH1cbn07XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWRpbWVuc2lvbnMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRGltZW5zaW9uKGFtb3VudCwgbmFtZU9mUHJvcCwgbG9jYXRpb24pIHtcbiAgaWYgKHR5cGVvZiBhbW91bnQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBhbW91bnR9YCk7XG4gIH1cbiAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBpcyBOYU4uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYW1vdW50KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgZmluaXRlLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgJSAxICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgaXMgJHthbW91bnR9LmApO1xuICB9XG4gIGlmIChhbW91bnQgPD0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHthbW91bnR9LmApO1xuICB9XG59XG5cbi8vIHNyYy92YWxpZGF0aW9uL3ZhbGlkYXRlLWR1cmF0aW9uLWluLWZyYW1lcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBhbGxvd0Zsb2F0cywgY29tcG9uZW50IH0gPSBvcHRpb25zO1xuICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBpcyBtaXNzaW5nLmApO1xuICB9XG4gIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gXCJudW1iZXJcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBkdXJhdGlvbkluRnJhbWVzfWApO1xuICB9XG4gIGlmIChkdXJhdGlvbkluRnJhbWVzIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICB9XG4gIGlmICghYWxsb3dGbG9hdHMgJiYgZHVyYXRpb25JbkZyYW1lcyAlIDEgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25JbkZyYW1lcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgfVxufVxuXG4vLyBzcmMvdmFsaWRhdGlvbi92YWxpZGF0ZS1mcHMudHNcbmZ1bmN0aW9uIHZhbGlkYXRlRnBzKGZwcywgbG9jYXRpb24sIGlzR2lmKSB7XG4gIGlmICh0eXBlb2YgZnBzICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcImZwc1wiIG11c3QgYmUgYSBudW1iZXIsIGJ1dCB5b3UgcGFzc2VkIGEgdmFsdWUgb2YgdHlwZSAke3R5cGVvZiBmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IGJlIGEgZmluaXRlLCBidXQgeW91IHBhc3NlZCAke2Zwc30gJHtsb2NhdGlvbn1gKTtcbiAgfVxuICBpZiAoaXNOYU4oZnBzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gIH1cbiAgaWYgKGZwcyA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCJmcHNcIiBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7ZnBzfSAke2xvY2F0aW9ufWApO1xuICB9XG4gIGlmIChpc0dpZiAmJiBmcHMgPiA1MCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBGUFMgZm9yIGEgR0lGIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiA1MC4gVXNlIHRoZSAtLWV2ZXJ5LW50aC1mcmFtZSBvcHRpb24gdG8gbG93ZXIgdGhlIEZQUzogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9yZW5kZXItYXMtZ2lmYCk7XG4gIH1cbn1cblxuLy8gc3JjL3ZpZGVvL2dldC1jdXJyZW50LXRpbWUudHNcbnZhciBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCA9ICh7XG4gIGZyYW1lLFxuICBwbGF5YmFja1JhdGUsXG4gIHN0YXJ0RnJvbVxufSkgPT4ge1xuICByZXR1cm4gaW50ZXJwb2xhdGUoZnJhbWUsIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyAxXSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIHBsYXliYWNrUmF0ZV0pO1xufTtcblxuLy8gc3JjL2Fic29sdXRlLXNyYy50c1xudmFyIGdldEFic29sdXRlU3JjID0gKHJlbGF0aXZlU3JjKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlU3JjO1xuICB9XG4gIGlmIChyZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiaHR0cDovL1wiKSB8fCByZWxhdGl2ZVNyYy5zdGFydHNXaXRoKFwiaHR0cHM6Ly9cIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikgfHwgcmVsYXRpdmVTcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpIHx8IHJlbGF0aXZlU3JjLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIHJldHVybiByZWxhdGl2ZVNyYztcbiAgfVxuICByZXR1cm4gbmV3IFVSTChyZWxhdGl2ZVNyYywgd2luZG93Lm9yaWdpbikuaHJlZjtcbn07XG5cbi8vIHNyYy92aWRlby9vZmZ0aHJlYWQtdmlkZW8tc291cmNlLnRzXG52YXIgZ2V0T2ZmdGhyZWFkVmlkZW9Tb3VyY2UgPSAoe1xuICBzcmMsXG4gIHRyYW5zcGFyZW50LFxuICBjdXJyZW50VGltZSxcbiAgdG9uZU1hcHBlZFxufSkgPT4ge1xuICByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6JHt3aW5kb3cucmVtb3Rpb25fcHJveHlQb3J0fS9wcm94eT9zcmM9JHtlbmNvZGVVUklDb21wb25lbnQoZ2V0QWJzb2x1dGVTcmMoc3JjKSl9JnRpbWU9JHtlbmNvZGVVUklDb21wb25lbnQoTWF0aC5tYXgoMCwgY3VycmVudFRpbWUpKX0mdHJhbnNwYXJlbnQ9JHtTdHJpbmcodHJhbnNwYXJlbnQpfSZ0b25lTWFwcGVkPSR7U3RyaW5nKHRvbmVNYXBwZWQpfWA7XG59O1xuXG4vLyBzcmMvbm8tcmVhY3QudHNcbnZhciBOb1JlYWN0SW50ZXJuYWxzID0ge1xuICBwcm9jZXNzQ29sb3IsXG4gIHRydXRoeSxcbiAgdmFsaWRhdGVGcHMsXG4gIHZhbGlkYXRlRGltZW5zaW9uLFxuICB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMsXG4gIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMsXG4gIHZhbGlkYXRlRnJhbWUsXG4gIHNlcmlhbGl6ZUpTT05XaXRoU3BlY2lhbFR5cGVzLFxuICBidW5kbGVOYW1lOiBcImJ1bmRsZS5qc1wiLFxuICBidW5kbGVNYXBOYW1lOiBcImJ1bmRsZS5qcy5tYXBcIixcbiAgZGVzZXJpYWxpemVKU09OV2l0aFNwZWNpYWxUeXBlcyxcbiAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgREVMQVlfUkVOREVSX1JFVFJZX1RPS0VOLFxuICBERUxBWV9SRU5ERVJfQ0xFQVJfVE9LRU4sXG4gIERFTEFZX1JFTkRFUl9BVFRFTVBUX1RPS0VOOiBERUxBWV9SRU5ERVJfUkVUUklFU19MRUZULFxuICBnZXRPZmZ0aHJlYWRWaWRlb1NvdXJjZSxcbiAgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQsXG4gIEVOQUJMRV9WNV9CUkVBS0lOR19DSEFOR0VTLFxuICBNSU5fTk9ERV9WRVJTSU9OOiBFTkFCTEVfVjVfQlJFQUtJTkdfQ0hBTkdFUyA/IDE4IDogMTYsXG4gIE1JTl9CVU5fVkVSU0lPTjogRU5BQkxFX1Y1X0JSRUFLSU5HX0NIQU5HRVMgPyBcIjEuMS4zXCIgOiBcIjEuMC4zXCIsXG4gIGNvbG9yTmFtZXMsXG4gIERBVEVfVE9LRU4sXG4gIEZJTEVfVE9LRU4sXG4gIHZhbGlkYXRlQ29kZWMsXG4gIHByb1Jlc1Byb2ZpbGVPcHRpb25zXG59O1xuZXhwb3J0IHtcbiAgcmFuZG9tLFxuICBpbnRlcnBvbGF0ZSxcbiAgTm9SZWFjdEludGVybmFsc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/remotion/dist/esm/no-react.mjs\n");

/***/ })

};
;